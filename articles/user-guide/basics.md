---
title: 'Q # alapjai'
description: 'A Q alapvető fogalmai #'
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 02/28/2020
ms.topic: article
uid: microsoft.quantum.guide.basics
ms.openlocfilehash: 45e6f2f33dafc2aec177091d3cfa94aca14fbf0a
ms.sourcegitcommit: af10179284967bd7a72a52ae7e1c4da65c7d128d
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 06/26/2020
ms.locfileid: "85415359"
---
# <a name="q-basics"></a><span data-ttu-id="e3d1d-103">Q # alapjai</span><span class="sxs-lookup"><span data-stu-id="e3d1d-103">Q# Basics</span></span>

<span data-ttu-id="e3d1d-104">Ez a cikk röviden bemutatja a Q # alapszintű építőelemeit.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-104">This article presents a brief introduction to the basic building blocks of Q#.</span></span>

<span data-ttu-id="e3d1d-105">A Q #-ról és a Quantum Development Kit alapvető összetevőinek áttekintéséhez lásd: [Mi a q #?](xref:microsoft.quantum.overview.q-sharp).</span><span class="sxs-lookup"><span data-stu-id="e3d1d-105">For an overview of what Q# is and where it fits in as a fundamental component of the Quantum Development Kit, see [What is Q#?](xref:microsoft.quantum.overview.q-sharp).</span></span> 

## <a name="what-is-a-quantum-program"></a><span data-ttu-id="e3d1d-106">Mi az a Quantum program?</span><span class="sxs-lookup"><span data-stu-id="e3d1d-106">What is a quantum program?</span></span>

<span data-ttu-id="e3d1d-107">Technikai szempontból a Quantum program a klasszikus alrutinok egy adott készlete, amely a híváskor bizonyos műveleteket hajt végre a kvantum-rendszeren.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-107">From a technical perspective, a quantum program is a particular set of classical subroutines which, when called, perform certain operations on a quantum system.</span></span>
<span data-ttu-id="e3d1d-108">Ennek a nézetnek a fontos következménye, hogy a Q # program nem qubits magukat közvetlenül, hanem leírja, hogyan kommunikál a klasszikusan vezérelt számítógépek a qubits.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-108">An important consequence of that view is that a Q# program does not directly model qubits themselves, but rather describes how a classically controlled computer interacts with those qubits.</span></span>
<span data-ttu-id="e3d1d-109">A tervezés szerint a Q # nem határozza meg a kvantum-állapotokat vagy a kvantummechanika egyéb tulajdonságait közvetlenül.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-109">By design, Q# does not define quantum states or other properties of quantum mechanics directly.</span></span>
<span data-ttu-id="e3d1d-110">Vegyük például a {0} {1} {2} [Quantum Computing fogalmakat](xref:microsoft.quantum.concepts.intro) ismertető útmutatóban a $ \ket{+} = \left (\ket + \ket \right)/\sqrt $ állapotot.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-110">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="e3d1d-111">Ha ezt az állapotot a Q #-ban szeretné előkészíteni, kezdje azzal a ténnyel, hogy a qubits a $ \ket {0} $ állapotban inicializálják, és hogy a $ \ket{+} = H\ket {0} $, ahol a $H $ a [ `H` művelet](xref:microsoft.quantum.intrinsic.h)által megvalósított [Hadamard-transzformáció](xref:microsoft.quantum.glossary#hadamard).</span><span class="sxs-lookup"><span data-stu-id="e3d1d-111">To prepare this state in Q#, start with the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the [Hadamard transform](xref:microsoft.quantum.glossary#hadamard), implemented by the [`H` operation](xref:microsoft.quantum.intrinsic.h).</span></span> <span data-ttu-id="e3d1d-112">A qubit inicializálásához és átalakításához szükséges alapszintű Q # kód a következőképpen néz ki:</span><span class="sxs-lookup"><span data-stu-id="e3d1d-112">The basic Q# code to initialize and transform a qubit, then, looks like this:</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, the qubit is in the state |0⟩.
    H(qubit);
    // H is now applied, such that the qubit is in H|0⟩ = |+⟩, as desired.
}
```
<span data-ttu-id="e3d1d-113">A qubits inicializálásával és *lefoglalásával*kapcsolatos további információkért lásd: [a qubits használata](xref:microsoft.quantum.guide.qubits).</span><span class="sxs-lookup"><span data-stu-id="e3d1d-113">For more information on initializing, or *allocating*, qubits, see [Working with qubits](xref:microsoft.quantum.guide.qubits).</span></span>

## <a name="quantum-states-in-q"></a><span data-ttu-id="e3d1d-114">Quantum állapotok a Q-ban #</span><span class="sxs-lookup"><span data-stu-id="e3d1d-114">Quantum states in Q#</span></span>

<span data-ttu-id="e3d1d-115">Fontos, hogy az előző program nem hivatkozik kifejezetten a Q # állapotára, de azt is ismertette, hogy a program hogyan *alakította át* az állapotot.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-115">Importantly, the previous program does not explicitly refer to the state within Q# but described how our program *transformed* the state.</span></span>
<span data-ttu-id="e3d1d-116">Ezzel a megközelítéssel teljesen agnosztikus lehet arról, hogy mi *is az egyes* célszámítógépen a kvantum-állapot, ami eltérő értelmezésekkel rendelkezhet a számítógéptől függően.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-116">With this approach, you can be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="e3d1d-117">A Q # program nem tud betekintést kimutatni egy qubit állapotával.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-117">A Q# program cannot introspect into the state of a qubit.</span></span>
<span data-ttu-id="e3d1d-118">Ehelyett egy program olyan műveleteket hívhat meg, mint például a [`Measure`](xref:microsoft.quantum.intrinsic.measure) qubit származó információk megismerése, és olyan műveletek hívása, mint például a [`X`](xref:microsoft.quantum.intrinsic.x) és a [`H`](xref:microsoft.quantum.intrinsic.h) qubit állapotának elvégzése.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-118">Instead, a program can call operations such as [`Measure`](xref:microsoft.quantum.intrinsic.measure) to learn information from a qubit, and call operations such as [`X`](xref:microsoft.quantum.intrinsic.x) and [`H`](xref:microsoft.quantum.intrinsic.h) to act on the state of a qubit.</span></span>
<span data-ttu-id="e3d1d-119">Ezeket a műveleteket ténylegesen csak az adott Q # program futtatására használt *célszámítógép végzi.*</span><span class="sxs-lookup"><span data-stu-id="e3d1d-119">What these operations actually *do* is only made concrete by the target machine used to run the particular Q# program.</span></span>
<span data-ttu-id="e3d1d-120">Ha például a programot a [teljes állapotú szimulátoron](xref:microsoft.quantum.machines.full-state-simulator)futtatja, a szimulátor a szimulált kvantum-rendszernek megfelelő matematikai műveleteket hajtja végre.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-120">For example, if running the program on our [full-state simulator](xref:microsoft.quantum.machines.full-state-simulator), the simulator performs the corresponding mathematical operations to the simulated quantum system.</span></span>
<span data-ttu-id="e3d1d-121">De a jövő irányába szemlélve, amikor a célszámítógép egy valódi kvantum-számítógép, a Q #-ban az ilyen műveletek meghívásával a kvantum-számítógép elvégzi a megfelelő *valós* műveleteket a *valós* kvantum-rendszeren, például pontosan időzített lézeres impulzusokat.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-121">But looking toward the future, when the target machine is a real quantum computer, calling such operations in Q# directs the quantum computer to perform the corresponding *real* operations on the *real* quantum system, for example, precisely timed laser pulses).</span></span>

<span data-ttu-id="e3d1d-122">A Q # program újrakombinálja ezeket a műveleteket a célszámítógép által meghatározott módon, hogy új, magasabb szintű műveleteket hozzon létre a kvantum-számításokhoz.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-122">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="e3d1d-123">Így a Q # megkönnyíti a Quantum és a hibrid kvantum – klasszikus algoritmusok kiépítését, és egyúttal általános megoldást is biztosít a célszámítógép vagy a szimulátor struktúrájára vonatkozóan.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-123">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum–classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="e3d1d-124">Q # műveletek és függvények</span><span class="sxs-lookup"><span data-stu-id="e3d1d-124">Q# operations and functions</span></span>

<span data-ttu-id="e3d1d-125">Konkrétan a Q # program a *műveleteket*, a *függvényeket*és a felhasználó által definiált típusokat tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-125">Concretely, a Q# program comprises *operations*, *functions*, and any user-defined types.</span></span> 

<span data-ttu-id="e3d1d-126">A műveletek a kvantum-rendszerek átalakításának leírására szolgálnak, és a Q # programok legalapvetőbb építőelemei.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-126">Operations are used to describe the transformations of quantum systems and are the most fundamental building block of Q# programs.</span></span> <span data-ttu-id="e3d1d-127">A Q # által meghatározott minden művelet hívhat meg tetszőleges számú egyéb műveletet.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-127">Each operation defined in Q# may then call any number of other operations.</span></span>

<span data-ttu-id="e3d1d-128">A műveletekkel szemben a functions a tisztán *determinisztikus* klasszikus viselkedés leírására szolgál, és nem gyakorol semmilyen hatást a klasszikus számítástechnikai értékek mellett.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-128">In contrast to operations, functions are used to describe purely *deterministic* classical behavior and do not have any effects besides computing classical values.</span></span> <span data-ttu-id="e3d1d-129">Tegyük fel például, hogy egy program végén szeretné mérni a qubits, és hozzáadja a mérési eredményeket egy tömbhöz.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-129">For example, suppose you want to measure the qubits at the end of a program and add the measurement results to an array.</span></span>
<span data-ttu-id="e3d1d-130">Ebben az esetben `Measure` egy *művelet* , amely arra utasítja a célszámítógépet, hogy a (valós vagy szimulált) qubits mérést végezzen.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-130">In this case, `Measure` is an *operation* that instructs the target machine to perform a measurement on the (real or simulated) qubits.</span></span> <span data-ttu-id="e3d1d-131">Ugyanakkor a *functions* kezeli a visszaadott eredmények tömbbe való felvételének klasszikus folyamatát.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-131">At the same time, *functions* handle the classical process of adding the returned results to an array.</span></span>

<span data-ttu-id="e3d1d-132">A műveletek és a függvények együtt *callables*néven ismertek.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-132">Together, operations and functions are known as *callables*.</span></span> <span data-ttu-id="e3d1d-133">A rendszer az alapul szolgáló struktúrát és viselkedést a [Q #-ban ismertetett műveletekben és funkciókban](xref:microsoft.quantum.guide.operationsfunctions)részletezi.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-133">Their underlying structure and behavior are introduced and detailed in [Operations and Functions in Q#](xref:microsoft.quantum.guide.operationsfunctions).</span></span>


## <a name="q-syntax-overview"></a><span data-ttu-id="e3d1d-134">Q # szintaxis – áttekintés</span><span class="sxs-lookup"><span data-stu-id="e3d1d-134">Q# syntax overview</span></span>

<span data-ttu-id="e3d1d-135">A nyelv szintaxisa a szintaktikai módon helyes programot alkotó szimbólumok különböző kombinációit írja le.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-135">The syntax of a language describes the different combinations of symbols that form a syntactically correct program.</span></span>
<span data-ttu-id="e3d1d-136">A Q #-ban a szintaktikai elemek három különböző csoportba sorolhatók: típusok, kifejezések és utasítások.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-136">In Q#, syntax elements are classified into three different groups: types, expressions, and statements.</span></span>

### <a name="types"></a><span data-ttu-id="e3d1d-137">Típusok</span><span class="sxs-lookup"><span data-stu-id="e3d1d-137">Types</span></span>
<span data-ttu-id="e3d1d-138">A q # egy erősen gépelt nyelv, amely lehetővé teszi, hogy a típusok körültekintő használata segíthet a fordítónak a Q # programokkal kapcsolatos erős garanciák megadásában a fordítás ideje alatt.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-138">Q# is a strongly-typed language, such that careful use of types can help the compiler provide strong guarantees about Q# programs at compile time.</span></span>
<span data-ttu-id="e3d1d-139">A standard és a kvantum-specifikus beépített primitív típusok (például,,, `Int` `Bool` és) mellett a `Qubit` `Result` Q # támogatja a felhasználó által definiált típusokat.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-139">In addition to standard and quantum-specific built-in primitive types, for example, `Int`, `Bool`, `Qubit`, and `Result`, Q# provides support for user-defined types.</span></span>

<span data-ttu-id="e3d1d-140">Az összes primitív típus leírását, a tömb és a rekord típusának részleteit, valamint az új típusok Q # fájlon belüli definiálásának lépéseit lásd: [types in q #](xref:microsoft.quantum.guide.types).</span><span class="sxs-lookup"><span data-stu-id="e3d1d-140">For descriptions of all the primitive types, details for array and tuple types, and steps to define new types within a Q# file, see [Types in Q#](xref:microsoft.quantum.guide.types).</span></span>

### <a name="expressions"></a><span data-ttu-id="e3d1d-141">Kifejezések</span><span class="sxs-lookup"><span data-stu-id="e3d1d-141">Expressions</span></span>
<span data-ttu-id="e3d1d-142">A programozási nyelv kifejezése egy vagy több állandó, változó, operátor és függvény kombinációja, amelyet a programozási nyelv értelmez és kiértékel egy adott értékre.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-142">An expression in a programming language is a combination of one or more constants, variables, operators, and functions that the programming language interprets and evaluates to a specific value.</span></span>
<span data-ttu-id="e3d1d-143">A legtöbb esetben a nyelv minden típusához az adott típusú kifejezés lehet *literál* vagy szimbólum, amely egy adott típusú értékhez van kötve.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-143">Most simply, for every type in a language, expressions of that type can be either *literals* or symbols bound to a value of that type.</span></span>
<span data-ttu-id="e3d1d-144">Például `5` egy `Int` literál (azaz típusú kifejezés `Int` ), és ha a szimbólum az `count` egész értékhez van kötve `5` , akkor az `count` egész szám kifejezés is.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-144">For example, `5` is an `Int` literal (thus also an expression of type `Int`), and if the symbol `count` is bound to the integer value `5`, then `count` is also an integer expression.</span></span>

<span data-ttu-id="e3d1d-145">Egy kifejezés továbbá tartalmazhat más, bizonyos operátorok által összevont kifejezéseket is.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-145">Additionally, an expression can consist of other expressions combined by certain operators.</span></span>
<span data-ttu-id="e3d1d-146">Például egy másik `Int` kifejezés, amely kiértékeli a következőt: `5` `2+3` .</span><span class="sxs-lookup"><span data-stu-id="e3d1d-146">For example, another `Int` expression that evaluates to `5` is `2+3`.</span></span>

<span data-ttu-id="e3d1d-147">A Q # kifejezésekkel és kompatibilis operátorokkal kapcsolatos további információkért lásd: [kifejezések megadása a q #](xref:microsoft.quantum.guide.expressions)-ban.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-147">For more information about expressions and compatible operators in Q#, see [Type Expressions in Q#](xref:microsoft.quantum.guide.expressions).</span></span> 

### <a name="statements"></a><span data-ttu-id="e3d1d-148">Utasítások</span><span class="sxs-lookup"><span data-stu-id="e3d1d-148">Statements</span></span> 
<span data-ttu-id="e3d1d-149">Az utasítás egy kötelező programozási nyelv szintaktikai egysége, amely némi művelet elvégzését fejezi ki. Az utasításokban szereplő kifejezések kontrasztja nem ad eredményül az eredményeket, és kizárólag azok mellékhatásait hajtja végre.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-149">A statement is a syntactic unit of an imperative programming language that expresses some action to carry out. Statements contrast with expressions in that statements do not return results and are executed solely for their side effects.</span></span> <span data-ttu-id="e3d1d-150">A kifejezések azonban mindig visszaadnak egy eredményt, és gyakran nincsenek mellékhatásai.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-150">Expressions, however, always return a result and often do not have side effects at all.</span></span> <span data-ttu-id="e3d1d-151">A short, a Q # utasítások végrehajtásakor a rendszer kiértékeli a kifejezéseket.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-151">In short, Q# statements are executed, while expressions are evaluated.</span></span>

<span data-ttu-id="e3d1d-152">A Q # egyik utasításának egyszerű példája egy szimbólum társítása egy kifejezéshez:</span><span class="sxs-lookup"><span data-stu-id="e3d1d-152">A simple example of a statement in Q# is assigning a symbol to an expression:</span></span>
```qsharp
let count = 5;
```

<span data-ttu-id="e3d1d-153">Érdekes példa az `for` iterációt támogató utasítás, amely egy *utasítási blokkot*tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-153">A more interesting example is the `for` statement which supports iteration and includes a *statement block*.</span></span>
<span data-ttu-id="e3d1d-154">Tegyük fel, `qubits` hogy a szimbólum a qubits (technika típusa `Qubit[]` vagy típusú tömb) egy regiszteréhez van kötve `Qubit` .</span><span class="sxs-lookup"><span data-stu-id="e3d1d-154">Suppose `qubits` is the symbol bound to a register of qubits (technically of type `Qubit[]`, or an array of `Qubit` types).</span></span> <span data-ttu-id="e3d1d-155">Majd</span><span class="sxs-lookup"><span data-stu-id="e3d1d-155">Then</span></span>
```qsharp
for (qubit in qubits) {
    H(qubit);
}
```
<span data-ttu-id="e3d1d-156">a egy olyan utasítás, amely a regisztráció minden qubit megismétli a műveletet, és mindegyiken végrehajtja a `H` műveletet.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-156">is a statement that iterates over each qubit in the register, performing the `H` operation on each one.</span></span> <span data-ttu-id="e3d1d-157">Vegye figyelembe, hogy `H(qubit);` egy utasítás önmagában is szerepel.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-157">Note that `H(qubit);` is a statement in itself as well.</span></span>

<span data-ttu-id="e3d1d-158">Bármilyen típusú hívási kifejezést használhat `Unit` (a `Unit` típus nem ad vissza adatokat) utasításként.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-158">You can use any call expression of type `Unit` (a `Unit` type does not return any information) as a statement.</span></span>
<span data-ttu-id="e3d1d-159">Ez a típusú kifejezés akkor hasznos, ha olyan qubits-műveleteket hív meg, amelyek visszaadnak, `Unit` mert az utasítás célja az implicit kvantum állapotának módosítása.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-159">This type of expression is useful when calling operations on qubits that return `Unit` because the purpose of the statement is to modify the implicit quantum state.</span></span>
<span data-ttu-id="e3d1d-160">A kifejezés-értékelési utasításokhoz pontosvesszőt kell lezárni.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-160">Expression evaluation statements require a terminating semicolon.</span></span>

<span data-ttu-id="e3d1d-161">Egy Q # program szinte minden aspektusának összeállításához utasításokkal kell elkészíteni, és egyetlen oldal sem terjedhet ki a rájuk vonatkozó összes információra.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-161">You use statements to build nearly every aspect of a Q# program, and no single page could encompass all the information relating to them.</span></span>
<span data-ttu-id="e3d1d-162">További információ a lexikális szerkezetről és a formázásról: [Q # file Structure](xref:microsoft.quantum.guide.filestructure); a szimbólum-kötési hozzárendelés és a hatókör esetében lásd: [változók a Q #](xref:microsoft.quantum.guide.variables); és a vezérlési folyamathoz kapcsolódó hurkok `for` , például: [vezérlési folyamat a Q #-ban](xref:microsoft.quantum.guide.controlflow).</span><span class="sxs-lookup"><span data-stu-id="e3d1d-162">For more information about their lexical structure and formatting, see [Q# File Structure](xref:microsoft.quantum.guide.filestructure); for symbol binding assignment and scope, see [Variables in Q#](xref:microsoft.quantum.guide.variables); and for control flow loops such as `for`, see [Control Flow in Q#](xref:microsoft.quantum.guide.controlflow).</span></span>

## <a name="next-steps"></a><span data-ttu-id="e3d1d-163">További lépések</span><span class="sxs-lookup"><span data-stu-id="e3d1d-163">Next steps</span></span>

<span data-ttu-id="e3d1d-164">Megkezdheti [a Q #-beli típusok](xref:microsoft.quantum.guide.types)megismerését.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-164">Start learning about [Types in Q#](xref:microsoft.quantum.guide.types).</span></span>

<span data-ttu-id="e3d1d-165">Ha többet szeretne megtudni az alapjairól és a Q # mögötti motivációról, olvassa el a [Miért van szükségünk q #?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/)című témakört.</span><span class="sxs-lookup"><span data-stu-id="e3d1d-165">For more background about the foundations and motivation behind Q#, see [Why do we need Q#?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span></span>
