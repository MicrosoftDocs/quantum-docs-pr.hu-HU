---
title: 'Q # alapjai'
description: 'A Q alapvető fogalmai #'
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 02/28/2020
ms.topic: article
uid: microsoft.quantum.guide.basics
ms.openlocfilehash: fd0ea47f00b1456ec460808ef7d451c8427677cd
ms.sourcegitcommit: 2317473fdf2b80de58db0f43b9fcfb57f56aefff
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 05/15/2020
ms.locfileid: "83431155"
---
# <a name="q-basics"></a><span data-ttu-id="d1fdd-103">Q # alapjai</span><span class="sxs-lookup"><span data-stu-id="d1fdd-103">Q# Basics</span></span>

<span data-ttu-id="d1fdd-104">Ebben a szakaszban röviden bemutatjuk a Q # alapszintű építőelemeit.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-104">In this section we present a brief introduction to the basic building blocks of Q#.</span></span>

<span data-ttu-id="d1fdd-105">Ha gyors áttekintést szeretne arról, hogy mi a Q #, és hogyan illeszkedik a Quantum Development Kit alapvető összetevőjéhez, tekintse meg a következőt: [Mi a q #?](xref:microsoft.quantum.overview.q-sharp).</span><span class="sxs-lookup"><span data-stu-id="d1fdd-105">For a quick overview of what Q# is and where it fits in as a fundamental component of the Quantum Development Kit, you can check out [What is Q#?](xref:microsoft.quantum.overview.q-sharp).</span></span> 

## <a name="what-is-a-quantum-program"></a><span data-ttu-id="d1fdd-106">Mi az a Quantum program?</span><span class="sxs-lookup"><span data-stu-id="d1fdd-106">What is a quantum program?</span></span>

<span data-ttu-id="d1fdd-107">Technikai szempontból a kvantum-program a klasszikus alrutinok egy adott készletét láthatja, amely a híváskor bizonyos műveleteket hajt végre a kvantum-rendszeren.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-107">From a technical perspective, a quantum program can be seen as a particular set of classical subroutines which, when called, perform certain operations on a quantum system.</span></span>
<span data-ttu-id="d1fdd-108">Ennek a nézetnek a fontos következménye, hogy a Q #-ban írt program nem qubits magukat közvetlenül, hanem azt is leírja, hogyan kommunikál a klasszikus vezérlő számítógépek a qubits.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-108">An important consequence of that view is that a program written in Q# does not directly model qubits themselves, but rather describes how a classical control computer interacts with those qubits.</span></span>
<span data-ttu-id="d1fdd-109">A tervezés szerint a Q # így nem határozza meg a kvantum-állapotokat vagy a kvantummechanika egyéb tulajdonságait közvetlenül.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-109">By design, Q# thus does not define quantum states or other properties of quantum mechanics directly.</span></span>
<span data-ttu-id="d1fdd-110">Vegyük például a {0} {1} {2} [Quantum Computing fogalmakat](xref:microsoft.quantum.concepts.intro) ismertető útmutatóban a $ \ket{+} = \left (\ket + \ket \right)/\sqrt $ állapotot.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-110">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="d1fdd-111">Ha ezt az állapotot Q #-ban szeretné felkészíteni, a qubits a $ \ket {0} $ állapotú, és a $ \ket{+} = H\ket {0} $, ahol a $H $ érték a [ `H` művelet] (] (xref: Microsoft. Quantum. belső. H) által megvalósított Hadamard átalakítást használja:</span><span class="sxs-lookup"><span data-stu-id="d1fdd-111">To prepare this state in Q#, we use the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the Hadamard transform, implemented by the [`H` operation](](xref:microsoft.quantum.intrinsic.h):</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0⟩.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0⟩ = |+⟩, as we wanted.
}
```

## <a name="quantum-states-in-q"></a><span data-ttu-id="d1fdd-112">Quantum állapotok a Q-ban #</span><span class="sxs-lookup"><span data-stu-id="d1fdd-112">Quantum states in Q#</span></span>

<span data-ttu-id="d1fdd-113">Fontos, hogy a fenti program írásakor nem kifejezetten a Q #-on belüli állapotra hivatkozunk, hanem azt is, hogy a program hogyan *alakította át* az állapotot.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-113">Importantly, in writing the above program, we did not explicitly refer to the state within Q#, but rather described how the state was *transformed* by our program.</span></span>
<span data-ttu-id="d1fdd-114">Ez lehetővé teszi számunkra, hogy teljesen függetlenek legyenek attól, hogy milyen kvantum-állapotot biztosítanak *az egyes* célszámítógépeken, ami különböző értelmezésekkel rendelkezhet a gépen.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-114">This allows us to be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="d1fdd-115">A Q # programnak nincs lehetősége arra, hogy betekintést qubit az állapotba.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-115">A Q# program has no ability to introspect into the state of a qubit.</span></span>
<span data-ttu-id="d1fdd-116">A program Ehelyett olyan műveleteket hívhat meg, mint például a [`Measure`](xref:microsoft.quantum.intrinsic.measure) qubit származó információk megismerése, és olyan műveletek hívása, mint a [`X`](xref:microsoft.quantum.intrinsic.x) és a [`H`](xref:microsoft.quantum.intrinsic.h) qubit állapotának elvégzése.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-116">Rather, a program can call operations such as [`Measure`](xref:microsoft.quantum.intrinsic.measure) to learn information from a qubit, and call operations such as [`X`](xref:microsoft.quantum.intrinsic.x) and [`H`](xref:microsoft.quantum.intrinsic.h) to act on the state of a qubit.</span></span>
<span data-ttu-id="d1fdd-117">Ezeket a műveleteket ténylegesen csak az adott Q # program futtatásához használt célszámítógép *végzi el.*</span><span class="sxs-lookup"><span data-stu-id="d1fdd-117">What these operations actually *do* is only made concrete by the target machine we use to run the particular Q# program.</span></span>
<span data-ttu-id="d1fdd-118">Ha például a programot a [teljes állapotú szimulátoron](xref:microsoft.quantum.machines.full-state-simulator)futtatja, a szimulátor a szimulált Quantum rendszernek megfelelő matematikai műveleteket hajtja végre.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-118">For example, if running the program on our [full-state simulator](xref:microsoft.quantum.machines.full-state-simulator), the simulator will perform the corresponding mathematical operations to the simulated quantum system.</span></span>
<span data-ttu-id="d1fdd-119">De a jövő irányába szemlélve, amikor a célszámítógép egy valódi kvantum-számítógép, a Q #-ban az ilyen műveletek meghívásával irányítja a kvantum-számítógépet, hogy végrehajtsa a megfelelő *valós* műveleteket a *valós* kvantum-rendszeren (például a pontosan időzített lézeres impulzusok esetében).</span><span class="sxs-lookup"><span data-stu-id="d1fdd-119">But looking toward the future, when the target machine is a real quantum computer, calling such operations in Q# will direct the quantum computer to perform the corresponding *real* operations on the *real* quantum system (e.g. precisely timed laser pulses).</span></span>

<span data-ttu-id="d1fdd-120">A Q # program újrakombinálja ezeket a műveleteket a célszámítógép által meghatározott módon, hogy új, magasabb szintű műveleteket hozzon létre a kvantum-számításokhoz.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-120">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="d1fdd-121">Így a Q # megkönnyíti a Quantum és a hibrid kvantum – klasszikus algoritmusok kiépítését, és egyúttal általános megoldást is biztosít a célszámítógép vagy a szimulátor struktúrájára vonatkozóan.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-121">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum–classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="d1fdd-122">Q # műveletek és függvények</span><span class="sxs-lookup"><span data-stu-id="d1fdd-122">Q# operations and functions</span></span>

<span data-ttu-id="d1fdd-123">Konkrétan a Q # program *műveletekből*, *függvényekből*és bármely felhasználó által definiált típusból áll.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-123">Concretely, a Q# program is comprised of *operations*, *functions*, and any user-defined types.</span></span> 

<span data-ttu-id="d1fdd-124">A műveletek a kvantum-rendszerek átalakításának leírására szolgálnak, és a Q # programok legalapvetőbb építőelemei.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-124">Operations are used to describe the transformations of quantum systems and are the most basic building block of Q# programs.</span></span> <span data-ttu-id="d1fdd-125">A Q # által meghatározott minden művelet hívhat meg tetszőleges számú egyéb műveletet.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-125">Each operation defined in Q# may then call any number of other operations.</span></span>

<span data-ttu-id="d1fdd-126">A műveletekkel szemben a functions a tisztán *determinisztikus* klasszikus viselkedés leírására szolgál, és nem gyakorol semmilyen hatást a klasszikus számítástechnikai értékek mellett.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-126">In contrast to operations, functions are used to describe purely *deterministic* classical behavior and do not have any effects besides computing classical values.</span></span> <span data-ttu-id="d1fdd-127">Tegyük fel például, hogy a qubits a program végén szeretnénk mérni, és a mérési eredményeket egy tömbhöz adja.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-127">For example, suppose we would like to measure our qubits at the end of a program, and add the measurement results to an array.</span></span>
<span data-ttu-id="d1fdd-128">Ebben az esetben `Measure` egy *művelet* , amely arra utasítja a célszámítógépet, hogy végezzen el egy mérést a (valós vagy szimulált) qubits, és a visszaadott eredmények tömbbe való felvételének klasszikus folyamatát a *functions*fogja kezelni.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-128">In this case `Measure` is an *operation* which instructs the target machine to perform a measurement on the (real or simulated) qubits, and the classical process of adding the returned results to an array will be handled by *functions*.</span></span>

<span data-ttu-id="d1fdd-129">A műveletek és a függvények együttes használata a *callables*, és a mögöttes struktúra és viselkedés a [Q # lapon lévő műveleteken és függvényeken](xref:microsoft.quantum.guide.operationsfunctions) van bevezetve.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-129">Together, operations and functions are referred to as *callables*, and their underlying structure and behavior is introduced on the [Operations and Functions in Q#](xref:microsoft.quantum.guide.operationsfunctions) page.</span></span>


## <a name="q-syntax-overview"></a><span data-ttu-id="d1fdd-130">Q # szintaxis – áttekintés</span><span class="sxs-lookup"><span data-stu-id="d1fdd-130">Q# syntax overview</span></span>

<span data-ttu-id="d1fdd-131">A nyelv szintaxisa a szintaktikai módon helyes programot alkotó szimbólumok különböző kombinációit írja le.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-131">The syntax of a language describes the different combinations of symbols that form a syntactically correct program.</span></span>
<span data-ttu-id="d1fdd-132">A Q #-ban három különböző csoportban is kategorizálhatja a szintaxisának elemeit: types, Expressions és utasítások.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-132">In Q# we can classify the elements of its syntax in three different groups: types, expressions and statements.</span></span>

### <a name="types"></a><span data-ttu-id="d1fdd-133">Típusok</span><span class="sxs-lookup"><span data-stu-id="d1fdd-133">Types</span></span>
<span data-ttu-id="d1fdd-134">A q # egy erősen gépelt nyelv, amely lehetővé teszi, hogy a típusok körültekintő használata segíthet a fordítónak a Q # programokkal kapcsolatos erős garanciák megadásában a fordítás ideje alatt.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-134">Q# is a strongly-typed language, such that careful use of types can help the compiler provide strong guarantees about Q# programs at compile time.</span></span>
<span data-ttu-id="d1fdd-135">A standard és a kvantum-specifikus beépített primitív típusok (például,, `Int` `Bool` és) mellett a `Qubit` `Result` Q # támogatást nyújt a felhasználó által definiált típusokhoz.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-135">In addition to standard and quantum-specific built-in primitive types (e.g. `Int`, `Bool`, `Qubit`, and `Result`), Q# provides support for user-defined types.</span></span>
<span data-ttu-id="d1fdd-136">Az összes Q # különböző primitív típusát a [q # oldalon található típusok](xref:microsoft.quantum.guide.types) írják le, valamint a tömb és a rekord típusának részleteit, valamint azt, hogy miként lehet új típusokat definiálni a q #-fájlokon belül.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-136">All of Q#'s various primitive types are described on the [Types in Q#](xref:microsoft.quantum.guide.types) page, along with details on array and tuple types, as well as how to define new types within a Q# file.</span></span>

### <a name="expressions"></a><span data-ttu-id="d1fdd-137">Kifejezések</span><span class="sxs-lookup"><span data-stu-id="d1fdd-137">Expressions</span></span>
<span data-ttu-id="d1fdd-138">A programozási nyelv kifejezése egy vagy több állandó, változó, operátor és függvény kombinációja, amelyet a programozási nyelv értelmez és kiértékel egy adott értékre.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-138">An expression in a programming language is a combination of one or more constants, variables, operators, and functions that the programming language interprets and evaluates to a specific value.</span></span>
<span data-ttu-id="d1fdd-139">A legtöbb esetben a nyelv minden típusához az adott típusú kifejezés lehet *literál* vagy szimbólum, amely egy adott típusú értékhez van kötve.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-139">Most simply, for every type in a language, expressions of that type can be either *literals* or symbols bound to a value of that type.</span></span>
<span data-ttu-id="d1fdd-140">Például `5` egy `Int` literál (azaz típusú kifejezés `Int` ), és ha a szimbólum az `count` egész értékhez van kötve `5` , akkor az `count` egész szám kifejezés is.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-140">For example, `5` is an `Int` literal (thus also an expression of type `Int`), and if the symbol `count` is bound to the integer value `5`, then `count` is also an integer expression.</span></span>

<span data-ttu-id="d1fdd-141">Emellett a kifejezések tartalmazhatnak más, bizonyos operátorokkal összevont kifejezéseket is.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-141">Additionally, an expression can consist of other expressions combined with certain operators.</span></span>
<span data-ttu-id="d1fdd-142">Ezért egy másik példa egy `Int` kifejezésre, amely a következőt értékeli: `5` `2+3` .</span><span class="sxs-lookup"><span data-stu-id="d1fdd-142">Hence another example of an `Int` expression which evaluates to `5` is `2+3`.</span></span>

<span data-ttu-id="d1fdd-143">A Q # oldalon található típusok lehetséges kifejezései, valamint a velük megalkotható kompatibilis operátorok részletesen szerepelnek a [q # lapon a Type kifejezésekben](xref:microsoft.quantum.guide.expressions) .</span><span class="sxs-lookup"><span data-stu-id="d1fdd-143">The possible expressions of types in Q#, as well as the compatible operators that can be used to form them, are detailed on the [Type Expressions in Q#](xref:microsoft.quantum.guide.expressions) page.</span></span> 

### <a name="statements"></a><span data-ttu-id="d1fdd-144">Utasítások</span><span class="sxs-lookup"><span data-stu-id="d1fdd-144">Statements</span></span> 
<span data-ttu-id="d1fdd-145">Az utasítás egy kötelező programozási nyelv szintaktikai egysége, amely egy művelet elvégzését fejezi ki. Az utasításokban szereplő kifejezések kontrasztja nem ad eredményül az eredményeket, és kizárólag a rájuk vonatkozó hatásuk miatt hajtja végre a kifejezéseket, míg a kifejezések mindig egy eredményt adnak vissza, és gyakran nincsenek mellékhatásai.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-145">A statement is a syntactic unit of an imperative programming language that expresses some action to be carried out. Statements contrast with expressions in that statements do not return results and are executed solely for their side effects, while expressions always return a result and often do not have side effects at all.</span></span>
<span data-ttu-id="d1fdd-146">Ez a különbségtétel gyakran megfigyelhető a szóhasználatban: egy kifejezés kiértékelése megtörtént, míg a rendszer egy utasítást hajt végre.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-146">This distinction is frequently observed in wording: an expression is evaluated, whereas a statement is executed.</span></span>

<span data-ttu-id="d1fdd-147">A Q # egyik utasításának nagyon egyszerű példája egy szimbólum társítása egy kifejezéshez:</span><span class="sxs-lookup"><span data-stu-id="d1fdd-147">A very basic example of a statement in Q# is assigning a symbol to an expression:</span></span>
```qsharp
let count = 5;
```

<span data-ttu-id="d1fdd-148">Egy kicsit érdekesebb példa az az `for` utasítás, amely támogatja az iterációt, és tartalmaz egy *utasítás blokkot*.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-148">A slightly more interesting example is the `for` statement which supports iteration and includes a *statement block*.</span></span>
<span data-ttu-id="d1fdd-149">Tegyük fel, `qubits` hogy a szimbólum a qubits (a típus típusa `Qubit[]` , azaz egy tömb) egy regiszteréhez van kötve `Qubit` .</span><span class="sxs-lookup"><span data-stu-id="d1fdd-149">Suppose `qubits` is the symbol bound to a register of qubits (technically of type `Qubit[]`, i.e. an array of `Qubit` types).</span></span> <span data-ttu-id="d1fdd-150">Majd</span><span class="sxs-lookup"><span data-stu-id="d1fdd-150">Then</span></span>
```qsharp
for (qubit in qubits) {
    H(qubit);
}
```
<span data-ttu-id="d1fdd-151">a egy olyan utasítás, amely a regisztráció minden qubit megismétli, végrehajtja a `H` műveletet mindegyiken.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-151">is a statement which iterates over each qubit in the register, performing the `H` operation on each.</span></span> <span data-ttu-id="d1fdd-152">Vegye figyelembe, hogy `H(qubit);` egy utasítás önmagában is szerepel.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-152">Note that `H(qubit);` is a statement in itself as well.</span></span>

<span data-ttu-id="d1fdd-153">Valójában bármely típusú hívás kifejezés `Unit` (ezek a callables, amelyek nem adnak vissza adatokat) utasításként is használhatók.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-153">In fact, any call expression of type `Unit` (those callables that do not return any information) may be used as a statement.</span></span>
<span data-ttu-id="d1fdd-154">Ez elsősorban akkor használatos, ha olyan műveleteket hív meg a qubits, amelyek visszaadnak, `Unit` mert az utasítás célja az implicit kvantum állapotának módosítása.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-154">This is primarily of use when calling operations on qubits that return `Unit` because the purpose of the statement is to modify the implicit quantum state.</span></span>
<span data-ttu-id="d1fdd-155">A kifejezés-értékelési utasításokhoz pontosvesszőt kell lezárni.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-155">Expression evaluation statements require a terminating semicolon.</span></span>

<span data-ttu-id="d1fdd-156">A Q # program csaknem minden aspektusa utasítások használatával készült, így egyetlen oldal sem terjedhet ki a rájuk vonatkozó összes információra.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-156">Nearly every aspect of a Q# program is built using statements, so no single page could encompass all the information relating to them.</span></span>
<span data-ttu-id="d1fdd-157">Azonban a saját lexikális szerkezete és formázása a [q # file Structure](xref:microsoft.quantum.guide.filestructure) oldalon, a Symbol kötési hozzárendelés és a hatókör a [q # változóknál](xref:microsoft.quantum.guide.variables), valamint a flow-hurkok vezérlése, például a `for` [Control flow in q #](xref:microsoft.quantum.guide.controlflow).</span><span class="sxs-lookup"><span data-stu-id="d1fdd-157">However, their lexical structure and formatting is described on the [Q# File Structure](xref:microsoft.quantum.guide.filestructure) page, symbol binding assignment and scope at [Variables in Q#](xref:microsoft.quantum.guide.variables), and control flow loops such as `for` at [Control Flow in Q#](xref:microsoft.quantum.guide.controlflow).</span></span>


## <a name="whats-next"></a><span data-ttu-id="d1fdd-158">A következő lépések</span><span class="sxs-lookup"><span data-stu-id="d1fdd-158">What's next?</span></span>
<span data-ttu-id="d1fdd-159">A jelen útmutató további részében bemutatjuk, hogyan használhatók a Q # az összetett kvantum-programok létrehozásához a műveletek, függvények és típusok alapvető építőelemei alapján.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-159">Throughout the rest of this guide, we will show you how to use Q# to construct complex quantum programs through the basic building blocks of operations, functions, and types.</span></span>

<span data-ttu-id="d1fdd-160">Első lépésként megkezdheti [a Q #-ban található típusok](xref:microsoft.quantum.guide.types)megismerését.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-160">To get started, you can start learning about [Types in Q#](xref:microsoft.quantum.guide.types).</span></span>

<span data-ttu-id="d1fdd-161">Ha szeretne többet megtudni az alapítványokról és a Q # mögötti motivációról, tekintse meg, [Miért van szükségünk q #?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/)elemre.</span><span class="sxs-lookup"><span data-stu-id="d1fdd-161">If you are interested in learning more about the foundations and motivation behind Q#, check out [Why do we need Q#?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span></span>
