---
title: 'Diagnosztika a Q # standard könyvtárakban'
description: 'Ismerje meg, hogy milyen diagnosztikai funkciókkal és műveletekkel lehet elsajátítani a kvantum-programok hibáit vagy hibáit a Q # standard kódtárakban.'
author: cgranade
uid: microsoft.quantum.libraries.diagnostics
ms.author: chgranad@microsoft.com
ms.topic: article
ms.openlocfilehash: fa5173f710dd9e0b0b2c110e45aa0bf019111aca
ms.sourcegitcommit: 0181e7c9e98f9af30ea32d3cd8e7e5e30257a4dc
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 06/23/2020
ms.locfileid: "85274987"
---
# <a name="diagnostics"></a><span data-ttu-id="3c592-103">Diagnosztika</span><span class="sxs-lookup"><span data-stu-id="3c592-103">Diagnostics</span></span> #

<span data-ttu-id="3c592-104">A klasszikus fejlesztéshez hasonlóan fontos, hogy képes legyen diagnosztizálni a kvantum-programok hibáit és hibáit.</span><span class="sxs-lookup"><span data-stu-id="3c592-104">As with classical development, it is important to be able to diagnose mistakes and errors in quantum programs.</span></span>
<span data-ttu-id="3c592-105">A Q # standard kódtárak számos különböző módszert biztosítanak a kvantum-programok helyességének biztosításához <xref:microsoft.quantum.guide.testingdebugging> .</span><span class="sxs-lookup"><span data-stu-id="3c592-105">The Q# standard libraries provide a variety of different ways to ensure the correctness of quantum programs, as detailed in <xref:microsoft.quantum.guide.testingdebugging>.</span></span>
<span data-ttu-id="3c592-106">Ez a támogatás nagyrészt olyan függvények és műveletek formájában érhető el, amelyek a célszámítógép számára arra utasítja a további diagnosztikai adatokat, hogy a gazda programhoz vagy a fejlesztőhöz, vagy a függvény vagy a művelet hívása által kifejezett feltételek és invariánsok helyességét érvényesítsék.</span><span class="sxs-lookup"><span data-stu-id="3c592-106">Largely speaking, this support comes in the form of functions and operations that either instruct the target machine to provide additional diagnostic information to the host program or developer, or enforce the correctness of conditions and invariants expressed by the function or operation call.</span></span>

## <a name="machine-diagnostics"></a><span data-ttu-id="3c592-107">Gépi diagnosztika</span><span class="sxs-lookup"><span data-stu-id="3c592-107">Machine Diagnostics</span></span> ##

<span data-ttu-id="3c592-108">A klasszikus értékekkel kapcsolatos diagnosztika megszerzéséhez a <xref:microsoft.quantum.intrinsic.message> függvény használatával kell naplózni egy üzenetet a gépen függő módon.</span><span class="sxs-lookup"><span data-stu-id="3c592-108">Diagnostics about classical values can be obtained by using the <xref:microsoft.quantum.intrinsic.message> function to log a message in a machine-dependent way.</span></span>
<span data-ttu-id="3c592-109">Alapértelmezés szerint ez a karakterláncot írja a konzolra.</span><span class="sxs-lookup"><span data-stu-id="3c592-109">By default, this writes the string to the console.</span></span>
<span data-ttu-id="3c592-110">Az interpolált karakterláncokkal együtt használva <xref:microsoft.quantum.intrinsic.message> könnyedén jelenthet diagnosztikai adatokat a klasszikus értékekről:</span><span class="sxs-lookup"><span data-stu-id="3c592-110">Used together with interpolated strings, <xref:microsoft.quantum.intrinsic.message> makes it easy to report diagnostic information about classical values:</span></span>

```Q#
let angle = Microsoft.Quantum.Math.PI() * 2.0 / 3.0;
Message($"About to rotate by an angle of {angle}...");
```

> [!NOTE]
> <span data-ttu-id="3c592-111">`Message`a rendelkezik aláírással `(String -> Unit)` , amely azt jelenti, hogy a hibakeresési napló üzenete nem figyelhető meg a Q #-on belül.</span><span class="sxs-lookup"><span data-stu-id="3c592-111">`Message` has signature `(String -> Unit)`, again representing that emitting a debug log message cannot be observed from within Q#.</span></span>

<span data-ttu-id="3c592-112">A <xref:microsoft.quantum.diagnostics.dumpmachine> és a <xref:microsoft.quantum.diagnostics.dumpregister> callables utasíthatja a megcélzott gépeket arra, hogy diagnosztikai adatokat szolgáltassanak a jelenleg lefoglalt qubits vagy a qubits egy adott regiszteréről.</span><span class="sxs-lookup"><span data-stu-id="3c592-112">The <xref:microsoft.quantum.diagnostics.dumpmachine> and <xref:microsoft.quantum.diagnostics.dumpregister> callables instruct target machines to provide diagnostic information about all currently allocated qubits or about a specific register of qubits, respectively.</span></span>
<span data-ttu-id="3c592-113">Az egyes célszámítógépeken eltérő diagnosztikai információk szerepelnek a dump utasításra adott válaszban.</span><span class="sxs-lookup"><span data-stu-id="3c592-113">Each target machine varies in what diagnostic information is provided in response to a dump instruction.</span></span>
<span data-ttu-id="3c592-114">A [teljes körű állapot-szimulátor](xref:microsoft.quantum.machines.full-state-simulator) célszámítógép, például biztosítja a gazdagép programját a belső használatú állapot-vektor alapján, hogy az qubits regisztráljon.</span><span class="sxs-lookup"><span data-stu-id="3c592-114">The [full state simulator](xref:microsoft.quantum.machines.full-state-simulator) target machine, for instance, provides the host program with the state vector that it uses internally to represent a register of qubits.</span></span>
<span data-ttu-id="3c592-115">Összehasonlításképpen a [Toffoli Simulator](xref:microsoft.quantum.machines.toffoli-simulator) célszámítógép egyetlen klasszikus bitet biztosít minden qubit.</span><span class="sxs-lookup"><span data-stu-id="3c592-115">By comparison, the [Toffoli simulator](xref:microsoft.quantum.machines.toffoli-simulator) target machine provides a single classical bit for each qubit.</span></span>

 <span data-ttu-id="3c592-116">Ha többet szeretne megtudni a [teljes állapotú szimulátor](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` kimenetéről, tekintse meg a [tesztelési és hibakeresési cikk](xref:microsoft.quantum.guide.testingdebugging#dump-functions)dump functions című szakaszát.</span><span class="sxs-lookup"><span data-stu-id="3c592-116">To learn more about the [full state simulator's](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` output, take a look at the dump functions section of our [testing and debugging article](xref:microsoft.quantum.guide.testingdebugging#dump-functions).</span></span>


## <a name="facts-and-assertions"></a><span data-ttu-id="3c592-117">Tények és kijelentések</span><span class="sxs-lookup"><span data-stu-id="3c592-117">Facts and Assertions</span></span> ##

<span data-ttu-id="3c592-118">Ahogy azt a [tesztelési és hibakeresési](xref:microsoft.quantum.guide.testingdebugging)művelet, az aláírással `Unit -> Unit` vagy a használatával végzett műveletek `Unit => Unit` is megadhatók *egységként*.</span><span class="sxs-lookup"><span data-stu-id="3c592-118">As discussed in [Testing and Debugging](xref:microsoft.quantum.guide.testingdebugging), a function or operation with signature `Unit -> Unit` or `Unit => Unit`, respectively, can be marked as a *unit test*.</span></span>
<span data-ttu-id="3c592-119">Az egyes egységek tesztelése általában egy kis kvantum-programból áll, valamint egy vagy több, a program helyességét ellenőrző feltételt.</span><span class="sxs-lookup"><span data-stu-id="3c592-119">Each unit test generally consists of a small quantum program, along with one or more conditions that check the correctness of that program.</span></span>
<span data-ttu-id="3c592-120">Ezek a feltételek akár _tények_formájában is megtekinthetők, amelyek bemutatják a bemenetek vagy a _bejelentések_értékeit, amelyek egy vagy több, bemenetként átadott qubits állapotának ellenőrzését jelzik.</span><span class="sxs-lookup"><span data-stu-id="3c592-120">These conditions can come in the form of either _facts_, which check the values of their inputs, or _assertions_, which check the states of one or more qubits passed as input.</span></span>

<span data-ttu-id="3c592-121">Például `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` az a matematikai tény, hogy a $1 + 1 = $2, míg `AssertQubit(One, qubit)` a mérési feltételt jelzi, hogy a mérés `qubit` visszaadja a megfelelő `One` bizonyosságot.</span><span class="sxs-lookup"><span data-stu-id="3c592-121">For example, `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` represents the mathematical fact that $1 + 1 = 2$, while `AssertQubit(One, qubit)` represents the condition that measuring `qubit` will return a `One` with certainty.</span></span>
<span data-ttu-id="3c592-122">Az előző esetben ellenőrizhető, hogy a feltétel helyes értéke csak az értékekre vonatkozik-e, míg az utóbbiban tudnia kell valamit a qubit állapotáról az érvényesítés kiértékelése érdekében.</span><span class="sxs-lookup"><span data-stu-id="3c592-122">In the former case, we can check the correctness of the condition given only its values, while in the latter, we must know something about the state of the qubit in order to evaluate the assertion.</span></span>

<span data-ttu-id="3c592-123">A Q # standard könyvtárak számos különböző funkciót biztosítanak a tények ábrázolásához, többek között:</span><span class="sxs-lookup"><span data-stu-id="3c592-123">The Q# standard libraries provide several different functions for representing facts, including:</span></span>

- <xref:microsoft.quantum.diagnostics.fact>
- <xref:microsoft.quantum.diagnostics.equalitywithintolerancefact>
- <xref:microsoft.quantum.diagnostics.nearequalityfactc>
- <xref:microsoft.quantum.diagnostics.equalityfacti>


### <a name="testing-qubit-states"></a><span data-ttu-id="3c592-124">Qubit állapotának tesztelése</span><span class="sxs-lookup"><span data-stu-id="3c592-124">Testing Qubit States</span></span> ###

<span data-ttu-id="3c592-125">A gyakorlatban az állítások arra utalnak, hogy a kvantummechanika klasszikus szimulációinak nem kell megtartaniuk a [klónozás nélküli adattételt](https://arxiv.org/abs/quant-ph/9607018), így nem lehet fizikai méréseket és kijelentéseket készíteni, ha szimulátort használunk a célszámítógép számára.</span><span class="sxs-lookup"><span data-stu-id="3c592-125">In practice, assertions rely on the fact that classical simulations of quantum mechanics need not obey the [no-cloning theorem](https://arxiv.org/abs/quant-ph/9607018), such that we can make unphysical measurements and assertions when using a simulator for our target machine.</span></span>
<span data-ttu-id="3c592-126">Így a hardverre való üzembe helyezés előtt tesztelheti az egyes műveleteket a klasszikus szimulátoron.</span><span class="sxs-lookup"><span data-stu-id="3c592-126">Thus, we can test individual operations on a classical simulator before deploying on hardware.</span></span>
<span data-ttu-id="3c592-127">Azokon a célszámítógépeken, amelyek nem engedélyezik az állítások kiértékelését, <xref:microsoft.quantum.intrinsic.assert> nyugodtan figyelmen kívül hagyhatják a hívásokat.</span><span class="sxs-lookup"><span data-stu-id="3c592-127">On target machines which do not allow evaluation of assertions, calls to <xref:microsoft.quantum.intrinsic.assert> can be safely ignored.</span></span>

<span data-ttu-id="3c592-128">Általánosságban a <xref:microsoft.quantum.intrinsic.assert> művelet azt állítja be, hogy a megadott Pauli-alapú qubits mérése mindig a megadott eredménnyel jár.</span><span class="sxs-lookup"><span data-stu-id="3c592-128">More generally, the <xref:microsoft.quantum.intrinsic.assert> operation asserts that measuring the given qubits in the given Pauli basis will always have the given result.</span></span>
<span data-ttu-id="3c592-129">Ha az állítás sikertelen, a végrehajtás a `fail` megadott üzenettel való meghívásával végződik.</span><span class="sxs-lookup"><span data-stu-id="3c592-129">If the assertion fails, the execution ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="3c592-130">Alapértelmezés szerint ez a művelet nincs implementálva; a-t támogató szimulátoroknak olyan implementációt kell biztosítaniuk, amely a futtatókörnyezet ellenőrzését végzi.</span><span class="sxs-lookup"><span data-stu-id="3c592-130">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="3c592-131">`Assert`aláírással rendelkezik `((Pauli[], Qubit[], Result, String) -> ())` .</span><span class="sxs-lookup"><span data-stu-id="3c592-131">`Assert` has signature `((Pauli[], Qubit[], Result, String) -> ())`.</span></span>
<span data-ttu-id="3c592-132">Mivel a `Assert` függvény egy üres rekord kimenetének típusa, a rendszer semmilyen, `Assert` a Q # programon belül megfigyelhető hatást sem tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="3c592-132">Since `Assert` is a function with an empty tuple as its output type, no effects from having called `Assert` are observable within a Q# program.</span></span>

<span data-ttu-id="3c592-133">A <xref:microsoft.quantum.intrinsic.assertprob> Operation függvény azt állítja be, hogy a megadott Pauli-alapú qubits mérése a megadott valószínűséggel az adott tűréshatáron belül megtörténik.</span><span class="sxs-lookup"><span data-stu-id="3c592-133">The <xref:microsoft.quantum.intrinsic.assertprob> operation function asserts that measuring the given qubits in the given Pauli basis will have the given result with the given probability, within some tolerance.</span></span>
<span data-ttu-id="3c592-134">A tolerancia adalékanyag (például `abs(expected-actual) < tol` ).</span><span class="sxs-lookup"><span data-stu-id="3c592-134">Tolerance is additive (e.g. `abs(expected-actual) < tol`).</span></span>
<span data-ttu-id="3c592-135">Ha az állítás sikertelen, a végrehajtás a `fail` megadott üzenettel való meghívásával végződik.</span><span class="sxs-lookup"><span data-stu-id="3c592-135">If the assertion fails, the execution ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="3c592-136">Alapértelmezés szerint ez a művelet nincs implementálva; a-t támogató szimulátoroknak olyan implementációt kell biztosítaniuk, amely a futtatókörnyezet ellenőrzését végzi.</span><span class="sxs-lookup"><span data-stu-id="3c592-136">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="3c592-137">`AssertProb`aláírással rendelkezik `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)` .</span><span class="sxs-lookup"><span data-stu-id="3c592-137">`AssertProb` has signature `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)`.</span></span> <span data-ttu-id="3c592-138">Az első `Double` paraméter megadja az eredmény kívánt valószínűségét, a második pedig a tűréshatárt.</span><span class="sxs-lookup"><span data-stu-id="3c592-138">The first of `Double` parameters gives the desired probability of the result, and the second one the tolerance.</span></span>

<span data-ttu-id="3c592-139">Több, mint egy olyan mérést végzünk, amely a szimulátor által a qubit belső állapotának jelzésére használt klasszikus információkat a másolásra alkalmasnak tekinti, így nem kell mérést végeznie az állítás teszteléséhez.</span><span class="sxs-lookup"><span data-stu-id="3c592-139">We can do more than assert a single measurement, using that the classical information used by a simulator to represent the internal state of a qubit is amenable to copying, such that we do not need to actually perform a measurement to test our assertion.</span></span>
<span data-ttu-id="3c592-140">Ez különösen azt eredményezi, hogy a nem *kompatibilis* mérések oka a tényleges hardverek esetében nem lehetséges.</span><span class="sxs-lookup"><span data-stu-id="3c592-140">In particular, this allows us to reason about *incompatible* measurements that would be impossible on actual hardware.</span></span>

<span data-ttu-id="3c592-141">Tegyük fel, hogy `P : Qubit => Unit` egy olyan művelet, amely a $ \ket{\psi} $ állapot előkészítésére szolgál, ha a bemenete a $ \ket $ állapotú {0} .</span><span class="sxs-lookup"><span data-stu-id="3c592-141">Suppose that `P : Qubit => Unit` is an operation intended to prepare the state $\ket{\psi}$ when its input is in the state $\ket{0}$.</span></span>
<span data-ttu-id="3c592-142">A $ \ket{\psi '} $ értéket kell a tényleges állapotra felkészíteni `P` .</span><span class="sxs-lookup"><span data-stu-id="3c592-142">Let $\ket{\psi'}$ be the actual state prepared by `P`.</span></span>
<span data-ttu-id="3c592-143">Ezt követően a $ \ket{\psi} = \ket{\psi '} $ értéket, ha pedig csak akkor, ha a $ \ket{\psi} $ által ismertetett tengelyen a $ \ket{\psi '} $ érték mérése után a rendszer csak a $ `Zero`</span><span class="sxs-lookup"><span data-stu-id="3c592-143">Then, $\ket{\psi} = \ket{\psi'}$ if and only if measuring $\ket{\psi'}$ in the axis described by $\ket{\psi}$ always returns `Zero`.</span></span>
<span data-ttu-id="3c592-144">Ez a következő: \begin{align} \ket{\psi} = \ket{\psi '} \text{IF és only if} \braket{\psi | \psi '} = 1.</span><span class="sxs-lookup"><span data-stu-id="3c592-144">That is, \begin{align} \ket{\psi} = \ket{\psi'} \text{ if and only if } \braket{\psi | \psi'} = 1.</span></span>
<span data-ttu-id="3c592-145">a bevezetés során definiált primitív műveletek \end{align} közvetlenül olyan mérést végezhetünk, amely visszaadja a $ \ket{\psi} $ értéket, amely a `Zero` Pauli-operátorok egyikének eigenstate.</span><span class="sxs-lookup"><span data-stu-id="3c592-145">\end{align} Using the primitive operations defined in the prelude, we can directly perform a measurement that returns `Zero` if $\ket{\psi}$ is an eigenstate of one of the Pauli operators.</span></span>


<span data-ttu-id="3c592-146">A művelet <xref:microsoft.quantum.diagnostics.assertqubit> különösen hasznos rövidítést biztosít erre az esetre, ha tesztelni szeretné a $ \ket{\psi} = \ket {0} $ állítását.</span><span class="sxs-lookup"><span data-stu-id="3c592-146">The operation <xref:microsoft.quantum.diagnostics.assertqubit> provides a particularly useful shorthand to do so in the case that we wish to test the assertion $\ket{\psi} = \ket{0}$.</span></span>
<span data-ttu-id="3c592-147">Ez például akkor fordul elő, ha nem számítottuk ki, hogy Ancilla qubits vissza $ \ket $ értékre, {0} mielőtt felszabadítja őket.</span><span class="sxs-lookup"><span data-stu-id="3c592-147">This is common, for instance, when we have uncomputed to return ancilla qubits to $\ket{0}$ before releasing them.</span></span>
<span data-ttu-id="3c592-148">A $ \ket $-re {0} való állítás akkor is hasznos, ha azt szeretnénk, hogy a két állapot előkészítését `P` és `Q` műveleteit egyaránt készítse elő, és ha `Q` támogatja `Adjoint` .</span><span class="sxs-lookup"><span data-stu-id="3c592-148">Asserting against $\ket{0}$ is also useful when we wish to assert that two state preparation `P` and `Q` operations both prepare the same state, and when `Q` supports `Adjoint`.</span></span>
<span data-ttu-id="3c592-149">Különösen a</span><span class="sxs-lookup"><span data-stu-id="3c592-149">In particular,</span></span>

```qsharp
using (register = Qubit()) {
    P(register);
    Adjoint Q(register);

    AssertQubit(Zero, register);
}
```

<span data-ttu-id="3c592-150">Általánosságban azonban előfordulhat, hogy nem férnek hozzá olyan állapotokra vonatkozó kijelentésekhez, amelyek nem egyeznek a Pauli-operátorok eigenstates.</span><span class="sxs-lookup"><span data-stu-id="3c592-150">More generally, however, we may not have access to assertions about states that do not coincide with eigenstates of Pauli operators.</span></span>
<span data-ttu-id="3c592-151">Például a $ \ket{\psi} = (\ket {0} + e ^ {i \pi/8} \ket {1} )/\sqrt {2} $ nem eigenstate a Pauli operátorok egyike sem, így nem tudjuk <xref:microsoft.quantum.intrinsic.assertprob> egyedileg meghatározni, hogy a $ \ket{\psi '} $ érték egyenlő a $ \ket{\psi} $ értékkel.</span><span class="sxs-lookup"><span data-stu-id="3c592-151">For example, $\ket{\psi} = (\ket{0} + e^{i \pi / 8} \ket{1}) / \sqrt{2}$ is not an eigenstate of any Pauli operator, such that we cannot use <xref:microsoft.quantum.intrinsic.assertprob> to uniquely determine that a state $\ket{\psi'}$ is equal to $\ket{\psi}$.</span></span>
<span data-ttu-id="3c592-152">Ehelyett fel kell bontani a $ \ket{\psi '} = \ket{\psi} $ metódust olyan feltételezésekre, amelyeket közvetlenül a szimulátor által támogatott primitívek használatával lehet tesztelni.</span><span class="sxs-lookup"><span data-stu-id="3c592-152">Instead, we must decompose the assertion $\ket{\psi'} = \ket{\psi}$ into assumptions that can be directly tested using  the primitives supported by our simulator.</span></span>
<span data-ttu-id="3c592-153">Ehhez tegye a $ \ket{\psi} = \alpha \ket {0} + \beta \ket $ értéket {1} a következő összetett számok esetében: $ \alpha = a \_ r + a \_ i i $ és $ \beta $.</span><span class="sxs-lookup"><span data-stu-id="3c592-153">To do so, let $\ket{\psi} = \alpha \ket{0} + \beta \ket{1}$ for complex numbers $\alpha = a\_r + a\_i i$ and $\beta$.</span></span>
<span data-ttu-id="3c592-154">Vegye figyelembe, hogy ehhez a kifejezéshez négy valós számot kell \{ \_ megadnia: $ a r, \_ i, b \_ r, b \_ i \} $, hogy megadják, mivel minden összetett szám egy valós és egy képzeletbeli rész összegével fejezhető ki.</span><span class="sxs-lookup"><span data-stu-id="3c592-154">Note that this expression requires four real numbers $\{a\_r, a\_i, b\_r, b\_i\}$ to specify, as each complex number can be expressed as the sum of a real and imaginary part.</span></span>
<span data-ttu-id="3c592-155">A globális fázis miatt azonban választhatjuk $a \_ i = $0, így csak három valós számra van szükségünk, hogy egyedi módon qubit állapotot adjon meg.</span><span class="sxs-lookup"><span data-stu-id="3c592-155">Due to the global phase, however, we can choose $a\_i = 0$, such that we only need three real numbers to uniquely specify a single-qubit state.</span></span>

<span data-ttu-id="3c592-156">Ezért három olyan állítást kell megadnia, amelyek egymástól függetlenek, hogy az elvárt állapotot érvényesítsék.</span><span class="sxs-lookup"><span data-stu-id="3c592-156">Thus, we need to specify three assertions which are independent of each other in order to assert the state that we expect.</span></span>
<span data-ttu-id="3c592-157">Ezt úgy teheti meg `Zero` , hogy megkeresi az egyes, a $ \alpha $ és a $ \beta $ értékkel megadott Pauli-mérések valószínűségét, és mindegyiket egymástól függetlenül érvényesíti.</span><span class="sxs-lookup"><span data-stu-id="3c592-157">We do so by finding the probability of observing `Zero` for each Pauli measurement given $\alpha$ and $\beta$, and asserting each independently.</span></span>
<span data-ttu-id="3c592-158">$X $, $y $, és $z $ érték adható `Result` meg a Pauli $X $, $Y $ és a $Z $ mérésekhez.</span><span class="sxs-lookup"><span data-stu-id="3c592-158">Let $x$, $y$, and $z$ be `Result` values for Pauli $X$, $Y$, and $Z$ measurements respectively.</span></span>
<span data-ttu-id="3c592-159">Ezt követően a \begin{align} \Pr (x = \texttt{Zero} | \alpha) a valószínűség függvény használatával \beta) & = \frac12 + a \_ r b \_ r + a \_ i b i \_ \\ \\ \Pr (y = \texttt{Zero} | \alpha, \beta) & = \frac12 + a \_ r b \_ i-a \_ i b \_ r \\ \\ \Pr (z = \texttt{Zero} | \alpha, \beta) & = \frac12\left (1 + a \_ r ^ 2 + a \_ i ^ 2 + b \_ r ^ 2 + b \_ i ^ 2 \right).</span><span class="sxs-lookup"><span data-stu-id="3c592-159">Then, using the likelihood function for quantum measurements, \begin{align} \Pr(x = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_r + a\_i b\_i \\\\ \Pr(y = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_i - a\_i b\_r \\\\ \Pr(z = \texttt{Zero} | \alpha, \beta) & = \frac12\left( 1 + a\_r^2 + a\_i^2 + b\_r^2 + b\_i^2 \right).</span></span>
<span data-ttu-id="3c592-160">\end{align}</span><span class="sxs-lookup"><span data-stu-id="3c592-160">\end{align}</span></span>

<span data-ttu-id="3c592-161">A <xref:microsoft.quantum.diagnostics.assertqubitisinstatewithintolerance> művelet végrehajtja ezeket az állításokat a $ \alpha $ és a $ \beta $ értékkel megadott típusú értékek formájában <xref:microsoft.quantum.math.complex> .</span><span class="sxs-lookup"><span data-stu-id="3c592-161">The <xref:microsoft.quantum.diagnostics.assertqubitisinstatewithintolerance> operation implements these assertions given representations of $\alpha$ and $\beta$ as values of type <xref:microsoft.quantum.math.complex>.</span></span>
<span data-ttu-id="3c592-162">Ez akkor hasznos, ha a várt állapotot matematikailag lehet kiszámítani.</span><span class="sxs-lookup"><span data-stu-id="3c592-162">This is helpful when the expected state can be computed mathematically.</span></span>

### <a name="asserting-equality-of-quantum-operations"></a><span data-ttu-id="3c592-163">A kvantum-műveletek egyenlőségének érvényesítése</span><span class="sxs-lookup"><span data-stu-id="3c592-163">Asserting Equality of Quantum Operations</span></span> ###

<span data-ttu-id="3c592-164">Eddig olyan tesztelési műveletekkel foglalkozunk, amelyek bizonyos állapotok előkészítésére szolgálnak.</span><span class="sxs-lookup"><span data-stu-id="3c592-164">Thus far, we have been concerned with testing operations which are intended to prepare particular states.</span></span>
<span data-ttu-id="3c592-165">Gyakran azonban arra is Kíváncsiak vagyunk, hogy egy adott művelet nem egyetlen rögzített bemenet helyett a tetszőleges bemenetek esetében is működik.</span><span class="sxs-lookup"><span data-stu-id="3c592-165">Often, however, we are interested in how an operation acts for arbitrary inputs rather than for a single fixed input.</span></span>
<span data-ttu-id="3c592-166">Tegyük fel például, hogy megvalósított egy olyan műveletet, amely `U : ((Double, Qubit[]) => () : Adjoint)` egy egységes operátorok családja $U (t) $, és a `adjoint` használata helyett explicit blokkot adott meg `adjoint auto` .</span><span class="sxs-lookup"><span data-stu-id="3c592-166">For example, suppose we have implemented an operation `U : ((Double, Qubit[]) => () : Adjoint)` corresponding to a family of unitary operators $U(t)$, and have provided an explicit `adjoint` block instead of using `adjoint auto`.</span></span>
<span data-ttu-id="3c592-167">Előfordulhat, hogy a rendszer azt állítja be, hogy $U ^ \dagger (t) = U (-t) $, ahogy az a várt érték, ha $t $ egy evolúciós időt jelöl.</span><span class="sxs-lookup"><span data-stu-id="3c592-167">We may be interested in asserting that $U^\dagger(t) = U(-t)$, as expected if $t$ represents an evolution time.</span></span>

<span data-ttu-id="3c592-168">Általánosságban elmondható, hogy két különböző stratégia van, amelyet követve elvégezheti az állítást, hogy két művelet `U` és `V` azonos módon járjon el.</span><span class="sxs-lookup"><span data-stu-id="3c592-168">Broadly speaking, there are two different strategies that we can follow in making the assertion that two operations `U` and `V` act identically.</span></span>
<span data-ttu-id="3c592-169">Először is megvizsgálhatja, hogy az `U(target); (Adjoint V)(target);` egyes állapotok megtalálhatók-e egy adott alapon.</span><span class="sxs-lookup"><span data-stu-id="3c592-169">First, we can check that `U(target); (Adjoint V)(target);` preserves each state in a given basis.</span></span>
<span data-ttu-id="3c592-170">Másodszor, azt is megtehetjük, hogy `U(target); (Adjoint V)(target);` egy kusza állapot felén eljáró műveletek megőrzik a felakadás.</span><span class="sxs-lookup"><span data-stu-id="3c592-170">Second, we can check that `U(target); (Adjoint V)(target);` acting on half of an entangled state preserves that entanglement.</span></span>
<span data-ttu-id="3c592-171">Ezeket a stratégiákat a Canon-műveletek, illetve a rendszerek implementálják <xref:microsoft.quantum.diagnostics.assertoperationsequalinplace> <xref:microsoft.quantum.diagnostics.assertoperationsequalreferenced> .</span><span class="sxs-lookup"><span data-stu-id="3c592-171">These strategies are implemented by the canon operations <xref:microsoft.quantum.diagnostics.assertoperationsequalinplace> and <xref:microsoft.quantum.diagnostics.assertoperationsequalreferenced>, respectively.</span></span>

> [!NOTE]
> <span data-ttu-id="3c592-172">A fent tárgyalt hivatkozott állítás a [Choi – Jamiłkowski isomorphism](https://en.wikipedia.org/wiki/Channel-state_duality), egy matematikai keretrendszer alapján működik, amely a (z) $n $ qubits műveleteit a $2n $ qubits-ben összekevert állapotokra kapcsolja.</span><span class="sxs-lookup"><span data-stu-id="3c592-172">The referenced assertion discussed above works based on the [Choi–Jamiłkowski isomorphism](https://en.wikipedia.org/wiki/Channel-state_duality), a mathematical framework which relates operations on $n$ qubits to entangled states on $2n$ qubits.</span></span>
> <span data-ttu-id="3c592-173">Különösen a $n $ qubits azonosító műveletét a rendszer a (z) $ \ket{\ beta_ {00} } \mathrel{: =} (\ket {00} + \ket {11} )/\sqrt $ összefoglalt állapot $n $ példányával jelöli {2} .</span><span class="sxs-lookup"><span data-stu-id="3c592-173">In particular, the identity operation on $n$ qubits is represented by $n$ copies of the entangled state $\ket{\beta_{00}} \mathrel{:=} (\ket{00} + \ket{11}) / \sqrt{2}$.</span></span>
> <span data-ttu-id="3c592-174">A művelet <xref:microsoft.quantum.preparation.preparechoistate> végrehajtja ezt a isomorphism, és előkészít egy olyan állapotot, amely egy adott műveletet jelöl.</span><span class="sxs-lookup"><span data-stu-id="3c592-174">The operation <xref:microsoft.quantum.preparation.preparechoistate> implements this isomorphism, preparing a state that represents a given operation.</span></span>

<span data-ttu-id="3c592-175">Nagyjából ezeket a stratégiákat az idő – Space kompromisszum különbözteti meg.</span><span class="sxs-lookup"><span data-stu-id="3c592-175">Roughly, these strategies are distinguished by a time–space tradeoff.</span></span>
<span data-ttu-id="3c592-176">Az egyes bemeneti állapotok közelítése további időt vesz igénybe, míg a felakadás használata során további qubits kell tárolnia.</span><span class="sxs-lookup"><span data-stu-id="3c592-176">Iterating through each input state takes additional time, while using entanglement as a reference requires storing additional qubits.</span></span>
<span data-ttu-id="3c592-177">Azokban az esetekben, amikor egy művelet egy megfordítható klasszikus műveletet valósít meg, így csak a számítási alapon működő állapotokkal kapcsolatos viselkedésre van szükség, a <xref:microsoft.quantum.diagnostics.assertoperationsequalinplacecompbasis> korlátozott adatbevitelek esetében az egyenlőséget ellenőrzi.</span><span class="sxs-lookup"><span data-stu-id="3c592-177">In cases where an operation implements a reversible classical operation, such that we are only interested in its behavior on computational basis states, <xref:microsoft.quantum.diagnostics.assertoperationsequalinplacecompbasis> tests equality on this restricted set of inputs.</span></span>

> [!TIP]
> <span data-ttu-id="3c592-178">A bemeneti állapotokra való iterációt a számbavételi műveletek és a <xref:microsoft.quantum.canon.iteratethroughcartesianproduct> <xref:microsoft.quantum.canon.iteratethroughcartesianpower> .</span><span class="sxs-lookup"><span data-stu-id="3c592-178">The iteration over input states is handled by the enumeration operations <xref:microsoft.quantum.canon.iteratethroughcartesianproduct> and <xref:microsoft.quantum.canon.iteratethroughcartesianpower>.</span></span>
> <span data-ttu-id="3c592-179">Ezek a műveletek általánosságban hasznosak lehetnek ahhoz, hogy a Descartes-féle termék minden elemére a két vagy több készlet között alkalmazza a műveletet.</span><span class="sxs-lookup"><span data-stu-id="3c592-179">These operations are useful more generally for applying an operation to each element of the Cartesian product between two or more sets.</span></span>

<span data-ttu-id="3c592-180">Még ennél is fontosabb, hogy a két módszer a vizsgálat alatt álló műveletek különböző tulajdonságait teszteli.</span><span class="sxs-lookup"><span data-stu-id="3c592-180">More critically, however, the two approaches test different properties of the operations under examination.</span></span>
<span data-ttu-id="3c592-181">Mivel a helyben történő bejelentések többször is meghívja az egyes műveleteket, az egyes bemeneti állapotokhoz egyszer, minden véletlenszerű döntés és mérési eredmény változhat a hívások között.</span><span class="sxs-lookup"><span data-stu-id="3c592-181">Since the in-place assertion calls each operation multiple times, once for each input state, any random choices and measurement results might change between calls.</span></span>
<span data-ttu-id="3c592-182">Ezzel szemben a hivatkozott állítás pontosan egyszer hívja meg az egyes műveleteket, például ellenőrzi, hogy a műveletek *egyetlen lövéssel*egyenlőek-e.</span><span class="sxs-lookup"><span data-stu-id="3c592-182">By contrast, the referenced assertion calls each operation exactly once, such that it checks that the operations are equal *in a single shot*.</span></span>
<span data-ttu-id="3c592-183">Mindkét teszt hasznos a kvantum-programok helyességének biztosításához.</span><span class="sxs-lookup"><span data-stu-id="3c592-183">Both of these tests are useful in ensuring the correctness of quantum programs.</span></span>


## <a name="further-reading"></a><span data-ttu-id="3c592-184">További információ</span><span class="sxs-lookup"><span data-stu-id="3c592-184">Further Reading</span></span> ##

- <xref:microsoft.quantum.guide.testingdebugging>
- <xref:microsoft.quantum.diagnostics>
