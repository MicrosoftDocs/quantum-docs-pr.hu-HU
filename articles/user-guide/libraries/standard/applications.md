---
title: Alkalmazások a Q# standard könyvtárakban
description: Ismerkedjen meg a Quantum Computing – Hamilton szimuláció és a rövid keresési algoritmusának két alapvető alkalmazásával.
author: QuantumWriter
uid: microsoft.quantum.libraries.applications
ms.author: martinro
ms.date: 12/11/2017
ms.topic: conceptual
no-loc:
- Q#
- $$v
ms.openlocfilehash: 214d584840f235868c66a1fb3ee24d0acab49630
ms.sourcegitcommit: 71605ea9cc630e84e7ef29027e1f0ea06299747e
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 01/26/2021
ms.locfileid: "98857245"
---
# <a name="applications"></a><span data-ttu-id="c9877-103">Alkalmazások</span><span class="sxs-lookup"><span data-stu-id="c9877-103">Applications</span></span> #

## <a name="hamiltonian-simulation"></a><span data-ttu-id="c9877-104">Hamilton-szimuláció</span><span class="sxs-lookup"><span data-stu-id="c9877-104">Hamiltonian Simulation</span></span> ##

<span data-ttu-id="c9877-105">A kvantum-rendszerek szimulációja a kvantum-számítás legizgalmasabb alkalmazásai közé esik.</span><span class="sxs-lookup"><span data-stu-id="c9877-105">The simulation of quantum systems is one of the most exciting applications of quantum computation.</span></span>
<span data-ttu-id="c9877-106">A klasszikus számítógépeken a kvantummechanika szimulálása során felmerülő nehézségek általában az állapot-vektoros ábrázolás $N $ dimenzióval méretezhetők.</span><span class="sxs-lookup"><span data-stu-id="c9877-106">On a classical computer, the difficulty of simulating quantum mechanics, in general, scales with the dimension $N$ of its state-vector representation.</span></span>
<span data-ttu-id="c9877-107">Mivel ez a képviselet exponenciálisan növekszik a $n $ qubits $N = 2 ^ n $ értékkel, a [dimenzióját átka](xref:microsoft.quantum.concepts.multiple-qubits)néven ismert tulajdonság, a Quantum szimulációs a klasszikus hardveren nem vonható le.</span><span class="sxs-lookup"><span data-stu-id="c9877-107">As this representation grows exponentially with the number of $n$ qubits $N=2^n$, a trait known also known as the [curse of dimensionality](xref:microsoft.quantum.concepts.multiple-qubits), quantum simulation on classical hardware is intractable.</span></span>

<span data-ttu-id="c9877-108">A helyzet azonban nagyon eltérő lehet a kvantum hardveren.</span><span class="sxs-lookup"><span data-stu-id="c9877-108">However, the situation can be very different on quantum hardware.</span></span> <span data-ttu-id="c9877-109">A kvantum-szimuláció leggyakoribb változata az idő-független Hamilton-szimulációs probléma.</span><span class="sxs-lookup"><span data-stu-id="c9877-109">The most common variation of quantum simulation is called the time-independent Hamiltonian simulation problem.</span></span> <span data-ttu-id="c9877-110">Itt az egyik a System Hamilton $H $, amely egy Hermitian mátrix, és néhány kezdeti Quantum State $ \ket{\psi (0)} $, amelyet a rendszer a kvantum-számítógépeken $n $ qubits alapján kódol.</span><span class="sxs-lookup"><span data-stu-id="c9877-110">There, one is provided with a description of the system Hamiltonian $H$, which is a Hermitian matrix, and some initial quantum state $\ket{\psi(0)}$ that is encoded in some basis on $n$ qubits on a quantum computer.</span></span> <span data-ttu-id="c9877-111">A zárt rendszerekben a kvantum-állapotok a következő Schrödinger-egyenlettel fejlődnek: $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = H \ket{\psi (t)}, \end{align} $ $ a cél az, hogy megvalósítsa az egységes idő-evolúciós operátort $U (t) = e ^ {-iHt} $ értéket bizonyos rögzített időpontokban $t $, ahol $ \ket{\psi (t)} = U (t) \ket{\psi (0)} $ a Schrödinger-egyenlet feloldása.</span><span class="sxs-lookup"><span data-stu-id="c9877-111">As quantum states in closed systems evolve under the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ the goal is to implement the unitary time-evolution operator $U(t)=e^{-iHt}$ at some fixed time $t$, where $\ket{\psi(t)}=U(t)\ket{\psi(0)}$ solves the Schrödinger equation.</span></span>
<span data-ttu-id="c9877-112">Analogously az időfüggő Hamilton-szimulációs probléma ugyanazokat az egyenleteket oldja meg, de a $H (t) $ most már az idő függvénye.</span><span class="sxs-lookup"><span data-stu-id="c9877-112">Analogously, the time-dependent Hamiltonian simulation problem solves the same equation, but with $H(t)$ now a function of time.</span></span>

<span data-ttu-id="c9877-113">A Hamilton szimuláció a számos más kvantum-szimulációs probléma egyik fő összetevője, és a Hamilton-szimulációs problémák megoldásai olyan algoritmusok, amelyek egy egyszerű kvantum-kapuk sorozatát írják le, amely egy egységes \tilde{U} $ értéket ad meg a következő hibával: $ \\ | \tilde{U}-U (t) \\ | \Le \epsilon $ a [spektrális normában](xref:microsoft.quantum.concepts.matrix-advanced).</span><span class="sxs-lookup"><span data-stu-id="c9877-113">Hamiltonian simulation is a major component of many other quantum simulation problems, and solutions to Hamiltonian simulation problem are algorithms that describes a sequence of primitive quantum gates for synthesizing an approximating unitary $\tilde{U}$ with error $\\|\tilde{U} - U(t)\\| \le \epsilon$ in the [spectral norm](xref:microsoft.quantum.concepts.matrix-advanced).</span></span> <span data-ttu-id="c9877-114">Ezeknek az algoritmusoknak a bonyolultsága nagyon nagy mértékben függ attól, hogy egy kvantum-számítógép hogyan teszi elérhetővé a Hamilton leírását.</span><span class="sxs-lookup"><span data-stu-id="c9877-114">The complexity of these algorithms depend very strongly on how a description of the Hamiltonian of interest is made accessible by a quantum computer.</span></span> <span data-ttu-id="c9877-115">Ha például a legrosszabb esetben, ha $H $-t $n $ qubits-ra, a $2 ^ n \times 2 ^ n $ számú listának kell megadnia, az egyiket az egyes mátrix-elemeknél, egyszerűen csak az adatok olvasása már exponenciális idő szükséges.</span><span class="sxs-lookup"><span data-stu-id="c9877-115">For instance, in the worst-case, if $H$ acting on $n$ qubits were to be provided as a list of $2^n \times 2^n$ numbers, one for each matrix element, simply reading the data would already require exponential time.</span></span> <span data-ttu-id="c9877-116">A legjobb esetben feltételezhető, hogy egy olyan fekete dobozhoz fér hozzá, amely $O \ket{t}\ket{\psi (0)} = \ket{t}U (t) \ket{\psi (0)} $ triviálisan megoldja a problémát.</span><span class="sxs-lookup"><span data-stu-id="c9877-116">In the best case, one could assume access to a black-box unitary that $O\ket{t}\ket{\psi(0)}=\ket{t}U(t)\ket{\psi(0)}$ trivially solves the problem.</span></span> <span data-ttu-id="c9877-117">Ezen bemeneti modellek egyike sem különösen érdekes – az előző, mivel nem jobb, mint a klasszikus megközelítés, és az utóbbi, mint a fekete doboz elrejti a megvalósításának primitívebb kapuit, ami exponenciális lehet a qubits számában.</span><span class="sxs-lookup"><span data-stu-id="c9877-117">Neither of these input models are particularly interesting -- the former as it is no better than classical approaches, and the latter as the black-box hides the primitive gate complexity of its implementation, which could be exponential in the number of qubits.</span></span>

### <a name="descriptions-of-hamiltonians"></a><span data-ttu-id="c9877-118">A Hamiltonians leírása</span><span class="sxs-lookup"><span data-stu-id="c9877-118">Descriptions of Hamiltonians</span></span> ###

<span data-ttu-id="c9877-119">Ezért a bemenet formátumának további feltételezései szükségesek.</span><span class="sxs-lookup"><span data-stu-id="c9877-119">Additional assumptions of the format of the input are therefore required.</span></span> <span data-ttu-id="c9877-120">Az érdekes Hamiltonians (például reális fizikai rendszerek vagy érdekes számítási problémák) és olyan bemeneti modellek között, amelyek megfelelő mértékben korlátozóak a kvantum-számítógépeken való hatékony megvalósításhoz, olyan bemeneti modellek között kell leküzdeni, amelyek eléggé leíró jellegűek.</span><span class="sxs-lookup"><span data-stu-id="c9877-120">A fine balance must be struck between input models that are sufficiently descriptive to encompass interesting Hamiltonians, such as those for realistic physical systems or interesting computational problems, and input models that are sufficiently restrictive to be efficiently implementable on a quantum computer.</span></span> <span data-ttu-id="c9877-121">Számos nem triviális bemeneti modell található az irodalomban, és ezek a kvantumtól a klasszikusig terjedhetnek.</span><span class="sxs-lookup"><span data-stu-id="c9877-121">A variety of non-trivial input model may be found in the literature, and they range from quantum to classical.</span></span> 

<span data-ttu-id="c9877-122">A Quantum input-modellek példái [alapján a minta-alapú Hamilton-szimulációk](http://www.nature.com/articles/s41534-017-0013-7) feketéket feltételeznek a kvantum-műveletekhez, amelyek a sűrűségi mátrix $ \rho $-es példányait hozzák létre, amelyek a Hamilton $H $.</span><span class="sxs-lookup"><span data-stu-id="c9877-122">As examples of quantum input models, [sample-based Hamiltonian simulation](http://www.nature.com/articles/s41534-017-0013-7) assumes black-box access to quantum operations that produce copies of a density matrix $\rho$, which are taken to be the Hamiltonian $H$.</span></span> <span data-ttu-id="c9877-123">Az [egységes hozzáférési modellben](https://arxiv.org/abs/1202.5822) az egyik azt feltételezi, hogy a Hamilton a unitaries $ $ \begin{align} H & = \sum ^ {d-1} \_ {j = 0} számú összegbe kerül \_ . a j \hat{U} \_ j, \end{align} $ $, ahol $a \_ j>$0, és $ \hat{U} \_ j $ unitaries.</span><span class="sxs-lookup"><span data-stu-id="c9877-123">In the [unitary access model](https://arxiv.org/abs/1202.5822) one supposes that the Hamiltonian instead decomposes into a sum of unitaries $$ \begin{align} H & = \sum^{d-1}\_{j=0} a\_j \hat{U}\_j, \end{align} $$ where $a\_j>0$ are coefficients, and $\hat{U}\_j$ are unitaries.</span></span> <span data-ttu-id="c9877-124">Ezt követően a rendszer feltételezi, hogy az egyiknek fekete-Box hozzáférése van az egységes Oracle $V = \sum ^ {d-1} \_ {j = 0} \Ket{j}\bra{j}\otimes \hat{U} \_ j $, amely kiválasztja a kívánt $ \hat{U} \_ j $ értéket. és az Oracle $A \ket {0} = \sum ^ {d-1} \_ {j = 0} \sqrt{a \_ j/\ Sum ^ {d-1} \_ {k = 0} \alpha \_ j} \ket{j} $, amely kvantum-állapotot hoz létre a jelen együtthatók kódolásával.</span><span class="sxs-lookup"><span data-stu-id="c9877-124">It is then assumed that one has black-box access to the unitary oracle $V=\sum^{d-1}\_{j=0}\ket{j}\bra{j}\otimes \hat{U}\_j$ that selects the desired $\hat{U}\_j$, and the oracle $A\ket{0}=\sum^{d-1}\_{j=0}\sqrt{a\_j/\sum^{d-1}\_{k=0}\alpha\_j}\ket{j}$ that create a quantum state encoding these coefficients.</span></span> <span data-ttu-id="c9877-125">[Ritka Hamilton szimuláció](https://arxiv.org/abs/quant-ph/0301023)esetén az egyik azt feltételezi, hogy a Hamilton egy ritka mátrix, amely csak $d = \mathcal{O} (\Text{polylog} (N)) $ nem nulla értékű elemet tartalmaz minden sorban.</span><span class="sxs-lookup"><span data-stu-id="c9877-125">In the case of [sparse Hamiltonian simulation](https://arxiv.org/abs/quant-ph/0301023), one assumes that the Hamiltonian is a sparse matrix with only $d=\mathcal{O}(\text{polylog}(N))$ non-zero element in every row.</span></span> <span data-ttu-id="c9877-126">Emellett az egyik feltételezi, hogy a hatékony kvantum-áramkörök megléte a nullától eltérő elemek helyét, valamint azok értékeit is kiadja.</span><span class="sxs-lookup"><span data-stu-id="c9877-126">Moreover, one assumes the existence of efficient quantum circuits that output the location of these non-zero elements, as well as the their values.</span></span> <span data-ttu-id="c9877-127">A Hamilton- [szimulációs algoritmusok](xref:microsoft.quantum.more-information) összetettségét a rendszer a fekete mezőkre vonatkozó lekérdezések száma alapján értékeli ki, és a primitív kapu összetettsége nagy mértékben függ a fekete dobozok megvalósításának nehéz feladataitól.</span><span class="sxs-lookup"><span data-stu-id="c9877-127">The complexity of [Hamiltonian simulation algorithms](xref:microsoft.quantum.more-information) is evaluated in terms of number of queries to these black-boxes, and the primitive gate complexity then depends very much on the difficulty of implementing these black-boxes.</span></span>

> [!NOTE]
> <span data-ttu-id="c9877-128">A Big-O jelölés általában az algoritmusok összetettségi skálázásának leírására szolgál.</span><span class="sxs-lookup"><span data-stu-id="c9877-128">The big-O notation is commonly used to describe the complexity scaling of algorithms.</span></span> <span data-ttu-id="c9877-129">A két valós functions $f, g $, The Expression $g (x) = \mathcal{O} (f (x)) $ érték azt jelenti, hogy létezik egy abszolút pozitív konstans $x \_ 0, c>$0, hogy $g (x) \Le c f (x) $ az összes $x \ge x \_ $0.</span><span class="sxs-lookup"><span data-stu-id="c9877-129">Given two real functions $f,g$, the expression $g(x)=\mathcal{O}(f(x))$ means that there exists an absolute positive constant $x\_0, c>0$ such that $g(x) \le c f(x)$ for all $x\ge x\_0$.</span></span> 

<span data-ttu-id="c9877-130">A legalkalmasabb alkalmazások a kvantum-számítógépeken történő megvalósításához a fekete dobozok hatékony implementálása szükséges, amely a $ \mathcal{O} (\text{polylog} (N)) $ primitív Quantum Gates.</span><span class="sxs-lookup"><span data-stu-id="c9877-130">In most practical applications to be implemented on a quantum computer, these black-boxes must be efficiently implementable, that is with $\mathcal{O}(\text{polylog}(N))$ primitive quantum gates.</span></span> <span data-ttu-id="c9877-131">Erősebb, hatékony simulable Hamiltonians kell lennie a klasszikusan ritka leírásnak.</span><span class="sxs-lookup"><span data-stu-id="c9877-131">More strongly, efficiently simulable Hamiltonians must have some sufficiently sparse classical description.</span></span> <span data-ttu-id="c9877-132">Az egyik ilyen megfogalmazás azt feltételezi, hogy a Hamilton a Hermitian-részek összegét összegzi $ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j.</span><span class="sxs-lookup"><span data-stu-id="c9877-132">In one such formulation, it is assumed that the Hamiltonian decomposes into a sum of Hermitian parts $$ \begin{align} H & = \sum^{d-1}_{j=0} H_j.</span></span>
<span data-ttu-id="c9877-133">\end{align} $ $, feltételezi, hogy az egyes részek, egy Hamilton $H \_ j $, könnyen szimulálható.</span><span class="sxs-lookup"><span data-stu-id="c9877-133">\end{align} $$ Moreover, it is assumed that each part, a Hamiltonian $H\_j$, is easy to simulate.</span></span> <span data-ttu-id="c9877-134">Ez azt jelenti, hogy az egységes $e ^ {-iH \_ j t} $ $t a $ \mathcal{O} (1) $ primitív Quantum Gates használatával pontosan implementálható.</span><span class="sxs-lookup"><span data-stu-id="c9877-134">This means that the unitary $e^{-iH\_j t}$ for any time $t$ may be implemented exactly using $\mathcal{O}(1)$ primitive quantum gates.</span></span> <span data-ttu-id="c9877-135">Ez például abban az esetben igaz, amikor minden $H \_ j $ a helyi Pauli-operátor, ami azt jelenti, hogy a (z) $ \mathcal{O} (1) $ nem Identity Pauli-operátorok, amelyek térbelien zárt qubits működnek.</span><span class="sxs-lookup"><span data-stu-id="c9877-135">For instance, this is true in the special case where each $H\_j$ are local Pauli operators, meaning that they are of tensor products of $\mathcal{O}(1)$ non-identity Pauli operators that act on spatially close qubits.</span></span> <span data-ttu-id="c9877-136">Ez a modell különösen a kötött és helyi interakcióval rendelkező fizikai rendszerek esetében érvényes, mivel a feltételek száma $d = \mathcal{O} (\text{polylog} (N)) $, és egyértelműen írható le, azaz a "klasszikusan" leírt módon.</span><span class="sxs-lookup"><span data-stu-id="c9877-136">This model is particularly applicable to physical systems with bounded and local interaction, as the number of terms is $d=\mathcal{O}(\text{polylog}(N))$, and may clearly be written down, i.e. classically described, in polynomial time.</span></span>

> [!TIP]
> <span data-ttu-id="c9877-137">Az egyes részekre bontásban lévő Hamiltonians a dinamikus generátor képviseleti könyvtárának használatával lehet leírni.</span><span class="sxs-lookup"><span data-stu-id="c9877-137">Hamiltonians that decompose into a sum of parts may be described using the Dynamical Generator Representation library.</span></span> <span data-ttu-id="c9877-138">További információ: a dinamikus generátorok ábrázolási szakasza az [adatstruktúrákban](xref:microsoft.quantum.libraries.data-structures).</span><span class="sxs-lookup"><span data-stu-id="c9877-138">For more information, see the Dynamical Generator Representation section in [data structures](xref:microsoft.quantum.libraries.data-structures).</span></span>

### <a name="simulation-algorithms"></a><span data-ttu-id="c9877-139">Szimulációs algoritmusok</span><span class="sxs-lookup"><span data-stu-id="c9877-139">Simulation Algorithms</span></span> ###

<span data-ttu-id="c9877-140">A kvantum-szimulációs algoritmus egy Hamilton egy adott leírását egy primitív kvantum-kapun alakítja át, amely teljes körű, becsült idő-evolúciót mutat a Hamilton szerint.</span><span class="sxs-lookup"><span data-stu-id="c9877-140">A quantum simulation algorithm converts a given description of a Hamiltonian into a sequence of primitive quantum gates that, as a whole, approximate time-evolution by said Hamiltonian.</span></span>

<span data-ttu-id="c9877-141">Abban a különleges esetben, ha a Hamilton Hermitian-részekre van lebontva, a Trotter-Suzuki bomlás egy olyan egyszerű és intuitív algoritmus, amely szimulálja a Hamiltonians a Hermitian-összetevők összegét.</span><span class="sxs-lookup"><span data-stu-id="c9877-141">In the special case where the Hamiltonian decomposes into a sum of Hermitian parts, the Trotter-Suzuki decomposition is a particularly simple and intuitive algorithm for simulating Hamiltonians that decompose into a sum of Hermitian components.</span></span> <span data-ttu-id="c9877-142">A család első sorrendű integrátora például a $ $ \begin{align} U (t) & = \left (e ^ {-iH \_ 0 t/r} e ^ {-IH \_ 1 t/r} \cdots e ^ {-IH \_ {d-1} t/r} \right) közelíti meg. ^ {r} + \mathcal{O} (d ^ 2 \ max_j \\ | H \_ j \\ | ^ 2 t ^ 2/r), \end{align} $ $ $r d $ feltételt használó termékkel.</span><span class="sxs-lookup"><span data-stu-id="c9877-142">For instance, a first-order integrator of this family approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j\\|H\_j\\|^2 t^2/r), \end{align} $$ using a product of $r d$ terms.</span></span> 

> [!TIP]
> <span data-ttu-id="c9877-143">A minták a Trotter-Suzuki szimulációs algoritmus alkalmazásait fedik le.</span><span class="sxs-lookup"><span data-stu-id="c9877-143">Applications of the Trotter-Suzuki simulation algorithm are covered in the samples.</span></span>
> <span data-ttu-id="c9877-144">Ahhoz, hogy a Ising modell csak az egyes célszámítógépeken elérhető belső műveleteket használja, tekintse meg a [ **SimpleIsing** -mintát](https://github.com/microsoft/Quantum/blob/main/samples/simulation/ising/simple).</span><span class="sxs-lookup"><span data-stu-id="c9877-144">For the Ising model using only the intrinsic operations provided by each target machine, please see the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/blob/main/samples/simulation/ising/simple).</span></span>
> <span data-ttu-id="c9877-145">A Ising modell Trotter-Suzuki könyvtár vezérlő struktúrájának használatával kapcsolatban tekintse meg a [ **IsingTrotter** mintát](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/trotter-evolution).</span><span class="sxs-lookup"><span data-stu-id="c9877-145">For the Ising model using the Trotter-Suzuki library control structure, please see the [**IsingTrotter** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/trotter-evolution).</span></span>
> <span data-ttu-id="c9877-146">A Trotter-Suzuki könyvtár-vezérlési struktúrát használó molekuláris hidrogén esetében tekintse meg a [ **H2 szimulációs** mintát](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line).</span><span class="sxs-lookup"><span data-stu-id="c9877-146">For molecular Hydrogen using the Trotter-Suzuki library control structure, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line).</span></span>

<span data-ttu-id="c9877-147">Sok esetben szeretnénk megvalósítani a szimulációs algoritmust, de nem érdeklik a megvalósításának részletei.</span><span class="sxs-lookup"><span data-stu-id="c9877-147">In many cases, we would like to implement the simulation algorithm, but are not interested in the details of its implementation.</span></span> <span data-ttu-id="c9877-148">Például: a második sorrendű integrátor körülbelül $ $ \begin{align} U (t) & = \left (e ^ {-iH \_ 0 t/2r} e ^ {-IH \_ 1 t/2r} \cdots e ^ {-IH \_ {d-1} t/2r} e ^ {-IH \_ {d-1} t/2r} \cdots e ^ {-IH \_ 1 t/2r} e ^ {-iH \_ 0 t/2r} \right) ^ {r} + \mathcal{O} (d ^ 3 \ max_j \\ | H \_ j \\ | ^ 3 t ^ 3/r ^ 2), \end{align} $ $ $2RD $ feltételt használó termékkel.</span><span class="sxs-lookup"><span data-stu-id="c9877-148">For instance, the second-order integrator approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / 2r} e^{-iH\_1 t / 2r} \cdots e^{-iH\_{d-1} t / 2r} e^{-iH\_{d-1} t / 2r}  \cdots e^{-iH\_1 t / 2r} e^{-iH\_0 t / 2r} \right)^{r} + \mathcal{O}(d^3 \max_j\\|H\_j\\|^3 t^3/r^2), \end{align} $$ using a product of $2rd$ terms.</span></span> <span data-ttu-id="c9877-149">A nagyobb megrendelések esetében még a feltételek és az optimalizált változatok is nagy mértékben nem triviális rendezést igényelhetnek az exponenciálisan.</span><span class="sxs-lookup"><span data-stu-id="c9877-149">Larger orders will involve even more terms and optimized variants may require highly non-trivial orderings on the exponentials.</span></span> <span data-ttu-id="c9877-150">Más speciális algoritmusok is magukban foglalhatják a Ancilla qubits használatát a közbenső lépésekben.</span><span class="sxs-lookup"><span data-stu-id="c9877-150">Other advanced algorithms may also involve the use of ancilla qubits in intermediate steps.</span></span> <span data-ttu-id="c9877-151">Így a szimulációs algoritmusokat a Canonban, felhasználó által definiált típusként csomagoljuk</span><span class="sxs-lookup"><span data-stu-id="c9877-151">Thus we package simulation algorithms in the canon as the user-defined type</span></span>

```qsharp
newtype SimulationAlgorithm = ((Double, EvolutionGenerator, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="c9877-152">Az első paraméter `Double` a szimuláció időpontja, a második paraméter, amely az `EvolutionGenerator` [adatstruktúrák](xref:microsoft.quantum.libraries.data-structures)dinamikus generátorok ábrázolási szakaszában szerepel, egy időfüggetlen Hamilton klasszikus leírása, amely leírja, hogy a Hamilton egyes használati időszakait hogyan lehet szimulálni.</span><span class="sxs-lookup"><span data-stu-id="c9877-152">The first parameter `Double` is the time of simulation, the second parameter `EvolutionGenerator`, covered in the Dynamical Generator Representation section of [data-structures](xref:microsoft.quantum.libraries.data-structures), is a classical description of a time-independent Hamiltonian packaged with instructions on how each term in the Hamiltonian may be simulated by a quantum circuit.</span></span> <span data-ttu-id="c9877-153">Az űrlap típusai megközelítik a (z) "^ {-iHt} $" egységes $e műveletet a harmadik paraméteren `Qubit[]` , amely a szimulált rendszer kvantum-állapotát tároló regisztráció.</span><span class="sxs-lookup"><span data-stu-id="c9877-153">Types of this form approximate the unitary operation $e^{-iHt}$ on the third parameter `Qubit[]`, which is the register storing the quantum state of the simulated system.</span></span> <span data-ttu-id="c9877-154">Az időfüggő esethez hasonlóan a felhasználó által definiált típust is definiáljuk `EvolutionSchedule` , amely egy időfüggő Hamilton klasszikus leírása.</span><span class="sxs-lookup"><span data-stu-id="c9877-154">Similarly for the time-dependent case, we define a user-defined type with an `EvolutionSchedule` type instead, which is a classical description of a time-dependent Hamiltonian.</span></span>

```qsharp
newtype TimeDependentSimulationAlgorithm = ((Double, EvolutionSchedule, Qubit[]) => Unit : Adjoint, Controlled);
```

<span data-ttu-id="c9877-155">Előfordulhat például, hogy az Trotter-Suzuki a következő Canon függvények használatával hívható meg, és a paraméterek a `trotterStepSize` Szimuláció időtartamát módosítják az egyes exponenciális értékekben, valamint a `trotterOrder` kívánt integrátor sorrendjét.</span><span class="sxs-lookup"><span data-stu-id="c9877-155">As an example, the Trotter-Suzuki decomposition may be called using the following canon functions, with parameters `trotterStepSize` modifying the duration of simulation in each exponential, and `trotterOrder` for the order of the desired integrator.</span></span>

```qsharp
function TrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: SimulationAlgorithm {
    ...
}

function TimeDependentTrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: TimeDependentSimulationAlgorithm {
    ...
}
```

> [!TIP]
> <span data-ttu-id="c9877-156">A szimulációs függvénytár alkalmazásait a minták tartalmazzák.</span><span class="sxs-lookup"><span data-stu-id="c9877-156">Applications of the simulation library are covered in the samples.</span></span> <span data-ttu-id="c9877-157">A Ising modellben használt fázis-becsléshez `SimulationAlgorithm` tekintse meg a [ **IsingPhaseEstimation** mintát](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="c9877-157">For phase estimation in the Ising model using `SimulationAlgorithm`, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>
> <span data-ttu-id="c9877-158">A adiabatic-állapot előkészítéséhez a Ising-modellben `TimeDependentSimulationAlgorithm` tekintse meg a [ **AdiabaticIsing** mintát](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span><span class="sxs-lookup"><span data-stu-id="c9877-158">For adiabatic state preparation in the Ising model using `TimeDependentSimulationAlgorithm`, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span></span>


### <a name="adiabatic-state-preparation--phase-estimation"></a><span data-ttu-id="c9877-159">Adiabatic állapot-előkészítés & fázisának becslése</span><span class="sxs-lookup"><span data-stu-id="c9877-159">Adiabatic State Preparation & Phase Estimation</span></span> ###

<span data-ttu-id="c9877-160">A Hamilton szimuláció egyik gyakori alkalmazása a adiabatic állapotának előkészítése.</span><span class="sxs-lookup"><span data-stu-id="c9877-160">One common application of Hamiltonian simulation is adiabatic state preparation.</span></span> <span data-ttu-id="c9877-161">Itt az egyik a következő két Hamiltonians $H \_ {\text{Start}} $ és $H \_ {\text{End}} $, valamint egy Quantum State $ \ket{\psi (0)} $, amely a start Hamilton $H \_ {\text{Start}} $.</span><span class="sxs-lookup"><span data-stu-id="c9877-161">Here, one is provided with two Hamiltonians $H\_{\text{start}}$ and $H\_{\text{end}}$, and a quantum state $\ket{\psi(0)}$ that is a ground state of the start Hamiltonian $H\_{\text{start}}$.</span></span> <span data-ttu-id="c9877-162">A $H \_ {\text{Start}} $ általában úgy van kiválasztva, hogy a $ \ket{\psi (0)} $-es verzió könnyen feldolgozható a számítási alapú állapotból $ \ket{0\cdots 0} $ értékkel.</span><span class="sxs-lookup"><span data-stu-id="c9877-162">Typically, $H\_{\text{start}}$ is chosen such that $\ket{\psi(0)}$ is easy to prepare from a computational basis state $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="c9877-163">Ezeknek a Hamiltonians az időfüggő szimulációs probléma elég lassan történő interpolációja révén a végén nagy valószínűséggel a végső $H Hamilton \_ ({\text{End}} $) végleges állapotba hozható.</span><span class="sxs-lookup"><span data-stu-id="c9877-163">By interpolating between these Hamiltonians in the time-dependent simulation problem sufficiently slowly, it is possible to end up, with high probability, in a ground state of the final Hamiltonian $H\_{\text{end}}$.</span></span> <span data-ttu-id="c9877-164">Bár a jó közelítések Hamilton a terepi állapotokra, így az időfüggő Hamilton-szimulációs algoritmusok alrutinként is meghívhatók, más, elméletileg eltérő megközelítések, például a variációs Quantum eigensolver.</span><span class="sxs-lookup"><span data-stu-id="c9877-164">Though preparing good approximations to Hamiltonian ground states could proceed in this manner by calling upon on time-dependent Hamiltonian simulation algorithms as a subroutine, other conceptually different approaches such as the variational quantum eigensolver are possible.</span></span>

<span data-ttu-id="c9877-165">Egy másik alkalmazás, amely mindenütt a Quantum kémiában található, megbecsüli a kémiai reakció közbenső lépéseit jelképező Hamiltonians.</span><span class="sxs-lookup"><span data-stu-id="c9877-165">Yet another application ubiquitous in quantum chemistry is estimating the ground state energy of Hamiltonians representing the intermediate steps of chemical reaction.</span></span> <span data-ttu-id="c9877-166">Ilyen séma lehet például, hogy adiabatic állapot-előkészítést használ a terepi állapot létrehozásához, majd időfüggetlen Hamilton szimulációt alkalmaz a fázis-becslési jellemzésben, hogy kinyerje ezt az energiát némi véges hibával és a siker valószínűségével.</span><span class="sxs-lookup"><span data-stu-id="c9877-166">Such a scheme could, for instance, rely on adiabatic state preparation to create the ground state, and then incorporate time-independent Hamiltonian simulation as a subroutine in phase estimation characterization to extract this energy with some finite error and probability of success.</span></span> 

<span data-ttu-id="c9877-167">Absztrakt szimulációs algoritmusok felhasználó által definiált típusként, `SimulationAlgorithm` és `TimeDependentSimulationAlgorithm` lehetővé teszik a funkciók kényelmes beépítését kifinomultabb kvantum-algoritmusokban.</span><span class="sxs-lookup"><span data-stu-id="c9877-167">Abstracting simulation algorithms as the user-defined types `SimulationAlgorithm` and `TimeDependentSimulationAlgorithm` allow us to conveniently incorporate their functionality into more sophisticated quantum algorithms.</span></span> <span data-ttu-id="c9877-168">Ez a gyakran használt alrutinok esetében is motivált.</span><span class="sxs-lookup"><span data-stu-id="c9877-168">This motivates us to do the same for these commonly used subroutines.</span></span>

<span data-ttu-id="c9877-169">Így definiáljuk a kényelmes függvényt</span><span class="sxs-lookup"><span data-stu-id="c9877-169">Thus we define the convenient function</span></span>

```qsharp
function InterpolatedEvolution(
        interpolationTime : Double, 
        evolutionGeneratorStart : EvolutionGenerator,
        evolutionGeneratorEnd : EvolutionGenerator,
        timeDependentSimulationAlgorithm : TimeDependentSimulationAlgorithm)
: (Qubit[] => Unit is Adj + Ctl) {
        ...
}
 
```

<span data-ttu-id="c9877-170">Ez egy egységes műveletet ad vissza, amely megvalósítja a adiabatic-állapot előkészítésének összes lépését.</span><span class="sxs-lookup"><span data-stu-id="c9877-170">This returns a unitary operation that implements all steps of adiabatic state preparation.</span></span> <span data-ttu-id="c9877-171">Az első paraméter `interpolatedTime` azt az időpontot határozza meg, amikor lineárisan interpolált a második paraméter által leírt indítási Hamilton `evolutionGeneratorStart` és a harmadik paraméter által leírt záró Hamilton között `evolutionGeneratorEnd` .</span><span class="sxs-lookup"><span data-stu-id="c9877-171">The first parameter `interpolatedTime` defines the time over which we linearly interpolate between the start Hamiltonian described by the second parameter `evolutionGeneratorStart` and the end Hamiltonian described by the third parameter `evolutionGeneratorEnd`.</span></span> <span data-ttu-id="c9877-172">A negyedik paraméter az `timeDependentSimulationAlgorithm` , ahol a szimulált algoritmus közül választhat.</span><span class="sxs-lookup"><span data-stu-id="c9877-172">The fourth parameter `timeDependentSimulationAlgorithm` is where one makes the choice of simulation algorithm.</span></span> <span data-ttu-id="c9877-173">Vegye figyelembe, hogy ha `interpolatedTime` elég hosszú, a kezdeti Alapállapot a Hamilton pillanatnyi állapotában marad az időfüggő szimuláció teljes időtartama alatt, és így végződik a végső Hamilton.</span><span class="sxs-lookup"><span data-stu-id="c9877-173">Note that if `interpolatedTime` is long enough, an initial ground state remains an instantaneous ground state of the Hamiltonian over the entire duration of time-dependent simulation, and thus ends in the ground state of the end Hamiltonian.</span></span>

<span data-ttu-id="c9877-174">Egy olyan hasznos műveletet is definiálunk, amely egy tipikus kvantum-kémiai kísérlet minden lépését automatikusan végrehajtja.</span><span class="sxs-lookup"><span data-stu-id="c9877-174">We also define a helpful operation that automatically performs all steps of a typical quantum chemistry experiment.</span></span> <span data-ttu-id="c9877-175">Például a következők állnak rendelkezésre, amely visszaadja az adiabatic állapot-előkészítéssel előállított állapot becslését:</span><span class="sxs-lookup"><span data-stu-id="c9877-175">For instance we have the following, which returns an energy estimate of the state produced by adiabatic state preparation:</span></span>

```qsharp
operation EstimateAdiabaticStateEnergy(
    nQubits : Int,
    statePrepUnitary : (Qubit[] => Unit),
    adiabaticUnitary : (Qubit[] => Unit),
    qpeUnitary: (Qubit[] => Unit is Adj + Ctl),
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double {
...
}
```

<span data-ttu-id="c9877-176">`nQubits` a kezdeti kvantum-állapot kódolásához használt qubits száma.</span><span class="sxs-lookup"><span data-stu-id="c9877-176">`nQubits` is the number of qubits used to encode the initial quantum state.</span></span> <span data-ttu-id="c9877-177">`statePrepUnitary` előkészíti az indítási állapotot a $ \ket{0\cdots 0} $ számítási alapján.</span><span class="sxs-lookup"><span data-stu-id="c9877-177">`statePrepUnitary` prepares the start state from the computational basis $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="c9877-178">`adiabaticUnitary` a a adiabatic állapot-előkészítést megvalósító egységes művelet, például a függvény által előállított  `InterpolatedEvolution` .</span><span class="sxs-lookup"><span data-stu-id="c9877-178">`adiabaticUnitary` is the unitary operation that implements adiabatic state preparation, such as produced by the  `InterpolatedEvolution` function.</span></span> <span data-ttu-id="c9877-179">`qpeUnitary` az az egységes művelet, amellyel a rendszer a fázisok becslését hajtja végre az eredményül kapott kvantum állapoton.</span><span class="sxs-lookup"><span data-stu-id="c9877-179">`qpeUnitary` is the unitary operation that is used to perform phase estimation on the resulting quantum state.</span></span> <span data-ttu-id="c9877-180">`phaseEstAlgorithm` a fázis becslési algoritmusa közül választhat.</span><span class="sxs-lookup"><span data-stu-id="c9877-180">`phaseEstAlgorithm` is our choice of phase estimation algorithm.</span></span>

> [!TIP]
> <span data-ttu-id="c9877-181">A mintákban a adiabatic-állapot előkészítésének alkalmazásai szerepelnek.</span><span class="sxs-lookup"><span data-stu-id="c9877-181">Applications of adiabatic state preparation are covered in the samples.</span></span> <span data-ttu-id="c9877-182">A Ising modell adiabatic állapot-előkészítésének manuális megvalósításával és a függvény használatával `AdiabaticEvolution` tekintse meg a [ **AdiabaticIsing** mintát](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span><span class="sxs-lookup"><span data-stu-id="c9877-182">For the Ising model using a manual implementation of adiabatic state preparation versus using the `AdiabaticEvolution` function, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span></span>
> <span data-ttu-id="c9877-183">A Ising modellben a fázisok becslése és a adiabatic állapotának előkészítéséhez tekintse meg a [ **IsingPhaseEstimation** mintát](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="c9877-183">For phase estimation and adiabatic state preparation in the Ising model, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>

> [!TIP]
> <span data-ttu-id="c9877-184">A [molekuláris hidrogén szimulálása](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) egy érdekes és rövid minta.</span><span class="sxs-lookup"><span data-stu-id="c9877-184">The [simulation of molecular Hydrogen](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) is an interesting and brief sample.</span></span> <span data-ttu-id="c9877-185">A [O'Malley et. Al](https://arxiv.org/abs/1512.06860) -ben jelentett modell és kísérleti eredmények.</span><span class="sxs-lookup"><span data-stu-id="c9877-185">The model and experimental results reported in [O'Malley et. al.](https://arxiv.org/abs/1512.06860)</span></span> <span data-ttu-id="c9877-186">csak a Pauli-mátrixok szükségesek, és az űrlapon a $ \hat H = g \_ {0} I \_ 0i \_ 1 + g \_ 1 {z \_ 0} + g \_ 2 {z \_ 1} + g \_ 3 {z \_ 0} {z \_ 1} + g \_ 4 {y \_ 0} {y \_ 1} + g \_ 5 {x \_ 0} {x \_ 1} $ értéket kell használnia.</span><span class="sxs-lookup"><span data-stu-id="c9877-186">only requires Pauli matrices and takes the form $\hat H = g\_{0}I\_0I\_1+g\_1{Z\_0}+g\_2{Z\_1}+g\_3{Z\_0}{Z\_1}+g\_4{Y\_0}{Y\_1}+g\_5{X\_0}{X\_1}$.</span></span> <span data-ttu-id="c9877-187">Ez egy hatékony Hamilton, amely csak a 2 qubits-t igényli, ahol a $g $ konstansokat a két hidrogén atomok közötti távolságból számított $R $ értékre számítjuk.</span><span class="sxs-lookup"><span data-stu-id="c9877-187">This is an effective Hamiltonian only requiring only 2 qubits, where the constants $g$ are computed from the distance $R$ between the two Hydrogen atoms.</span></span> <span data-ttu-id="c9877-188">A Canon functions használatával a Paulis átalakítja a unitaries-re, majd rövid idő alatt kifejlődött a Trotter-Suzuki bontás használatával.</span><span class="sxs-lookup"><span data-stu-id="c9877-188">Using canon functions, the Paulis are converted to unitaries and then evolved over short periods of time using the Trotter-Suzuki decomposition.</span></span> <span data-ttu-id="c9877-189">A adiabatic-állapot előkészítése nélkül hozható létre jó közelítés a $H _2 $ alapállapothoz, és így a rendszer közvetlenül a Canontól származó fázis-becslés használatával is megtalálhatja a terepi állapotot.</span><span class="sxs-lookup"><span data-stu-id="c9877-189">A good approximation to the $H_2$ ground state can be created without using adiabatic state preparation, and so the ground state energy may be found directly by utilizing phase estimation from the canon.</span></span>

## <a name="shors-algorithm"></a><span data-ttu-id="c9877-190">Shor-algoritmus</span><span class="sxs-lookup"><span data-stu-id="c9877-190">Shor's Algorithm</span></span> ##
<span data-ttu-id="c9877-191">A rövid algoritmusa továbbra is a kvantum-számítástechnika egyik legjelentősebb folyamata marad, mivel ez azt mutatta, hogy a kvantum-számítógépek a fontos, jelenleg klasszikusan megoldhatatlan problémák megoldására használhatók.</span><span class="sxs-lookup"><span data-stu-id="c9877-191">Shor's algorithm remains one of the most significant developments in quantum computing because it showed that quantum computers could be used to solve important, currently classically intractable problems.</span></span>
<span data-ttu-id="c9877-192">A rövid algoritmusa gyors megoldást kínál a nagy számokra a kvantum-számítógép, a *faktoring* nevű probléma használatával.</span><span class="sxs-lookup"><span data-stu-id="c9877-192">Shor's algorithm provides a fast way to factor large numbers using a quantum computer, a problem called *factoring*.</span></span>
<span data-ttu-id="c9877-193">A sok mai cryptosystems biztonsága azon a feltételezésen alapul, hogy nem létezik gyors algoritmus a faktoring szolgáltatáshoz.</span><span class="sxs-lookup"><span data-stu-id="c9877-193">The security of many present-day cryptosystems is based on the assumption that no fast algorithm exists for factoring.</span></span>
<span data-ttu-id="c9877-194">Ennek megfelelően a rövid algoritmusa olyan hatással volt, hogy miként gondolunk a biztonságra a kvantum utáni világban.</span><span class="sxs-lookup"><span data-stu-id="c9877-194">Thus Shor's algorithm has had a profound impact on how we think about security in a post-quantum world.</span></span>

<span data-ttu-id="c9877-195">A rövid algoritmusa hibrid algoritmus lehet.</span><span class="sxs-lookup"><span data-stu-id="c9877-195">Shor's algorithm can be thought of as a hybrid algorithm.</span></span>
<span data-ttu-id="c9877-196">A kvantum-számítógép egy számítási feladatok elvégzésére szolgál.</span><span class="sxs-lookup"><span data-stu-id="c9877-196">The quantum computer is used to perform a computationally hard task known as period finding.</span></span>
<span data-ttu-id="c9877-197">A rendszer az időszak megkeresésének eredményét a klasszikusan dolgozza fel a tényezők becslése érdekében.</span><span class="sxs-lookup"><span data-stu-id="c9877-197">The results from period finding are then classically processed to estimate the factors.</span></span>
<span data-ttu-id="c9877-198">Ezt a két lépést alább tekintjük át.</span><span class="sxs-lookup"><span data-stu-id="c9877-198">We review these two steps below.</span></span>

### <a name="period-finding"></a><span data-ttu-id="c9877-199">Időszak megállapítása</span><span class="sxs-lookup"><span data-stu-id="c9877-199">Period Finding</span></span> ###

<span data-ttu-id="c9877-200">Miután megismerte, hogyan működik a Quantum Fourier-transzformáció és a fázis becslése (lásd a [kvantum-algoritmusokat](xref:microsoft.quantum.libraries.standard.algorithms)), ezeket az eszközöket felhasználhatjuk a hagyományosan nehéz számítási probléma megoldásához, amelynek elnevezése az *időszak megállapítása*.</span><span class="sxs-lookup"><span data-stu-id="c9877-200">Having seen how the quantum Fourier transform and phase estimation work (see [Quantum algorithms](xref:microsoft.quantum.libraries.standard.algorithms)), we can use these tools to solve a classically hard computational problem called *period finding*.</span></span>  <span data-ttu-id="c9877-201">A következő szakaszban bemutatjuk, hogyan alkalmazhatja az időszak megállapítását a faktoring szolgáltatásba.</span><span class="sxs-lookup"><span data-stu-id="c9877-201">In the next section, we will see how to apply period finding to factoring.</span></span>

<span data-ttu-id="c9877-202">A két egész szám $a $ és $N $ között, ahol a $a<N $, az időszak megállapításának célját, más néven a sorrend megállapítását is, az a _sorrend_ , amely $r $ $a $ többtényezős $N $, ahol $r $ a legkevésbé pozitív egész számnak felel meg, például $a ^ r \equiv 1 \text{mod} N $.</span><span class="sxs-lookup"><span data-stu-id="c9877-202">Given two integers $a$ and $N$, where $a<N$, the goal of period finding, also called order finding, is to find the _order_ $r$ of $a$ modulo $N$, where $r$ is defined to be the least positive integer such that $a^r \equiv 1 \text{ mod } N$.</span></span>  

<span data-ttu-id="c9877-203">Ha kvantum-számítógép használatával szeretné megkeresni a sorrendet, a következő egységes operátorra alkalmazott fázis-becslési algoritmust is használhatja $U _a $: $ $ U_a \ket{x} \equiv \ket{(AX) \text{mod} N}. $ $ a $U _a $ eigenvectors az egész $s $ és $0 \ LEQ s \leq r-$1, $ $ \ket{x_s} \equiv 1/\sqrt{r} \sum \_ {k = 0} ^ {r-1} e ^ {\frac{-2\pi i SK} {r}} \ket{a ^ k\text {mod} N}, $ $ _eigenstates_ $U _a $.</span><span class="sxs-lookup"><span data-stu-id="c9877-203">To find the order using a quantum computer, we can use the phase estimation algorithm applied to the following unitary operator $U_a$: $$ U_a\ket{x} \equiv \ket{(ax)\text{ mod }N} .$$ The eigenvectors of $U_a$ are for integer $s$ and $0\leq s \leq r - 1$, $$\ket{x_s} \equiv 1 / \sqrt{r} \sum\_{k=0}^{r-1} e^{\frac{-2\pi i sk}{r}} \ket{a^k\text{ mod }N},$$ are _eigenstates_ of $U_a$.</span></span>
<span data-ttu-id="c9877-204">$U _a $ eigenvalues a $ $ U \_ a \ket{x \_ s} = e ^ {2 \ PI i s/r} \ket{x \_ s}.</span><span class="sxs-lookup"><span data-stu-id="c9877-204">The eigenvalues of $U_a$ are $$ U\_a \ket{x\_s} = e^{2\pi i s / r} \ket{x\_s} .</span></span> $$

<span data-ttu-id="c9877-205">A fázis becslése így a eigenvalues $e ^ {2 \ PI i s/r} $ értéket jeleníti meg, amelyből a $r $ a $s/r $-ből származó [folyamatos frakciók](https://en.wikipedia.org/wiki/Continued_fraction) használatával hatékonyan megtanult.</span><span class="sxs-lookup"><span data-stu-id="c9877-205">Phase estimation thus outputs the eigenvalues $e^{2\pi i s / r}$ from which $r$ can be learned efficiently using [continued fractions](https://en.wikipedia.org/wiki/Continued_fraction) from $s / r$.</span></span>

<span data-ttu-id="c9877-206">A kvantum-időszak megállapításához használt áramköri diagram a következő:</span><span class="sxs-lookup"><span data-stu-id="c9877-206">The circuit diagram for quantum period finding is:</span></span>

![A kvantum-időszak megkeresésének áramköri diagramja](~/media/QPE.svg)

<span data-ttu-id="c9877-208">Itt $2n $ qubits inicializálása $ \ket {0} $-re, a $n $ qubits pedig a $ \ket $-re lett inicializálva {1} .</span><span class="sxs-lookup"><span data-stu-id="c9877-208">Here $2n$ qubits are initialized to $\ket{0}$ and $n$ qubits are initialized to $\ket{1}$.</span></span>
<span data-ttu-id="c9877-209">Az olvasónak újra lehet tudnia, hogy miért lett inicializálva a eigenstates a \ket $ értékre {1} .</span><span class="sxs-lookup"><span data-stu-id="c9877-209">The reader again may wonder why the quantum register to hold the eigenstates is initialized to $\ket{1}$.</span></span>
<span data-ttu-id="c9877-210">Mivel az egyik nem tudja, hogy a rendelés $r $, nem lehet ténylegesen előkészíteni a $ \ket{x_s} $ $ állapotot.</span><span class="sxs-lookup"><span data-stu-id="c9877-210">As one does not know the order $r$ in advance, we cannot actually prepare $\ket{x_s}$ states directly.</span></span>
<span data-ttu-id="c9877-211">Szerencsére kiderül, hogy a $1/\ SQRT {r} \sum \_ {s = 0} ^ {r-1} \ket{x \_ s} = \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="c9877-211">Luckily, it turns out that $1/\sqrt{r} \sum\_{s=0}^{r-1} \ket{x\_s} = \ket{1}$.</span></span>
<span data-ttu-id="c9877-212">Nem kell ténylegesen előkészíteni a $ \ket{x} $-t!</span><span class="sxs-lookup"><span data-stu-id="c9877-212">We don't need to actually prepare $\ket{x}$!</span></span>
<span data-ttu-id="c9877-213">Most már előkészítheti $n $ qubits kvantum-regisztrációját $ \ket {1} $ állapotban.</span><span class="sxs-lookup"><span data-stu-id="c9877-213">We can just prepare a quantum register of $n$ qubits in state $\ket{1}$.</span></span> 

<span data-ttu-id="c9877-214">Az áramkör tartalmazza a QFT és a több vezérelt kaput.</span><span class="sxs-lookup"><span data-stu-id="c9877-214">The circuit contains the QFT and several controlled gates.</span></span>
<span data-ttu-id="c9877-215">A QFT-kaput [korábban](xref:microsoft.quantum.libraries.standard.algorithms)ismertetjük.</span><span class="sxs-lookup"><span data-stu-id="c9877-215">The QFT gate has been described [previously](xref:microsoft.quantum.libraries.standard.algorithms).</span></span>
<span data-ttu-id="c9877-216">A vezérelt $U _a $ Gate Maps $ \ket{x} $ to $ \ket{(AX) \text{mod} N} $, ha a vezérlő qubit $ \ket {1} $, és Maps $ \ket{x} $ to $ \ket{x} $ máskülönben.</span><span class="sxs-lookup"><span data-stu-id="c9877-216">The controlled-$U_a$ gate maps $\ket{x}$ to $\ket{(ax)\text{ mod } N}$ if the control qubit is $\ket{1}$, and maps $\ket{x}$ to $\ket{x}$ otherwise.</span></span>

<span data-ttu-id="c9877-217">Ahhoz, hogy a $ (a ^ NX) \text{mod} N $-t lehessen elérni, egyszerűen alkalmazhatjuk a szabályozott $U _ {a ^ n} $-t, ahol a $a ^ n \text{mod} N $-t a kvantum-áramkörbe való csatlakoztatáshoz.</span><span class="sxs-lookup"><span data-stu-id="c9877-217">To achieve $(a^nx)\text{ mod } N$,  we can simply apply controlled-$U_{a^n}$, where we calculate $a^n \text{ mod } N$ classically to plug into the quantum circuit.</span></span>  
<span data-ttu-id="c9877-218">Az ilyen Moduláris aritmetika eléréséhez szükséges áramkörök leírását a [Quantum aritmetikai dokumentációja](./algorithms.md#arithmetic)tartalmazza, konkrétan a vezérelt $U \_ {a ^ i} $ műveletek megvalósításához moduláris hatványozására áramkörre van szükségünk.</span><span class="sxs-lookup"><span data-stu-id="c9877-218">The circuits to achieve such modular arithmetic have been described in the [quantum arithmetic documentation](./algorithms.md#arithmetic), specifically we require a modular exponentiation circuit to implement the controlled-$U\_{a^i}$ operations.</span></span>

<span data-ttu-id="c9877-219">Míg a fenti kör megfelel a [kvantum fázisok becslésének](xref:Microsoft.Quantum.Characterization.QuantumPhaseEstimation) , és explicit módon lehetővé teszi a megrendelés megtalálását, csökkentheti a szükséges qubits számát.</span><span class="sxs-lookup"><span data-stu-id="c9877-219">While the circuit above corresponds to [Quantum Phase Estimation](xref:Microsoft.Quantum.Characterization.QuantumPhaseEstimation) and explicitly enables order finding, we can reduce the number of qubits required.</span></span> <span data-ttu-id="c9877-220">A Beauregard módszerét követve megtekintheti a [arXiv: Quant-pH/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), illetve a Microsoft. Quantum. jellemzésben elérhető fázis-becslési rutinok egyikét.</span><span class="sxs-lookup"><span data-stu-id="c9877-220">We can either follow Beauregard's method for order finding as described [on Page 8 of arXiv:quant-ph/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), or use one of the phase estimation routines available in Microsoft.Quantum.Characterization.</span></span> <span data-ttu-id="c9877-221">A [robusztus fázis becslése](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation) például egy extra qubit is használ.</span><span class="sxs-lookup"><span data-stu-id="c9877-221">For example, [Robust Phase Estimation](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation) also uses one extra qubit.</span></span>

### <a name="factoring"></a><span data-ttu-id="c9877-222">Faktoring</span><span class="sxs-lookup"><span data-stu-id="c9877-222">Factoring</span></span> ###
<span data-ttu-id="c9877-223">A faktoring célja, hogy meghatározza a $N $ egész szám két fő tényezőjét, ahol a $N $ egy $n $ bites szám.</span><span class="sxs-lookup"><span data-stu-id="c9877-223">The goal of factoring is to determine the two prime factors of integer $N$, where $N$ is an $n$-bit number.</span></span>  
<span data-ttu-id="c9877-224">A faktoring az alábbiakban ismertetett lépésekből áll.</span><span class="sxs-lookup"><span data-stu-id="c9877-224">Factoring consists of the steps described below.</span></span> <span data-ttu-id="c9877-225">A lépések három részre oszlanak: a klasszikus előfeldolgozási rutin (1-4); egy kvantum-számítási rutin, amely megkeresi az $a \text{mod} N $ (5); valamint egy klasszikus utófeldolgozó rutin, amely a sorrendből származtatja a legfontosabb tényezőket (6-9).</span><span class="sxs-lookup"><span data-stu-id="c9877-225">The steps are split into three parts: a classical preprocessing routine (1-4); a quantum computing routine to find the order of $a \text{ mod } N$ (5); and a classical postprocessing routine to derive the prime factors from the order (6-9).</span></span>

<span data-ttu-id="c9877-226">A klasszikus előfeldolgozási rutin a következő lépésekből áll:</span><span class="sxs-lookup"><span data-stu-id="c9877-226">The classical preprocessing routine consists of the following steps:</span></span>
1. <span data-ttu-id="c9877-227">Ha a $N $ értéke páros, a $2 $ Prime faktort kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="c9877-227">If $N$ is even, return the prime factor $2$.</span></span>
2. <span data-ttu-id="c9877-228">Ha $N = p ^ q $ $p \geq1 $, $q \geq2 $, a Prime Factor $p $ értéket kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="c9877-228">If $N=p^q$ for $p\geq1$, $q\geq2$, return the prime factor $p$.</span></span>  <span data-ttu-id="c9877-229">Ezt a lépést klasszikusan hajtják végre.</span><span class="sxs-lookup"><span data-stu-id="c9877-229">This step is performed classically.</span></span>
3. <span data-ttu-id="c9877-230">Válasszon egy véletlenszerű számot $a $, például $1 < < N-$1.</span><span class="sxs-lookup"><span data-stu-id="c9877-230">Choose a random number $a$ such that $1 < a < N-1$.</span></span>
4. <span data-ttu-id="c9877-231">Ha a $ \text{GCD} (a, N) >$1, akkor a \text{GCD} (a, N) $ elsődleges tényezőt kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="c9877-231">If $\text{gcd}(a,N)>1$, return the prime factor $\text{gcd}(a,N)$.</span></span> <span data-ttu-id="c9877-232">Ezt a lépést a Euklidész algoritmusa alapján számítjuk ki.</span><span class="sxs-lookup"><span data-stu-id="c9877-232">This step is computed using Euclid's algorithm.</span></span>
<span data-ttu-id="c9877-233">Ha nem adtak vissza elsődleges tényezőt, folytassa a kvantum-rutin használatával:</span><span class="sxs-lookup"><span data-stu-id="c9877-233">If no prime factor has been returned, we proceed to the quantum routine:</span></span>
5. <span data-ttu-id="c9877-234">Hívja meg a kvantum-időszak megkeresésének algoritmusát, hogy kiszámítsa $r $ $a \text{mod} N $ értékének megrendelését.</span><span class="sxs-lookup"><span data-stu-id="c9877-234">Call the quantum period finding algorithm to calculate the order $r$ of $a \text{ mod } N$.</span></span> <span data-ttu-id="c9877-235">A legfontosabb tényezők megállapításához használja az $r $-t a klasszikus utófeldolgozó rutinban:</span><span class="sxs-lookup"><span data-stu-id="c9877-235">Use $r$ in the classical postprocessing routine to determine the prime factors:</span></span>
6. <span data-ttu-id="c9877-236">Ha $r $ páratlan, térjen vissza az előfeldolgozási lépéshez (3).</span><span class="sxs-lookup"><span data-stu-id="c9877-236">If $r$ is odd, go back to preprocessing step (3).</span></span>
7. <span data-ttu-id="c9877-237">Ha $r $ páros, és $a ^ {r/2} =-1 \ Text {mod} N $, térjen vissza az előfeldolgozási lépéshez (3).</span><span class="sxs-lookup"><span data-stu-id="c9877-237">If $r$ is even and $a^{r/2} = -1\text{ mod }N$, go back to preprocessing step (3).</span></span>
8. <span data-ttu-id="c9877-238">Ha a $ \text{GCD} (a ^ {r/2} + 1, N) $ egy nem triviális tényező a $N $ értéknél, a Return $ \text{GCD} (a ^ {r/2} + 1, N) $ értéket kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="c9877-238">If $\text{gcd}(a^{r/2}+1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}+1, N)$.</span></span>
9. <span data-ttu-id="c9877-239">Ha a $ \text{GCD} (a ^ {r/2}-1, N) $ nem triviális tényező a $N $ értéknél, a Return $ \text{GCD} (a ^ {r/2}-1, N) $ értéket kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="c9877-239">If $\text{gcd}(a^{r/2}-1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}-1, N)$.</span></span>


<span data-ttu-id="c9877-240">A faktoring algoritmus valószínűsége: úgy láthatja, hogy a $r $ értéke legalább az egyik fele lesz, és $a ^ {r/2} \neq-1 \text{mod} N $, ami egy elsődleges tényezőt eredményez.</span><span class="sxs-lookup"><span data-stu-id="c9877-240">The factoring algorithm is probabilistic: it can been shown that with probability at least one half that $r$ will be even and $a^{r/2} \neq -1 \text{ mod }N$, thus producing a prime factor.</span></span>  <span data-ttu-id="c9877-241">(További információért lásd a [rövid eredeti dokumentumát](https://doi.org/10.1109/SFCS.1994.365700) , vagy a [További információk](xref:microsoft.quantum.more-information)egyik *alapszintű Quantum Computing* -szövegét).</span><span class="sxs-lookup"><span data-stu-id="c9877-241">(See [Shor's original paper](https://doi.org/10.1109/SFCS.1994.365700) for details, or one of the *Basic quantum computing* texts in [For more information](xref:microsoft.quantum.more-information)).</span></span>
<span data-ttu-id="c9877-242">Ha a rendszer nem ad vissza elsődleges tényezőt, egyszerűen ismételje meg az algoritmust a következő lépésből: (1).</span><span class="sxs-lookup"><span data-stu-id="c9877-242">If a prime factor is not returned, then we simply repeat the algorithm from step (1).</span></span>  <span data-ttu-id="c9877-243">$N $ próbálkozás után a valószínűsége, hogy minden kísérlet meghiúsult, legfeljebb 2 ^ {-n} $.</span><span class="sxs-lookup"><span data-stu-id="c9877-243">After $n$ tries, the probability that every attempt has failed is at most $2^{-n}$.</span></span>
<span data-ttu-id="c9877-244">Így az algoritmus megismétlése után a sikert csak kis számú alkalommal lehet megerősíteni.</span><span class="sxs-lookup"><span data-stu-id="c9877-244">Thus after repeating the algorithm a small number of times success is virtually assured.</span></span>
