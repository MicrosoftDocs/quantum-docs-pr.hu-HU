---
title: 'Adatstruktúrák a Q# standard könyvtárakban'
description: 'Ismerje meg az adatstruktúrákat, az Oracle-ket és a dinamikus generátorokat a Microsoft Q# szabványos könyvtáraiban.'
author: QuantumWriter
uid: microsoft.quantum.libraries.data-structures
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- 'Q#'
- '$$v'
ms.openlocfilehash: c3ce5d531618c269d15be3e4eb58ecbb597a022c
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 10/27/2020
ms.locfileid: "92692230"
---
# <a name="data-structures-and-modeling"></a><span data-ttu-id="f12b9-103">Adatstruktúrák és-modellezés</span><span class="sxs-lookup"><span data-stu-id="f12b9-103">Data Structures and Modeling</span></span> #

## <a name="classical-data-structures"></a><span data-ttu-id="f12b9-104">Klasszikus adatstruktúrák</span><span class="sxs-lookup"><span data-stu-id="f12b9-104">Classical Data Structures</span></span> ##

<span data-ttu-id="f12b9-105">A kvantum-fogalmakat jelképező, felhasználó által definiált típusokkal együtt a Canon a Quantum Systems vezérléséhez használt klasszikus adatokkal kapcsolatos műveleteket, funkciókat és típusokat is biztosít.</span><span class="sxs-lookup"><span data-stu-id="f12b9-105">Along with user-defined types for representing quantum concepts, the canon also provides operations, functions, and types for working with classical data used in the control of quantum systems.</span></span>
<span data-ttu-id="f12b9-106">A <xref:Microsoft.Quantum.Arrays.Reversed> függvény például bemenetként fogad egy tömböt, és fordított sorrendben adja vissza ugyanazt a tömböt.</span><span class="sxs-lookup"><span data-stu-id="f12b9-106">For instance, the <xref:Microsoft.Quantum.Arrays.Reversed> function takes an array as input and returns the same array in reverse order.</span></span>
<span data-ttu-id="f12b9-107">Ezt követően felhasználható egy típusú tömbben `Qubit[]` , hogy ne kelljen felesleges $ \operatorname{swap} $ gateset alkalmaznia, ha az egész számok kvantum-ábrázolásai között vált.</span><span class="sxs-lookup"><span data-stu-id="f12b9-107">This can then be used on an array of type `Qubit[]` to avoid having to apply unnecessary $\operatorname{SWAP}$ gates when converting between quantum representations of integers.</span></span>
<span data-ttu-id="f12b9-108">Hasonlóképpen láttuk az előző szakaszban, hogy az űrlap típusa `(Int, Int -> T)` hasznos lehet a véletlen hozzáférésű gyűjtemények ábrázolásához, így a <xref:Microsoft.Quantum.Arrays.LookupFunction> függvény kényelmes módszert biztosít az ilyen típusú típusok tömbből való összeállításához.</span><span class="sxs-lookup"><span data-stu-id="f12b9-108">Similarly, we saw in the previous section that types of the form `(Int, Int -> T)` can be useful for representing random access collections, so the <xref:Microsoft.Quantum.Arrays.LookupFunction> function provides a convenient way of constructing such types from array types.</span></span>

### <a name="pairs"></a><span data-ttu-id="f12b9-109">Párok</span><span class="sxs-lookup"><span data-stu-id="f12b9-109">Pairs</span></span> ###

<span data-ttu-id="f12b9-110">A Canon támogatja a párok funkcionális stílusú jelölését, amely kiegészíti a rekordok való hozzáférését:</span><span class="sxs-lookup"><span data-stu-id="f12b9-110">The canon supports functional-style notation for pairs, complementing accessing tuples by deconstruction:</span></span>

```qsharp
let pair = (PauliZ, register); // type (Pauli, Qubit[])
ApplyToEach(H, Snd(pair)); // No need to deconstruct to access the register.
```

### <a name="arrays"></a><span data-ttu-id="f12b9-111">Tömbök</span><span class="sxs-lookup"><span data-stu-id="f12b9-111">Arrays</span></span> ###

<span data-ttu-id="f12b9-112">A Canon számos funkciót biztosít a tömbök manipulálására.</span><span class="sxs-lookup"><span data-stu-id="f12b9-112">The canon provides several functions for manipulating arrays.</span></span>
<span data-ttu-id="f12b9-113">Ezek a függvények Type-paraméteres, így bármilyen típusú tömbökkel használhatók Q# .</span><span class="sxs-lookup"><span data-stu-id="f12b9-113">These functions are type-parameterized, and thus can be used with arrays of any Q# type.</span></span>
<span data-ttu-id="f12b9-114">A <xref:Microsoft.Quantum.Arrays.Reversed> függvény például egy olyan új tömböt ad vissza, amelynek elemei fordított sorrendben vannak a bemenettől.</span><span class="sxs-lookup"><span data-stu-id="f12b9-114">For instance, the <xref:Microsoft.Quantum.Arrays.Reversed> function returns a new array whose elements are in reverse order from its input.</span></span>
<span data-ttu-id="f12b9-115">Ezzel megváltoztathatja, hogy a rendszer hogyan jelenítse meg a kvantum-regisztereket a műveletek meghívásakor:</span><span class="sxs-lookup"><span data-stu-id="f12b9-115">This can be used to change how a quantum register is represented when calling operations:</span></span>

```qsharp
let leRegister = LittleEndian(register);
// QFT expects a BigEndian, so we can reverse before calling.
QFT(BigEndian(Reversed(leRegister!)));
// This is how the LittleEndianAsBigEndian function is implemented:
QFT(LittleEndianAsBigEndian(leRegister));
```

<span data-ttu-id="f12b9-116">Hasonlóképpen, a <xref:Microsoft.Quantum.Arrays.Subarray> függvény használható a tömb elemeinek átrendezésére vagy az elemek részhalmazának elvégzésére:</span><span class="sxs-lookup"><span data-stu-id="f12b9-116">Similarly, the <xref:Microsoft.Quantum.Arrays.Subarray> function can be used to reorder or take subsets of the elements of an array:</span></span>

```qsharp
// Applies H to qubits 2 and 5.
ApplyToEach(H, Subarray([2, 5], register));
```

<span data-ttu-id="f12b9-117">A Flow Control szolgáltatással kombinálva a Array manipulációs függvények, például a (z) <xref:Microsoft.Quantum.Arrays.Zipped> hatékony módot biztosítanak a kvantum-programok kiírására:</span><span class="sxs-lookup"><span data-stu-id="f12b9-117">When combined with flow control, array manipulation functions such as <xref:Microsoft.Quantum.Arrays.Zipped> can provide a powerful way to express quantum programs:</span></span>

```qsharp
// Applies X₃ Y₁ Z₇ to a register of any size.
ApplyToEach(
    ApplyPauli(_, register),
    Map(
        EmbedPauli(_, _, Length(register)),
        Zipped([PauliX, PauliY, PauliZ], [3, 1, 7])
    )
);
```

## <a name="oracles"></a><span data-ttu-id="f12b9-118">Jóslatok</span><span class="sxs-lookup"><span data-stu-id="f12b9-118">Oracles</span></span> ##

<span data-ttu-id="f12b9-119">A [fázisok becslése](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) és az [amplitúdó-erősítési](https://en.wikipedia.org/wiki/Amplitude_amplification) irodalomban gyakran megjelenik egy Oracle koncepciója.</span><span class="sxs-lookup"><span data-stu-id="f12b9-119">In the [phase estimation](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) and [amplitude amplification](https://en.wikipedia.org/wiki/Amplitude_amplification) literature the concept of an oracle appears frequently.</span></span>
<span data-ttu-id="f12b9-120">Itt az Oracle kifejezés olyan tábla-kvantum-alrutint jelöl, amely qubits végez, és a választ fázisként adja vissza.</span><span class="sxs-lookup"><span data-stu-id="f12b9-120">Here the term oracle refers to a blackbox quantum subroutine that acts upon a set of qubits and returns the answer as a phase.</span></span>
<span data-ttu-id="f12b9-121">Ez az alrutin gyakran úgy gondolja, mint egy olyan kvantum-algoritmus bemenete, amely más paraméterek mellett is elfogadja az Oracle-t, és egy sor kvantum-műveletet alkalmaz, és a kvantum-alrutin hívását kezeli, mintha egy alapvető kapu lenne.</span><span class="sxs-lookup"><span data-stu-id="f12b9-121">This subroutine often can be thought of as an input to a quantum algorithm that accepts the oracle, in addition to some other parameters, and applies a series of quantum operations and treating a call to this quantum subroutine as if it were a fundamental gate.</span></span>
<span data-ttu-id="f12b9-122">Természetesen ahhoz, hogy a nagyobb algoritmus ténylegesen megvalósítható legyen, meg kell adni az Oracle-nek az alapvető kapuk konkrét összetételét, de az Oracle-t meghívó algoritmus megismeréséhez nincs szükség ilyen felbomlásra.</span><span class="sxs-lookup"><span data-stu-id="f12b9-122">Obviously, in order to actually implement the larger algorithm a concrete decomposition of the oracle into fundamental gates must be provided but such a decomposition is not needed in order to understand the algorithm that calls the oracle.</span></span>
<span data-ttu-id="f12b9-123">A-ben Q# Ez a művelet az első osztályú értékeket használja, így a műveletek átadhatók a kvantum-algoritmusok megvalósításához a fekete dobozos módon.</span><span class="sxs-lookup"><span data-stu-id="f12b9-123">In Q#, this abstraction is represented by using that operations are first-class values, such that operations can be passed to implementations of quantum algorithms in a black-box manner.</span></span>
<span data-ttu-id="f12b9-124">Emellett a felhasználó által definiált típusok a különböző Oracle-adatábrázolások típusos biztonságos módon történő címkézésére szolgálnak, így megnehezítik a különböző típusú fekete Box-műveletek véletlen kicsomagolását.</span><span class="sxs-lookup"><span data-stu-id="f12b9-124">Moreover, user-defined types are used to label the different oracle representations in a type-safe way, making it difficult to accidentally conflate different kinds of black box operations.</span></span>

<span data-ttu-id="f12b9-125">Az ilyen Oracle-k számos különböző kontextusban jelennek meg, beleértve az olyan híres példákat is, mint például a a a megtalált [Keresés](https://en.wikipedia.org/wiki/Grover%27s_algorithm) és a Quantum szimulációs algoritmusok.</span><span class="sxs-lookup"><span data-stu-id="f12b9-125">Such oracles appear in a number of different contexts, including famous examples such as [Grover's search](https://en.wikipedia.org/wiki/Grover%27s_algorithm) and quantum simulation algorithms.</span></span>
<span data-ttu-id="f12b9-126">Itt a csak két alkalmazáshoz szükséges Oracle-ket vesszük figyelembe: az amplitúdó erősítése és a fázisok becslése.</span><span class="sxs-lookup"><span data-stu-id="f12b9-126">Here we focus on the oracles needed for just two applications: amplitude amplification and phase estimation.</span></span>
<span data-ttu-id="f12b9-127">Első lépésként megbeszéljük az amplitúdó-bővítési Oracle-ket.</span><span class="sxs-lookup"><span data-stu-id="f12b9-127">We will first discuss amplitude amplification oracles before proceeding to phase estimation.</span></span>

### <a name="amplitude-amplification-oracles"></a><span data-ttu-id="f12b9-128">Amplitúdó-erősítés Oracles</span><span class="sxs-lookup"><span data-stu-id="f12b9-128">Amplitude Amplification Oracles</span></span> ###

<span data-ttu-id="f12b9-129">Az amplitúdó-erősítési algoritmus célja, hogy elvégezze a kezdeti állapot és a végső állapot közötti rotációs műveletet az állapot reflexiós sorrendjének alkalmazásával.</span><span class="sxs-lookup"><span data-stu-id="f12b9-129">The amplitude amplification algorithm aims to perform a rotation between an initial state and a final state by applying a sequence of reflections of the state.</span></span>
<span data-ttu-id="f12b9-130">Ahhoz, hogy az algoritmus működjön, mindkét állapotnak meg kell határoznia.</span><span class="sxs-lookup"><span data-stu-id="f12b9-130">In order for the algorithm to function, it needs a specification of both of these states.</span></span>
<span data-ttu-id="f12b9-131">Ezeket a specifikációkat két Oracle adja meg.</span><span class="sxs-lookup"><span data-stu-id="f12b9-131">These specifications are given by two oracles.</span></span>
<span data-ttu-id="f12b9-132">Ezek a jóslatok úgy működnek, hogy a bemeneteket két szóközre, egy "cél" alterületre és egy "kezdeti" alterületre bontja.</span><span class="sxs-lookup"><span data-stu-id="f12b9-132">These oracles work by breaking the inputs into two spaces, a "target" subspace and an "initial" subspace.</span></span>
<span data-ttu-id="f12b9-133">Az Oracle-k azonosítják az ilyen alterületeket, hasonlóan ahhoz, ahogyan a Pauli-operátorok két szóközt azonosítanak, egy $ \pm $1 fázist alkalmazva ezekre a szóközökre.</span><span class="sxs-lookup"><span data-stu-id="f12b9-133">The oracles identify such subspaces, similar to how Pauli operators identify two spaces, by applying a $\pm 1$ phase to these spaces.</span></span>
<span data-ttu-id="f12b9-134">A fő különbség az, hogy ezek a szóközök nem szükségesek az alkalmazásban.</span><span class="sxs-lookup"><span data-stu-id="f12b9-134">The main difference is that these spaces need not be half-spaces in this application.</span></span>
<span data-ttu-id="f12b9-135">Azt is vegye figyelembe, hogy ez a két alterület általában nem zárják ki egymást: mindkét szóköz tagjai lesznek.</span><span class="sxs-lookup"><span data-stu-id="f12b9-135">Also note that these two subspaces are not usually mutually exclusive: there will be vectors that are members of both spaces.</span></span>
<span data-ttu-id="f12b9-136">Ha ez nem igaz, az amplitúdó-erősítésnek nincs hatása, ezért a kezdeti alterületnek nem kell átfedésben lennie a cél alterülettel.</span><span class="sxs-lookup"><span data-stu-id="f12b9-136">If this were not true then amplitude amplification would have no effect so we need the initial subspace to have non-zero overlap with the target subspace.</span></span>

<span data-ttu-id="f12b9-137">A következő művelet végrehajtásához meg kell adni az első Oracle-t, amelyre az amplitúdó-erősítésre van szükségünk $P \_ $0.</span><span class="sxs-lookup"><span data-stu-id="f12b9-137">We will denote the first oracle that we need for amplitude amplification to be $P\_0$, defined to have the following action.</span></span>  <span data-ttu-id="f12b9-138">Minden, a "kezdeti" alterületen a $ \ket{x} $ értékkel rendelkező állapothoz $P \_ 0 \ket{x} =-\ket{x} $ és minden olyan állapothoz $ \ket{y} $, amely nem ebben az altérben van $P \_ 0 \ket{y} = \ket{y} $.</span><span class="sxs-lookup"><span data-stu-id="f12b9-138">For all states $\ket{x}$ in the "initial" subspace $P\_0 \ket{x} = -\ket{x}$ and for all states $\ket{y}$ that are not in this subspace we have $P\_0 \ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="f12b9-139">A célként megadott alterületet ($P _1 $) jelölő Oracle pontosan ugyanazt az űrlapot veszi fel.</span><span class="sxs-lookup"><span data-stu-id="f12b9-139">The oracle that marks the target subspace, $P_1$, takes exactly the same form.</span></span>
<span data-ttu-id="f12b9-140">Minden állapothoz $ \ket{x} $ a célként megadott alterületen (azaz minden olyan állapot esetében, amelynek a kimenetét szeretné kiadni), $P _1 \ ket {x} =-\ket{x} $.</span><span class="sxs-lookup"><span data-stu-id="f12b9-140">For all states $\ket{x}$ in the target subspace (i.e., for all states that you'd like the algorithm to output), $P_1\ket{x} = -\ket{x}$.</span></span>
<span data-ttu-id="f12b9-141">Hasonlóképpen, az összes olyan állam esetében, amely nem a \ket{y} $ $P _1 \ ket {y} = \ket{y} $.</span><span class="sxs-lookup"><span data-stu-id="f12b9-141">Similarly, for all states $\ket{y}$ that are not in the target subspace $P_1\ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="f12b9-142">Ezt a két reflexiót egyesítjük egy olyan operátor kialakításával, amely az amplitúdó erősítésének egyetlen lépését, $Q =-P_0 P_1 $ értéket adja meg, ahol a teljes mínusz jel csak az ellenőrzött alkalmazások esetében fontos.</span><span class="sxs-lookup"><span data-stu-id="f12b9-142">These two reflections are then combined to form an operator that enacts a single step of amplitude amplification, $Q = -P_0 P_1$, where the overall minus sign is only important to consider in controlled applications.</span></span>
<span data-ttu-id="f12b9-143">Az amplitúdó-erősítés ezután egy kezdeti állapotba kerül, amely a kezdeti alterületen található $ \ket{\psi} $, majd végrehajtja a $ \ket{\psi} \mapsto Q ^ m \ket{\psi} $ értéket.</span><span class="sxs-lookup"><span data-stu-id="f12b9-143">Amplitude amplification then proceeds by taking an initial state, $\ket{\psi}$ that is in the initial subspace and then performs $\ket{\psi} \mapsto Q^m \ket{\psi}$.</span></span>
<span data-ttu-id="f12b9-144">Az ilyen iterációk elvégzése garantálja, hogy ha az egyik kezdeti állapottal rendelkezik, amely átfedésben van a $ \sin ^ 2 (\theta) $ karakterrel a megjelölt területtel, akkor $m $ iteráció után az átfedés lesz $ \sin ^ 2 ([2m + 1] \theta) $.</span><span class="sxs-lookup"><span data-stu-id="f12b9-144">Performing such an iteration guarantees that if one starts with an initial state that has overlap $\sin^2(\theta)$ with the marked space then after $m$ iterations this overlap becomes $\sin^2([2m + 1] \theta)$.</span></span>
<span data-ttu-id="f12b9-145">Ezért általában úgy szeretnénk kiválasztani $m $-t, hogy legyen egy ingyenes paraméter, például $ [2m + 1] \theta = \ pi/2 $; azonban az ilyen merev megoldások nem annyira fontosak az amplitúdó-erősítés bizonyos formáinál, például a rögzített pont amplitúdójának erősítése.</span><span class="sxs-lookup"><span data-stu-id="f12b9-145">We therefore typically wish to choose $m$ to be a free parameter such that $[2m+1]\theta = \pi/2$; however, such rigid choices are not as important for some forms of amplitude amplification such as fixed point amplitude amplification.</span></span>
<span data-ttu-id="f12b9-146">Ez a folyamat lehetővé teszi, hogy egy olyan állapotot Készítsünk elő a megjelölt alterületen, amely a jelölési függvénynek és az állapot-előkészítési függvénynek csak egy szigorúan klasszikus eszközön való használata esetén lehetséges.</span><span class="sxs-lookup"><span data-stu-id="f12b9-146">This process allows us to prepare a state in the marked subspace using quadratically fewer queries to the marking function and the state preparation function than would be possible on a strictly classical device.</span></span>
<span data-ttu-id="f12b9-147">Ezért fontos, hogy az amplitúdó-erősítés a kvantum-számítástechnika számos alkalmazásának jelentős építőeleme.</span><span class="sxs-lookup"><span data-stu-id="f12b9-147">This is why amplitude amplification is a significant building block for many applications of quantum computing.</span></span>

<span data-ttu-id="f12b9-148">Az algoritmus használatának megismeréséhez hasznos lehet olyan példát biztosítani, amely az Oracle-ket is felépíti.</span><span class="sxs-lookup"><span data-stu-id="f12b9-148">In order to understand how to use the algorithm, it is useful to provide an example that gives a construction of the oracles.</span></span>  <span data-ttu-id="f12b9-149">Ebben a beállításban érdemes megfontolni a a kiinduló adatbázis-keresésekhez szükséges a a a a a</span><span class="sxs-lookup"><span data-stu-id="f12b9-149">Consider performing Grover's algorithm for database searches in this setting.</span></span>
<span data-ttu-id="f12b9-150">A a a \ket{+} ^ {\otimes n} = H ^ {\otimes n} \ket $ értéket az {0} egyik (potenciálisan) számos megjelölt állapotba alakítja a.</span><span class="sxs-lookup"><span data-stu-id="f12b9-150">In Grover's search the goal is to transform the state $\ket{+}^{\otimes n} = H^{\otimes n} \ket{0}$ into one of (potentially) many marked states.</span></span>
<span data-ttu-id="f12b9-151">A további egyszerűsítés érdekében nézzük meg azt az esetet, amikor az egyetlen megjelölt állapot $ \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="f12b9-151">To further simplify, let's just look at the case where the only marked state is $\ket{0}$.</span></span>
<span data-ttu-id="f12b9-152">Ezt követően két Oracle-t tervezünk: az egyiket, amely csak az $ \ket{+} ^ {\otimes n} $ kezdeti állapotot jelöli mínusz jellel, egy másikat, amely mínusz jellel jelöli meg a megjelölt állapotot ($ \ket {0} $).</span><span class="sxs-lookup"><span data-stu-id="f12b9-152">Then we have design two oracles: one that only marks the initial state $\ket{+}^{\otimes n}$ with a minus sign and another that marks the marked state $\ket{0}$ with a minus sign.</span></span>
<span data-ttu-id="f12b9-153">Az utóbbi kaput a következő eljárással lehet megvalósítani a Canon vezérlési folyamat műveleteinek használatával:</span><span class="sxs-lookup"><span data-stu-id="f12b9-153">The latter gate can be implemented using the following process operation, by using the control flow operations in the canon:</span></span>

```qsharp
operation ReflectAboutAllZeros(register : Qubit[]) : Unit 
is Adj + Ctl {

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);

    // Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.
    // This gate will lead to a sign flip if and only if every qubit is
    // $1$, which happens only if each of the qubits were $0$ before step 1.
    Controlled Z(Most(register), Tail(register));

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);
}
```

<span data-ttu-id="f12b9-154">Ez az Oracle a művelet egy speciális esete <xref:Microsoft.Quantum.Canon.RAll1> , amely lehetővé teszi, hogy tetszőleges fázisban forgatható legyen a $ \phi = \pi $ reflexiós eset helyett.</span><span class="sxs-lookup"><span data-stu-id="f12b9-154">This oracle is then a special case of the <xref:Microsoft.Quantum.Canon.RAll1> operation, which allows for rotating by an arbitrary phase instead of the reflection case $\phi = \pi$.</span></span>
<span data-ttu-id="f12b9-155">Ebben az esetben `RAll1` hasonló az <xref:Microsoft.Quantum.Intrinsic.R1> előlépési művelethez, mert az a $ \ket{11\cdots1} $-t a qubit állapot ($ \ket $) helyett elforgatja {1} .</span><span class="sxs-lookup"><span data-stu-id="f12b9-155">In this case, `RAll1` is similar to the <xref:Microsoft.Quantum.Intrinsic.R1> prelude operation, in that it rotates about $\ket{11\cdots1}$ instead of the single-qubit state $\ket{1}$.</span></span>

<span data-ttu-id="f12b9-156">A kezdeti alterületet jelölő Oracle hasonló módon építhető ki.</span><span class="sxs-lookup"><span data-stu-id="f12b9-156">The oracle that marks the initial subspace can be constructed similarly.</span></span>
<span data-ttu-id="f12b9-157">A pseudocode-ben:</span><span class="sxs-lookup"><span data-stu-id="f12b9-157">In pseudocode:</span></span>

1. <span data-ttu-id="f12b9-158">$H $ kaput alkalmazzon minden qubit.</span><span class="sxs-lookup"><span data-stu-id="f12b9-158">Apply $H$ gates to every qubit.</span></span>
2. <span data-ttu-id="f12b9-159">$X $ kaput alkalmazzon minden qubit.</span><span class="sxs-lookup"><span data-stu-id="f12b9-159">Apply $X$ gates to every qubit.</span></span>
3. <span data-ttu-id="f12b9-160">Alkalmazzon egy $n-$1 vezérelt $Z $-Gate értéket a $n ^ {\text{th}} $ qubit.</span><span class="sxs-lookup"><span data-stu-id="f12b9-160">Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.</span></span>
4. <span data-ttu-id="f12b9-161">$X $ kaput alkalmazzon minden qubit.</span><span class="sxs-lookup"><span data-stu-id="f12b9-161">Apply $X$ gates to every qubit.</span></span>
5. <span data-ttu-id="f12b9-162">$H $ kaput alkalmazzon minden qubit.</span><span class="sxs-lookup"><span data-stu-id="f12b9-162">Apply $H$ gates to every qubit.</span></span>

<span data-ttu-id="f12b9-163">Ezúttal <xref:Microsoft.Quantum.Canon.ApplyWith> a <xref:Microsoft.Quantum.Canon.RAll1> fent ismertetett művelettel együtt is bemutatjuk a használatát:</span><span class="sxs-lookup"><span data-stu-id="f12b9-163">This time, we also demonstrate using <xref:Microsoft.Quantum.Canon.ApplyWith> together with the <xref:Microsoft.Quantum.Canon.RAll1> operation discussed above:</span></span>

```qsharp
operation ReflectAboutInitial(register : Qubit[]) : Unit
is Adj + Ctl {
    ApplyWithCA(ApplyToEach(H, _), ApplyWith(ApplyToEach(X, _), RAll1(_, PI()), _), register);
}
```

<span data-ttu-id="f12b9-164">Ezt a két Oracle-t összekapcsoljuk a két állapot és a determinisztikus módon átalakítás $ \ket{+} ^ {\otimes n} $ és $ \ket $ közötti elforgatásával, {0} amely számos, a $ Hadamard ^ n} számú réteggel rendelkező \sqrt{2 $ (ie $m \propto \sqrt{2 ^ n} $) és a nagyjából 2 ^ n $ rétegek, amelyek szükségesek a nem determinisztikus módon előkészíteni a $ \ket {0} $ állapotot a kezdeti állapot előkészítésével és mérésével, amíg meg nem történik a $0 $ megfigyelve.</span><span class="sxs-lookup"><span data-stu-id="f12b9-164">We can then combine these two oracles together to rotate between the two states and deterministically transform $\ket{+}^{\otimes n}$ to $\ket{0}$ using a number of layers of Hadamard gates that is proportional to $\sqrt{2^n}$ (ie $m\propto \sqrt{2^n}$) versus the roughly $2^n$ layers that would be needed to non-deterministically prepare the $\ket{0}$ state by preparing and measuring the initial state until the outcome $0$ is observed.</span></span>

### <a name="phase-estimation-oracles"></a><span data-ttu-id="f12b9-165">Fázisok becslése Oracles</span><span class="sxs-lookup"><span data-stu-id="f12b9-165">Phase Estimation Oracles</span></span> ###

<span data-ttu-id="f12b9-166">A fázisok becsléséhez az Oracles valamivel több természetesebb.</span><span class="sxs-lookup"><span data-stu-id="f12b9-166">For phase estimation the oracles are somewhat more natural.</span></span>
<span data-ttu-id="f12b9-167">A fokozatos becslés célja, hogy olyan alrutint tervezzen, amely képes egy egységes mátrix eigenvalues való mintavételre.</span><span class="sxs-lookup"><span data-stu-id="f12b9-167">The aim in phase estimation is to design a subroutine that is capable of sampling from the eigenvalues of a unitary matrix.</span></span>
<span data-ttu-id="f12b9-168">Ez a módszer nem feltétlenül elengedhetetlen a Quantum szimulációban, mert a kémia és az anyagi tudományok számos fizikai problémája miatt ezek a eigenvalues a kvantum-rendszerek talajközeli energiáit biztosítják, amelyek értékes információkat biztosítanak az anyagok és a molekulák reagálási dinamikájának fázis-diagramjairól.</span><span class="sxs-lookup"><span data-stu-id="f12b9-168">This method is indispensable in quantum simulation because for many physical problems in chemistry and material science these eigenvalues give the ground-state energies of quantum systems which provides us valuable information about the phase diagrams of materials and reaction dynamics for molecules.</span></span>
<span data-ttu-id="f12b9-169">A fázisok becslésének minden íz-bemenetének egységesnek kell lennie.</span><span class="sxs-lookup"><span data-stu-id="f12b9-169">Every flavor of phase estimation needs an input unitary.</span></span>
<span data-ttu-id="f12b9-170">Ez az egységes szolgáltatás a két Oracle-típus egyikének megfelelően van leírva.</span><span class="sxs-lookup"><span data-stu-id="f12b9-170">This unitary is customarily described by one of two types of oracles.</span></span>

> [!TIP]
> <span data-ttu-id="f12b9-171">Az alábbiakban ismertetett Oracle-típusok mindegyike szerepel a mintákban.</span><span class="sxs-lookup"><span data-stu-id="f12b9-171">Both of the oracle types described below are covered in the samples.</span></span>
> <span data-ttu-id="f12b9-172">Ha többet szeretne megtudni a folyamatos lekérdezési Oracle-ról, tekintse meg a [ **PhaseEstimation** mintát](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="f12b9-172">To learn more about continuous query oracles, please see the [**PhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation).</span></span>
> <span data-ttu-id="f12b9-173">Ha többet szeretne megtudni a diszkrét lekérdezési Oracle-ról, tekintse meg a [ **IsingPhaseEstimation** mintát](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="f12b9-173">To learn more about discrete query oracles, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>

<span data-ttu-id="f12b9-174">Az Oracle első típusa, amely egy különálló lekérdezési Oracle-t hív meg, és a felhasználó által definiált típusnak felel meg <xref:Microsoft.Quantum.Oracles.DiscreteOracle> , egyszerűen magában foglal egy egységes mátrixot.</span><span class="sxs-lookup"><span data-stu-id="f12b9-174">The first type of oracle, which we call a discrete query oracle and represent with the user-defined type <xref:Microsoft.Quantum.Oracles.DiscreteOracle>, simply involves a unitary matrix.</span></span>
<span data-ttu-id="f12b9-175">Ha $U $ az az egységes, amelynek a eigenvalues szeretnénk megbecsülni, akkor az Oracle for $U $ egyszerűen egy olyan alrutinra vonatkozik, amely megvalósítja a $U $-t.</span><span class="sxs-lookup"><span data-stu-id="f12b9-175">If $U$ is the unitary whose eigenvalues we wish to estimate then the oracle for $U$ is simply a stand-in for a subroutine that implements $U$.</span></span>
<span data-ttu-id="f12b9-176">Előfordulhat például, hogy az $U $ értéket kell megadnia az amplitúdó-becsléshez a fentiekben megadott Oracle $Q $ értékre.</span><span class="sxs-lookup"><span data-stu-id="f12b9-176">For example, one could take $U$ to be the oracle $Q$ defined above for amplitude estimation.</span></span>
<span data-ttu-id="f12b9-177">A mátrix eigenvalues felhasználható a kezdeti és a megcélzott állapotok, a $ \sin ^ 2 (\theta) $ közötti átfedés megbecslésére, amely a másodfokú módon kevesebb mintát használ, mint amennyit egyébként kellene.</span><span class="sxs-lookup"><span data-stu-id="f12b9-177">The eigenvalues of this matrix can be used to estimate the overlap between the initial and target states, $\sin^2(\theta)$, using quadratically fewer samples than one would need otherwise.</span></span>
<span data-ttu-id="f12b9-178">Ez a szakasz becslésének alkalmazásával keresi a következőt: a ($Q $, az amplitúdó-becslések monikere.</span><span class="sxs-lookup"><span data-stu-id="f12b9-178">This earns the application of phase estimation using the Grover oracle $Q$ as input the moniker of amplitude estimation.</span></span>
<span data-ttu-id="f12b9-179">Egy másik gyakori alkalmazás, amely a kvantum-metrológiaban széles körben használatos, egy kis elforgatási szöget eredményez.</span><span class="sxs-lookup"><span data-stu-id="f12b9-179">Another common application, widely used in quantum metrology, involves estimating a small rotation angle.</span></span>
<span data-ttu-id="f12b9-180">Más szóval a $ \theta $ értéket szeretnénk megbecsülni egy ismeretlen rotációs kapun $R _z (\theta) $ formában.</span><span class="sxs-lookup"><span data-stu-id="f12b9-180">In other words, we wish to estimate $\theta$ for an unknown rotation gate of the form $R_z(\theta)$.</span></span>
<span data-ttu-id="f12b9-181">Ilyen esetekben az az alrutin, amelyet a \theta $ értékkel való együttműködéshez szeretne használni a kapun, $ $ \begin{align} U & = R_z (\theta) \\ \\ & = \begin{bmatrix} e ^ {-i \theta/2} & 0 \\ \\ 0 & e ^ {i \ THÉTA/2} \end{bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="f12b9-181">In such cases, the subroutine that we would interact with in order to learn this fixed value of $\theta$ for the gate is $$ \begin{align} U & = R_z(\theta) \\\\ & = \begin{bmatrix} e^{-i \theta / 2} & 0 \\\\ 0 & e^{i\theta/2} \end{bmatrix}.</span></span>
<span data-ttu-id="f12b9-182">\end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="f12b9-182">\end{align} $$</span></span>

<span data-ttu-id="f12b9-183">A fázisok becslésében használt második Oracle a folyamatos lekérdezési Oracle, amelyet a típus képvisel <xref:Microsoft.Quantum.Oracles.ContinuousOracle> .</span><span class="sxs-lookup"><span data-stu-id="f12b9-183">The second type of oracle used in phase estimation is the continuous query oracle, represented by the <xref:Microsoft.Quantum.Oracles.ContinuousOracle> type.</span></span>
<span data-ttu-id="f12b9-184">A folyamatos lekérdezési Oracle a fázis becsléséhez $U (t) $, ahol $t $ egy klasszikusan ismert valós szám.</span><span class="sxs-lookup"><span data-stu-id="f12b9-184">A continuous query oracle for phase estimation takes the form $U(t)$ where $t$ is a classically known real number.</span></span>
<span data-ttu-id="f12b9-185">Ha hagyjuk, hogy a $U $ legyen rögzített, akkor a folyamatos lekérdezési Oracle az űrlapot $U (t) = U ^ t $ értéket veszi fel.</span><span class="sxs-lookup"><span data-stu-id="f12b9-185">If we let $U$ be a fixed unitary then the continuous query oracle takes the form $U(t) = U^t$.</span></span>
<span data-ttu-id="f12b9-186">Ez lehetővé teszi, hogy lekérdezzen egy olyan mátrixot, mint például a $ \sqrt{U} $, amely nem valósítható meg közvetlenül a diszkrét lekérdezési modellben.</span><span class="sxs-lookup"><span data-stu-id="f12b9-186">This allows us to query matrices such as $\sqrt{U}$, which could not be implemented directly in the discrete query model.</span></span>

<span data-ttu-id="f12b9-187">Ez a típusú Oracle akkor hasznos, ha nem egy adott egységes adattípust végez, hanem szeretné megismerni az egységes szolgáltatás létrehozójának tulajdonságait.</span><span class="sxs-lookup"><span data-stu-id="f12b9-187">This type of oracle is valuable when you're not probing a particular unitary, but rather wish to learn the properties of the generator of the unitary.</span></span>
<span data-ttu-id="f12b9-188">A dinamikus kvantum-szimulációban például az a cél, hogy olyan kvantum-áramköröket dolgozzon ki, amelyek szorosan megközelítik $U (t) = e ^ {-i H t} $-t a Hermitian-mátrixhoz $H $ és az Evolution Time $t $ értéknél.</span><span class="sxs-lookup"><span data-stu-id="f12b9-188">For example, in dynamical quantum simulation the goal is to devise quantum circuits that closely approximate $U(t)=e^{-i H t}$ for a Hermitian matrix $H$ and evolution time $t$.</span></span>
<span data-ttu-id="f12b9-189">$U (t) $ eigenvalues közvetlenül kapcsolódik a $H $ eigenvalues.</span><span class="sxs-lookup"><span data-stu-id="f12b9-189">The eigenvalues of $U(t)$ are directly related to the eigenvalues of $H$.</span></span>
<span data-ttu-id="f12b9-190">Ezt úgy tekintheti meg, hogy $H $: $H \ket{E} = E\ket {E} $ eigenvector, így könnyen látható, hogy milyen a mátrix exponenciálisa, hogy $U (t) \ket{E} = e ^ {i\phi} \ ket {E} = e ^ {-iEt} \ket{E} $.</span><span class="sxs-lookup"><span data-stu-id="f12b9-190">To see this, consider an eigenvector of $H$: $H \ket{E} = E\ket{E}$ then it is easy to see from the power-series definition of the matrix exponential that $U(t) \ket{E} = e^{i\phi}\ket{E}= e^{-iEt}\ket{E}$.</span></span>
<span data-ttu-id="f12b9-191">Így a $U (t) $ eigenphase becslése megadja a sajátérték $E $ értéket, feltételezve, hogy a eigenvector $ \ket{E} $ bemenet bekerül a fázis-becslési algoritmusba.</span><span class="sxs-lookup"><span data-stu-id="f12b9-191">Thus estimating the eigenphase of $U(t)$ gives the eigenvalue $E$ assuming the eigenvector $\ket{E}$ is input into the phase estimation algorithm.</span></span>
<span data-ttu-id="f12b9-192">Ebben az esetben azonban a $t $ érték megadható a felhasználó saját belátása szerint, mert az $t $ sajátérték $E $ értékkel rendelkező $E =-\ Phi/t $ használatával egyedileg visszaállíthatók.</span><span class="sxs-lookup"><span data-stu-id="f12b9-192">However, in this case the value $t$ can be chosen at the user's discretion since for any sufficiently small value of $t$ the eigenvalue $E$ can be uniquely inverted through $E=-\phi/t$.</span></span>
<span data-ttu-id="f12b9-193">Mivel a kvantum-szimulációs módszerek lehetővé teszik a töredékes evolúció végrehajtását, ez a fázis-értékelési algoritmusok további szabadságot biztosítanak az egységes állapot lekérdezése során, különösen, ha a diszkrét lekérdezési modell lehetővé teszi, hogy csak a unitaries $U ^ j $ értéket alkalmazza a $t $U $j rendszer</span><span class="sxs-lookup"><span data-stu-id="f12b9-193">Since quantum simulation methods provide the ability to perform a fractional evolution, this grants phase estimation algorithms an additional freedom when querying the unitary, specifically while the discrete query model allows only unitaries of the form $U^j$ to applied for integer $j$ the continuous query oracle allows us to approximate unitaries of the form $U^t$ for any real valued $t$.</span></span>
<span data-ttu-id="f12b9-194">Ez azért fontos, hogy a fázis-becslési algoritmusok alapján minden utolsó uncia hatékonyságot megnyomjon, mert lehetővé teszi számunkra, hogy pontosan olyan kísérletet válasszon, amely a legtöbbet a $E $; míg a különálló lekérdezéseken alapuló metódusoknak a kiegyezéssel kell rendelkezniük az algoritmusban található lekérdezések legjobb egész számának kiválasztásával.</span><span class="sxs-lookup"><span data-stu-id="f12b9-194">This is important to squeeze every last ounce of efficiency out of phase estimation algorithms because it allows us to choose precisely the experiment that would provide the most information about $E$; whereas methods based on discrete queries must make do with compromising by choosing the best integer number of queries in the algorithm.</span></span>

<span data-ttu-id="f12b9-195">Ennek konkrét példája, ha nem a kapu elforgatási szögét, hanem egy forgó kvantum-rendszer feldolgozási gyakoriságát kívánja megbecsülni.</span><span class="sxs-lookup"><span data-stu-id="f12b9-195">As a concrete example of this, consider the problem of estimating not the rotation angle of a gate but the procession frequency of a rotating quantum system.</span></span>
<span data-ttu-id="f12b9-196">Az ilyen kvantum-dinamika leírása $U (t) = R_z (2 \ Omega t) $ az Evolution Time $t $ és a $ \omega $ ismeretlen gyakorisággal.</span><span class="sxs-lookup"><span data-stu-id="f12b9-196">The unitary that describes such quantum dynamics is $U(t)=R_z(2\omega t)$ for evolution time $t$ and unknown frequency $\omega$.</span></span>
<span data-ttu-id="f12b9-197">Ebben a kontextusban a $U (t) $ értéket szimulálhatja bármely $t $-hez egyetlen $R _z $ Gate használatával, és így nem kell korlátoznia magunkat arra, hogy csak a különálló lekérdezésekre korlátozódjon.</span><span class="sxs-lookup"><span data-stu-id="f12b9-197">In this context, we can simulate $U(t)$ for any $t$ using a single $R_z$ gate and as such do not need to restrict ourselves to only discrete queries to the unitary.</span></span>
<span data-ttu-id="f12b9-198">Az ilyen folyamatos modell azt a tulajdonságot is megtudhatja, hogy a $2 \ PI $-nál nagyobb frekvenciákon a folyamatos lekérdezéseket használó fázis-becslési folyamatokból megtudhatja, hogy milyen fázis-információk láthatók a logaritmus-függvény elágazásával, a $t $ nem arányos értékeit érintő kísérletek eredményeiből.</span><span class="sxs-lookup"><span data-stu-id="f12b9-198">Such a continuous model also has the property that frequencies greater than $2\pi$ can be learned from phase estimation processes that use continuous queries because phase information that would otherwise be masked by the branch-cuts of the logarithm function can be revealed from the results of experiments performed on non-commensurate values of $t$.</span></span>
<span data-ttu-id="f12b9-199">Így olyan problémákhoz, mint például az Oracle fázis-becsléshez kapcsolódó folyamatos lekérdezési modellek, nem csupán megfelelőek, de a diszkrét lekérdezési modell esetében is előnyösek.</span><span class="sxs-lookup"><span data-stu-id="f12b9-199">Thus for problems such as this continuous query models for the phase estimation oracle are not only appropriate but are also preferable to the discrete query model.</span></span>
<span data-ttu-id="f12b9-200">Emiatt a Q# lekérdezések mindkét formájához van funkció, és a felhasználónak el kell döntenie, hogy egy fázis-becslési algoritmust válasszon az igényeinek megfelelően, valamint a rendelkezésre álló Oracle típusát.</span><span class="sxs-lookup"><span data-stu-id="f12b9-200">For this reason Q# has functionality for both forms of queries and leave it to the user to decide upon a phase estimation algorithm to fit their needs and the type of oracle that is available.</span></span>

## <a name="dynamical-generator-modeling"></a><span data-ttu-id="f12b9-201">Dinamikus generátor modellezése</span><span class="sxs-lookup"><span data-stu-id="f12b9-201">Dynamical Generator Modeling</span></span> ##

<span data-ttu-id="f12b9-202">A Time-Evolution generátorai ismertetik az állapotok időbeli alakulását.</span><span class="sxs-lookup"><span data-stu-id="f12b9-202">Generators of time-evolution describe how states evolve through time.</span></span> <span data-ttu-id="f12b9-203">Például a $ \ket{\psi} $ kvantum-állapot dinamikáját a következő Schrödinger-egyenlet szabályozza: $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = H \ket{\psi (t)}, \end{align} $ $ Hermitian-mátrixmal $H $, amely a Hamilton néven is ismert.</span><span class="sxs-lookup"><span data-stu-id="f12b9-203">For instance, the dynamics of a quantum state $\ket{\psi}$ is governed by the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ with a Hermitian matrix $H$, known as the Hamiltonian, as the generator of motion.</span></span> <span data-ttu-id="f12b9-204">Adott kezdeti állapot: $ \ket{\psi (0)} $ $t = $0, a formális megoldás erre az egyenletre $t $ időpontban is, elvileg a $ $ \begin{align} \ket{\psi (t)} = U (t) \ket{\psi (0)}, \end{align} $ $, ahol a mátrix exponenciális $U (t) = e ^ {-i H t} $-t nevezzük az egységes idő-Evolution operátornak.</span><span class="sxs-lookup"><span data-stu-id="f12b9-204">Given an initial state $\ket{\psi(0)}$ at time $t=0$, the formal solution to this equation at time $t$ may be, in principle, written $$ \begin{align} \ket{\psi(t)} = U(t)\ket{\psi(0)}, \end{align} $$ where the matrix exponential $U(t)=e^{-i H t}$ is known as the unitary time-evolution operator.</span></span> <span data-ttu-id="f12b9-205">Bár az alábbi űrlap-generátorokra koncentrálunk, Kiemeljük, hogy a koncepció szélesebb körben, például a nyílt kvantum-rendszerek szimulációján vagy az absztrakt különbözeti egyenletek esetében.</span><span class="sxs-lookup"><span data-stu-id="f12b9-205">Though we focus on generators of this form in the following, we emphasize that the concept applies more broadly, such as to the simulation of open quantum systems, or to more abstract differential equations.</span></span>

<span data-ttu-id="f12b9-206">A dinamikus szimuláció elsődleges célja az, hogy az idő-evolúciós operátort egy kvantum-számítógép qubits kódolva hajtsa végre.</span><span class="sxs-lookup"><span data-stu-id="f12b9-206">A primary goal of dynamical simulation is to implement the time-evolution operator on some quantum state encoded in qubits of a quantum computer.</span></span>  <span data-ttu-id="f12b9-207">Sok esetben előfordulhat, hogy a Hamilton néhány $d $ egyszerűbb kifejezésből álló összegre van bontva</span><span class="sxs-lookup"><span data-stu-id="f12b9-207">In many cases, the Hamiltonian may be broken into a sum of some $d$ simpler terms</span></span>

<span data-ttu-id="f12b9-208">$ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j, \end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="f12b9-208">$$ \begin{align} H & = \sum^{d-1}_{j=0} H_j, \end{align} $$</span></span>

<span data-ttu-id="f12b9-209">a kvantum-számítógépeken egyszerűen megvalósítható az egyes kifejezések időbeli alakulása.</span><span class="sxs-lookup"><span data-stu-id="f12b9-209">where time-evolution by each term alone is easy to implement on a quantum computer.</span></span> <span data-ttu-id="f12b9-210">Ha például $H _j $ egy Pauli $X _1X_2 $ operátor, amely a qubit-regisztráció 1. és 2. részében tevékenykedik `qubits` , a Time-Evolutiont a $t $-ig bármikor megvalósíthatja a művelet meghívásával `Exp([PauliX,PauliX], t, qubits[1..2])` , amely aláírást tartalmaz `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="f12b9-210">For instance, if $H_j$ is a Pauli $X_1X_2$ operator acting on the 1st and 2nd elements of the qubit register `qubits`, time-evolution by it for any time $t$ may be implemented simply by calling the operation `Exp([PauliX,PauliX], t, qubits[1..2])`, which has signature `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`.</span></span> <span data-ttu-id="f12b9-211">Ahogy az a Hamilton szimulációban is szerepel, az egyik megoldás, hogy az $H $ értékkel közelítse meg az időbeli alakulást az egyszerűbb műveletek sorozatával.</span><span class="sxs-lookup"><span data-stu-id="f12b9-211">As discussed later in Hamiltonian Simulation, one solution then is to approximate time-evolution by $H$ with a sequence of simpler operations</span></span>

<span data-ttu-id="f12b9-212">$ $ \begin{align} U (t) & = \left (e ^ {-iH \_ 0 t/r} e ^ {-IH \_ 1 t/r} \cdots e ^ {-IH \_ {d-1} t/r} \right) ^ {r} + \mathcal{O} (d ^ 2 \ max_j \\ | H \_ j \\ | ^ 2 t ^ 2/r), \end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="f12b9-212">$$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j \\|H\_j\\|^2 t^2/r), \end{align} $$</span></span>

<span data-ttu-id="f12b9-213">ahol az egész szám $r > $0 a közelítési hibát vezérli.</span><span class="sxs-lookup"><span data-stu-id="f12b9-213">where the integer $r > 0$ controls the approximation error.</span></span>

<span data-ttu-id="f12b9-214">A dinamikus generátor modellező könyvtára keretet biztosít a bonyolult generátorok szisztematikus kódolásához az egyszerűbb generátorok szempontjából.</span><span class="sxs-lookup"><span data-stu-id="f12b9-214">The dynamical generator modeling library provides a framework for systematically encoding complicated generators in terms of simpler generators.</span></span> <span data-ttu-id="f12b9-215">Ezt a leírást később átadhatják a szimulációs függvénytárnak, amely egy tetszőleges szimulációs algoritmussal valósítja meg a Time-Evolutiont, számos részletet pedig automatikusan elintéz.</span><span class="sxs-lookup"><span data-stu-id="f12b9-215">Such a description may then be passed to, say, the simulation library to implement time-evolution by a simulation algorithm of choice, with many details automatically taken care of.</span></span>

> [!TIP]
> <span data-ttu-id="f12b9-216">Az alább ismertetett dinamikus létrehozó függvénytárat a minták tartalmazzák.</span><span class="sxs-lookup"><span data-stu-id="f12b9-216">The dynamical generator library described below is covered in the samples.</span></span> <span data-ttu-id="f12b9-217">A Ising modellen alapuló példáért tekintse meg a [ **IsingGenerators** mintát](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/generators).</span><span class="sxs-lookup"><span data-stu-id="f12b9-217">For an example based on the Ising model, please see the [**IsingGenerators** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/generators).</span></span>
> <span data-ttu-id="f12b9-218">A molekuláris hidrogénen alapuló példákért tekintse meg a [**H2SimulationCmdLine**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) és a [**H2SimulationGUI**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/gui) mintákat.</span><span class="sxs-lookup"><span data-stu-id="f12b9-218">For an example based on molecular Hydrogen, please see the [**H2SimulationCmdLine**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) and [**H2SimulationGUI**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/gui) samples.</span></span>

### <a name="complete-description-of-a-generator"></a><span data-ttu-id="f12b9-219">Generátor leírásának teljes leírása</span><span class="sxs-lookup"><span data-stu-id="f12b9-219">Complete Description of a Generator</span></span> ###

<span data-ttu-id="f12b9-220">A legfelső szinten a Hamilton teljes leírása szerepel a `EvolutionGenerator` felhasználó által definiált típusban, amely két összetevőből áll:</span><span class="sxs-lookup"><span data-stu-id="f12b9-220">At the top level, a complete description of a Hamiltonian is contained in the `EvolutionGenerator` user-defined type which has two components.:</span></span>

```qsharp
newtype EvolutionGenerator = (EvolutionSet, GeneratorSystem);
```

<span data-ttu-id="f12b9-221">A `GeneratorSystem` felhasználó által definiált típus a Hamilton klasszikus leírása.</span><span class="sxs-lookup"><span data-stu-id="f12b9-221">The `GeneratorSystem` user-defined type is a classical description of the Hamiltonian.</span></span>

```qsharp
newtype GeneratorSystem = (Int, (Int -> GeneratorIndex));
```

<span data-ttu-id="f12b9-222">A rekord első eleme `Int` tárolja a $d $ értéket a Hamilton, a második elem `(Int -> GeneratorIndex)` pedig egy függvény, amely egy egész indexet képez le \{ 0, 1,..., d-1 \} $ értékről egy `GeneratorIndex` felhasználó által definiált típusra, amely egyedileg azonosítja az egyes primitív kifejezéseket a Hamilton.</span><span class="sxs-lookup"><span data-stu-id="f12b9-222">The first element `Int` of the tuple stores the number of terms $d$ in the Hamiltonian, and the second element `(Int -> GeneratorIndex)` is a function that maps an integer index in $\{0,1,...,d-1\}$ to a `GeneratorIndex` user-defined type which uniquely identifies each primitive term in the Hamiltonian.</span></span> <span data-ttu-id="f12b9-223">Vegye figyelembe, hogy a Hamilton lévő feltételek gyűjteményének a tömb helyett függvényként való kifejezése `GeneratorIndex[]` lehetővé teszi az on-fly számítást, `GeneratorIndex` amely különösen akkor hasznos, ha a Hamiltonians nagy számú kifejezéssel van ellátva.</span><span class="sxs-lookup"><span data-stu-id="f12b9-223">Note that by expressing the collection of terms in the Hamiltonian as a function rather than as an array `GeneratorIndex[]`, this allows for on-the-fly computation of the `GeneratorIndex` which is especially useful when describing Hamiltonians with a large number of terms.</span></span>

<span data-ttu-id="f12b9-224">Alapvetően nem határozunk meg olyan konvenciót, amely alapján a könnyen szimulálható, hogy milyen primitív feltételekkel rendelkezik `GeneratorIndex` .</span><span class="sxs-lookup"><span data-stu-id="f12b9-224">Crucially, we do not impose a convention on what primitive terms identified by the `GeneratorIndex` are easy-to-simulate.</span></span> <span data-ttu-id="f12b9-225">Előfordulhat például, hogy az egyszerű feltételek a fentiekben említettek szerint Pauli-operátorok, de a kvantum-kémia szimulációjában gyakran használt megsemmisítési és Fermionic is lehetnek.</span><span class="sxs-lookup"><span data-stu-id="f12b9-225">For instance, primitive terms could be Pauli operators as discussed above, but they could also be Fermionic annihilation and creation operators commonly used in quantum chemistry simulation.</span></span> <span data-ttu-id="f12b9-226">Önmagában a értelmetlen, `GeneratorIndex` mert nem írja le, hogy az adott kifejezés alapján hogyan alakulhat ki az idő – az evolúció a kvantum-áramkörként.</span><span class="sxs-lookup"><span data-stu-id="f12b9-226">By itself, a `GeneratorIndex` is meaningless as it does not describe how time-evolution by the term it points to may be implemented as a quantum circuit.</span></span>

<span data-ttu-id="f12b9-227">Ezt úgy oldja meg, hogy egy `EvolutionSet` felhasználó által definiált típust határoz meg, amely egy bizonyos Canonical-készletből leképezett leképezést végez, `GeneratorIndex` egy egységes operátorra, a `EvolutionUnitary` -ra, amely kvantum-áramkörként van kifejezve.</span><span class="sxs-lookup"><span data-stu-id="f12b9-227">This is resolved by specifying an `EvolutionSet` user-defined type that maps any `GeneratorIndex`, drawn from some canonical set, to a unitary operator, the `EvolutionUnitary`, expressed as a quantum circuit.</span></span> <span data-ttu-id="f12b9-228">A `EvolutionSet` meghatározza, hogy a hogyan `GeneratorIndex` legyen strukturálva, és meghatározza a lehetséges készletet is `GeneratorIndex` .</span><span class="sxs-lookup"><span data-stu-id="f12b9-228">The `EvolutionSet` defines the convention of how a `GeneratorIndex` is structured, and also defines the set of possible `GeneratorIndex`.</span></span>

```qsharp
newtype EvolutionSet = (GeneratorIndex -> EvolutionUnitary);
```

### <a name="pauli-operator-generators"></a><span data-ttu-id="f12b9-229">Pauli-kezelő generátorok</span><span class="sxs-lookup"><span data-stu-id="f12b9-229">Pauli Operator Generators</span></span> ###

<span data-ttu-id="f12b9-230">A generátorok konkrét és hasznos példája olyan Hamiltonians, amely a Pauli-operátorok összessége, amelyek mindegyike valószínűleg eltérő együtthatóval rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="f12b9-230">A concrete and useful example of generators are Hamiltonians that are a sum of Pauli operators, each possibly with a different coefficient.</span></span>
<span data-ttu-id="f12b9-231">$ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} a_j H_j, \end{align} $ $, ahol minden $ \hat H_j $ a Pauli csoportból lett kirajzolva.</span><span class="sxs-lookup"><span data-stu-id="f12b9-231">$$ \begin{align} H & = \sum^{d-1}_{j=0} a_j H_j, \end{align} $$ where each $\hat H_j$ is now drawn from the Pauli group.</span></span> <span data-ttu-id="f12b9-232">Ilyen rendszerek esetén olyan `PauliEvolutionSet()` típusú típust biztosítunk, `EvolutionSet` amely meghatározza a Pauli-csoport egy elemének, valamint egy együttható azonosítására szolgáló konvenciót `GeneratorIndex` , amely a következő aláírással rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="f12b9-232">For such systems, we provide the `PauliEvolutionSet()` of type `EvolutionSet` that defines a convention for how an element of the Pauli group and a coefficient may be identified by a `GeneratorIndex`, which has the following signature.</span></span>

```qsharp
newtype GeneratorIndex = ((Int[], Double[]), Int[]);
```

<span data-ttu-id="f12b9-233">A kódolásban az első paraméter `Int[]` egy Pauli-karakterláncot határoz meg, ahol a $ \Hat I\rightarrow $0, a $ \Hat X\rightarrow $1, a $ \Hat Y\rightarrow $2 és a $ \Hat Z\rightarrow $3.</span><span class="sxs-lookup"><span data-stu-id="f12b9-233">In our encoding, the first parameter `Int[]` specifies a Pauli string, where $\hat I\rightarrow 0$, $\hat X\rightarrow 1$, $\hat Y\rightarrow 2$, and $\hat Z\rightarrow 3$.</span></span> <span data-ttu-id="f12b9-234">A második paraméter a `Double[]` Pauli-karakterlánc együtthatóját tárolja a Hamilton.</span><span class="sxs-lookup"><span data-stu-id="f12b9-234">The second parameter `Double[]` stores the coefficient of the Pauli string in the Hamiltonian.</span></span> <span data-ttu-id="f12b9-235">Vegye figyelembe, hogy a tömbnek csak az első eleme van használatban.</span><span class="sxs-lookup"><span data-stu-id="f12b9-235">Note that only the first element of this array is used.</span></span> <span data-ttu-id="f12b9-236">A harmadik paraméter `Int[]` indexeli azokat a qubits, amelyeken ez a Pauli-karakterlánc működik, és nem rendelkezhet duplikált elemekkel.</span><span class="sxs-lookup"><span data-stu-id="f12b9-236">The third parameter `Int[]` indexes the qubits that this Pauli string acts on, and must have no duplicate elements.</span></span> <span data-ttu-id="f12b9-237">Így a $0,4 \hat X_0 \hat Y_8 \hat I_2 \hat Z_1 $ Hamilton kifejezés a következőképpen jelenhet meg</span><span class="sxs-lookup"><span data-stu-id="f12b9-237">Thus the Hamiltonian term $0.4 \hat X_0 \hat Y_8\hat I_2\hat Z_1$ may be represented as</span></span>

```qsharp
let generatorIndexExample = GeneratorIndex(([1,2,0,3], [0.4]]), [0,8,2,1]);
```

<span data-ttu-id="f12b9-238">Az `PauliEvolutionSet()` egy olyan függvény, amely az űrlap bármelyikét leképezi `GeneratorIndex` `EvolutionUnitary` a következő aláírással.</span><span class="sxs-lookup"><span data-stu-id="f12b9-238">The `PauliEvolutionSet()` is a function that maps any `GeneratorIndex` of this form to an `EvolutionUnitary` with the following signature.</span></span>

```qsharp
newtype EvolutionUnitary = ((Double, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="f12b9-239">Az első paraméter az időtartamot jelöli, amelyet a (z) és a (z `GeneratorIndex` ) egységes evolúciós együtthatója szoroz.</span><span class="sxs-lookup"><span data-stu-id="f12b9-239">The first parameter represents a time-duration, that will be multiplied by the coefficient in the `GeneratorIndex`, of unitary evolution.</span></span> <span data-ttu-id="f12b9-240">A második paraméter a qubit regisztrálja az egységes műveleteket.</span><span class="sxs-lookup"><span data-stu-id="f12b9-240">The second parameter is the qubit register the unitary acts on.</span></span> 

### <a name="time-dependent-generators"></a><span data-ttu-id="f12b9-241">Time-Dependent generátorok</span><span class="sxs-lookup"><span data-stu-id="f12b9-241">Time-Dependent Generators</span></span> ###

<span data-ttu-id="f12b9-242">Sok esetben érdeklik az időfüggő generátorok modellezése is, például a következő Schrödinger-egyenletben: $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = \hat H (t) \ket{\psi (t)}, \end{align} $ $, ahol a generátor $ \hat H (t) $ most időfügg.</span><span class="sxs-lookup"><span data-stu-id="f12b9-242">In many cases, we are also interested in modelling time-dependent generators, as might occur in the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = \hat H(t) \ket{\psi(t)}, \end{align} $$ where the generator $\hat H(t)$ is now time-dependent.</span></span> <span data-ttu-id="f12b9-243">Ebben az esetben a fenti időponttól független generátorok kiterjesztése egyszerű.</span><span class="sxs-lookup"><span data-stu-id="f12b9-243">The extension from the time-independent generators above to this case is straightforward.</span></span> <span data-ttu-id="f12b9-244">Ahelyett, hogy rögzítette `GeneratorSystem` a Hamilton összes $t $-os időpontra vonatkozó leírását, a `GeneratorSystemTimeDependent` felhasználó által definiált típust kell használnia.</span><span class="sxs-lookup"><span data-stu-id="f12b9-244">Rather than having a fixed `GeneratorSystem` describing the Hamiltonian for all times $t$, we instead have the `GeneratorSystemTimeDependent` user-defined type.</span></span>

```qsharp
newtype GeneratorSystemTimeDependent = (Double -> GeneratorSystem);
```

<span data-ttu-id="f12b9-245">Az első paraméter egy folytonos ütemezett paraméter, $s \in [0, 1] $, és az ilyen típusú függvények az `GeneratorSystem` adott ütemtervhez adott értéket adnak vissza.</span><span class="sxs-lookup"><span data-stu-id="f12b9-245">The first parameter is a continuous schedule parameter $s\in [0,1]$, and functions of this type return a `GeneratorSystem` for that schedule.</span></span> <span data-ttu-id="f12b9-246">Vegye figyelembe, hogy az ütemezett paraméter lineárisan kapcsolódhat a fizikai idő paraméterhez (például $s = t/T $) a szimulációs $T $-hoz tartozó összes időpontig.</span><span class="sxs-lookup"><span data-stu-id="f12b9-246">Note that the schedule parameter may be linearly related to the physical time parameter e.g. $s = t / T$, for some total time of simulation $T$.</span></span> <span data-ttu-id="f12b9-247">Általánosságban azonban ez nem szükséges.</span><span class="sxs-lookup"><span data-stu-id="f12b9-247">In general however, this need not be the case.</span></span>

<span data-ttu-id="f12b9-248">Ehhez hasonlóan a generátor teljes leírására van szükség `EvolutionSet` , ezért definiáljuk a `EvolutionSchedule` felhasználó által definiált típust.</span><span class="sxs-lookup"><span data-stu-id="f12b9-248">Similarly, a complete description of this generator requires an `EvolutionSet`, and so we define an `EvolutionSchedule` user-defined type.</span></span>

```qsharp
newtype EvolutionSchedule = (EvolutionSet, GeneratorSystemTimeDependent);
```
