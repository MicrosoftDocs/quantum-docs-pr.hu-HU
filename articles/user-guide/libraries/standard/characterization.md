---
title: Quantum jellemzés és statisztika
description: Ebből a szakaszból megtudhatja, hogyan használhatók a mérési statisztikák a fázis-becslésekben a kvantum-programozás eredményeinek becsléséhez.
author: bradben
uid: microsoft.quantum.libraries.characterization
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- ':::no-loc(Q#):::'
- ':::no-loc($$v):::'
ms.openlocfilehash: 51e7b3bcf4402a4d0ba5647643f284e9f10c3bb3
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 10/27/2020
ms.locfileid: "92692150"
---
# <a name="quantum-characterization-and-statistics"></a><span data-ttu-id="ec3e3-103">Quantum jellemzés és statisztika</span><span class="sxs-lookup"><span data-stu-id="ec3e3-103">Quantum Characterization and Statistics</span></span> #

<span data-ttu-id="ec3e3-104">Fontos, hogy képes legyen jellemezni a műveletek hatásait a hasznos kvantum-algoritmusok kifejlesztése érdekében.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-104">It is critical to be able to characterize the effects of operations in order to develop useful quantum algorithms.</span></span>
<span data-ttu-id="ec3e3-105">Ez kihívást jelenthet, mivel a kvantumrendszer minden mérése legfeljebb egy kis mennyiségű adatot eredményez.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-105">This is challenging because every measurement of a quantum system yields at most one bit of information.</span></span>
<span data-ttu-id="ec3e3-106">Egy sajátérték megismeréséhez, amely lehetővé teszi a kvantum-állapotot, a számos mérés eredményét össze kell keverni, hogy a felhasználó fel tudja venni az ilyen fogalmak ábrázolásához szükséges sok bitet.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-106">In order to learn an eigenvalue, let alone a quantum state, the results of many measurements must be stitched together so that the user can glean the many bits of information needed to represent these concepts.</span></span>
<span data-ttu-id="ec3e3-107">A kvantum-állapotok különösen bosszantóak, mert a [nem klónozási tétel](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) azt jelzi, hogy az állapot egyetlen példányáról sem lehet tetszőleges kvantum-állapotot betanulni, mert ezzel az állapot másolatait is lehetővé tenné.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-107">Quantum states are especially vexing because the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) states that there is no way to learn an arbitrary quantum state from a single copy of the state, because doing so would let you make copies of the state.</span></span>
<span data-ttu-id="ec3e3-108">A kvantum-állapotnak a felhasználótól való elhomályosítása abban a tényben tükröződik, amely :::no-loc(Q#)::: nem tesz elérhetővé vagy nem határozza meg, hogy milyen állapotban *van* a kvantum-programok.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-108">This obfuscation of the quantum state from the user is reflected in the fact that :::no-loc(Q#)::: does not expose or even define what a state *is* to quantum programs.</span></span>
<span data-ttu-id="ec3e3-109">Így a kvantum-jellemzést úgy közelítjük meg, hogy a műveleteket és az állapotokat fekete dobozként kezeli. Ez a megközelítés gyakran osztozik a kvantum-jellemzés, az ellenőrzés és az érvényesítés (QCVV) kísérleti gyakorlatával.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-109">We thus approach quantum characterization by treating operations and states as black-box; this approach shares much in common with the experimental practice of quantum characterization, verification and validation (QCVV).</span></span>

<span data-ttu-id="ec3e3-110">A jellemzés különbözik a korábban tárgyalt többi könyvtártól.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-110">Characterization is distinct from many of the other libraries discussed previously.</span></span>
<span data-ttu-id="ec3e3-111">A cél a rendszerre vonatkozó klasszikus információk megismerése, nem pedig az állapot-vektorok egységes átalakításának elvégzése.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-111">The aim here is less to learn classical information about the system, rather than to perform a unitary transformation on a state vector.</span></span>
<span data-ttu-id="ec3e3-112">Ezeknek a kódtáraknak ezért a klasszikus és a kvantum-adatok feldolgozását is el kell keverni.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-112">These libraries must therefore blend both classical and quantum information processing.</span></span>


## <a name="iterative-phase-estimation"></a><span data-ttu-id="ec3e3-113">Iterációs fázis becslése</span><span class="sxs-lookup"><span data-stu-id="ec3e3-113">Iterative Phase Estimation</span></span> ##

<span data-ttu-id="ec3e3-114">A kvantummechanika a Quantum-jellemzés szempontjából való megtekintése hasznos alternatívát mutat a kvantum fázis becsléséhez.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-114">Viewing quantum programming in terms of quantum characterization suggests a useful alternative to quantum phase estimation.</span></span>
<span data-ttu-id="ec3e3-115">Ez azt eredményezi, hogy ahelyett, hogy egy $n $-qubit regisztert kellene készítenie, amely a fázis bináris ábrázolását tartalmazza, mint a kvantum fázisok becslésében, megtekintheti a fázisok becslését arra a folyamatra, amellyel a *klasszikus* ügynök a kvantumrendszer tulajdonságait a mérések alapján tanulja meg.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-115">That is, instead of preparing an $n$-qubit register to contain a binary representation of the phase as in quantum phase estimation, we can view phase estimation as the process by which a *classical* agent learns properties of a quantum system through measurements.</span></span>
<span data-ttu-id="ec3e3-116">A "visszarúgás" fázis használatával a bejelentési művelet eredményeként a fekete dobozba tartozó műveletek egy ismeretlen szögbe való bekapcsolásához, de az elforgatást közvetlenül követő egyes lépésekben mért Ancilla qubit mérjük.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-116">We proceed as in the quantum case by using phase kickback to turn applications of a black-box operation into rotations by an unknown angle, but will measure the ancilla qubit that we rotate at each step immediately following the rotation.</span></span>
<span data-ttu-id="ec3e3-117">Ennek az az előnye, hogy csak egyetlen további qubit van szükség a kvantum-esetekben ismertetett visszarúgások végrehajtásához, ahogy ezt követően a mérési eredmények fázisát is megismerheti egy iterációs módon.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-117">This has the advantage that we only require a single additional qubit to perform the phase kickback described in the quantum case, as we then learn the phase from the measurement results at each step in an iterative fashion.</span></span>  
<span data-ttu-id="ec3e3-118">Az alábbiakban javasolt módszerek mindegyike egy másik stratégiát használ a kísérletek tervezéséhez és a különböző adatfeldolgozási módszerekhez a fázis megismerése érdekében.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-118">Each of the methods proposed below uses a different strategy for designing experiments and different data processing methods to learn the phase.</span></span>  <span data-ttu-id="ec3e3-119">Ezek mindegyike egyedi előnnyel rendelkezik, és a szigorú hibákra, a képességekre, az előzetes információk bevezetésére, a hibák elmulasztására vagy a limitted klasszikus számítógépeken való futtatására van szükség.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-119">They each have unique advantage ranging from having rigorous error bounds, to the abilities to incorporate prior information, tolerate errors or run on memory limitted classical computers.</span></span>

<span data-ttu-id="ec3e3-120">Az iterációs fázisok becslésének megvitatásakor egy egységes $U $ értéket fogunk figyelembe venni, amely egy fekete dobozból álló művelet.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-120">In discussing iterative phase estimation, we will consider a unitary $U$ given as a black-box operation.</span></span>
<span data-ttu-id="ec3e3-121">Az [adatstruktúrákban](xref:microsoft.quantum.libraries.data-structures)található Oracle-adatokról szóló szakaszban leírtaknak megfelelően a :::no-loc(Q#)::: Canon modelleket a <xref:Microsoft.Quantum.Oracles.DiscreteOracle> felhasználó által definiált típus alapján, a rekord típusa határozza meg `((Int, Qubit[]) => Unit : Adjoint, Controlled)` .</span><span class="sxs-lookup"><span data-stu-id="ec3e3-121">As described in the section on oracles in [data structures](xref:microsoft.quantum.libraries.data-structures), the :::no-loc(Q#)::: canon models such operations by the <xref:Microsoft.Quantum.Oracles.DiscreteOracle> user-defined type, defined by the tuple type `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span></span>
<span data-ttu-id="ec3e3-122">Konkrétan, ha `U : DiscreteOracle` , akkor `U(m)` a $U ^ millió $ értéket implementál a következőhöz: `m : Int` .</span><span class="sxs-lookup"><span data-stu-id="ec3e3-122">Concretely, if `U : DiscreteOracle`, then `U(m)` implements $U^m$ for `m : Int`.</span></span>

<span data-ttu-id="ec3e3-123">Ennek a definíciónak a helyén az ismétlődő fázisok becslésének minden lépése a $ \ket{+} $ állapotú kiegészítő qubit előkészítésével jár együtt, a kezdeti állapot pedig az $ \ket{\phi} $, amelyet feltételezzük, [hogy az $U](xref:microsoft.quantum.concepts.matrix-advanced) (m) $, azaz $U (m) \ket{\phi} = e ^ {im\phi} \ ket {\ Phi} $.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-123">With this definition in place, each step of iterative phase estimation proceeds by preparing an auxiliary qubit in the $\ket{+}$ state along with the initial state $\ket{\phi}$ that we assume is an [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) of $U(m)$, i.e. $U(m)\ket{\phi}= e^{im\phi}\ket{\phi}$.</span></span>  
<span data-ttu-id="ec3e3-124">Ekkor a rendszer egy vezérelt alkalmazást `U(m)` használ, amely előkészíti a $ \left (R \_ 1 (m \phi) \ket{+} \right) \ket{\phi} $ állapotot.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-124">A controlled application of `U(m)` is then used which prepares the state $\left(R\_1(m \phi) \ket{+}\right)\ket{\phi}$.</span></span>
<span data-ttu-id="ec3e3-125">Ahogy a Quantum Case esetében, az Oracle ellenőrzött alkalmazásának hatása `U(m)` pontosan ugyanaz, mint a $ \ket{+} $ ismeretlen fázisra vonatkozó $R _1 $ alkalmazásának hatása, így a $U $-re vonatkozó hatásokat ebben az egyszerűbb módon tudjuk leírni.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-125">As in the quantum case, the effect of a controlled application of the oracle `U(m)` is precisely the same as the effect of applying $R_1$ for the unknown phase on $\ket{+}$, such that we can describe the effects of $U$ in this simpler fashion.</span></span>
<span data-ttu-id="ec3e3-126">Szükség esetén az algoritmus elforgatja a vezérlő qubit úgy, hogy $R _1 (-m\theta) $ érték beszerzésére alkalmazza a következő állapotot: $ \ket{\psi} = \left (R \_ 1 (m [\phi-\theta]) \ket{+} \right) \ket{\phi} $ $.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-126">Optionally, the algorithm then rotates the control qubit by applying $R_1(-m\theta)$ to obtain a state $\ket{\psi}=\left(R\_1(m [\phi-\theta]) \ket{+}\right)\ket{\phi}$$.</span></span>
<span data-ttu-id="ec3e3-127">A vezérlőként használt kiegészítő qubit a `U(m)` rendszer a $X $ alapon méri, hogy egyetlen klasszikust szerezzen be `Result` .</span><span class="sxs-lookup"><span data-stu-id="ec3e3-127">The auxiliary qubit used as a control for `U(m)` is then measured in the $X$ basis to obtain a single classical `Result`.</span></span>

<span data-ttu-id="ec3e3-128">Ezen a ponton az `Result` iterációs fázis becslése által beszerzett értékek fázisának újraépítése a klasszikus statisztikai következtetési probléma.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-128">At this point, reconstructing the phase from the `Result` values obtained through iterative phase estimation is a classical statistical inference problem.</span></span>
<span data-ttu-id="ec3e3-129">A $m $ értékének megkeresése, amely maximalizálja a szerzett adatokat, mivel a rögzített következtetési módszer miatt egyszerűen probléma van a statisztikában.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-129">Finding the value of $m$ that maximizes the information gained, given a fixed inference method, is simply a problem in statistics.</span></span>
<span data-ttu-id="ec3e3-130">Ezt úgy hangsúlyozzuk, hogy röviden leírja az iterációs fázisok becslését elméleti szinten a Bayes-as paraméter alapján, mielőtt a Canonban ismertetjük a :::no-loc(Q#)::: klasszikus következtetési probléma megoldásához szükséges statisztikai algoritmusokat.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-130">We emphasize this by briefly describing iterative phase estimation at a theoretical level in the Bayesian parameter estimation formalism before proceeding to describe the statistical algorithms provided in the :::no-loc(Q#)::: canon for solving this classical inference problem.</span></span>

### <a name="iterative-phase-estimation-without-eigenstates"></a><span data-ttu-id="ec3e3-131">Iterációs fázis becslése Eigenstates nélkül</span><span class="sxs-lookup"><span data-stu-id="ec3e3-131">Iterative Phase Estimation Without Eigenstates</span></span> ###

<span data-ttu-id="ec3e3-132">Ha olyan bemeneti állapotot ad meg, amely nem eigenstate, azaz ha $U (m) \ket{\phi \_ j} = e ^ {im\phi \_ j} $, akkor a fázisok becslésének folyamata nem determinisztikus módon a kvantum-állapotot egyetlen energetikai eigenstate irányába.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-132">If an input state is provided that is not an eigenstate, which is to say that if $U(m)\ket{\phi\_j} = e^{im\phi\_j}$ then the process of phase estimation non-deterministically guides the quantum state towards a single energy eigenstate.</span></span>  <span data-ttu-id="ec3e3-133">A eigenstate végül az a eigenstate, amely a legvalószínűbb, hogy a megfigyelt terméket fogja létrehozni `Result` .</span><span class="sxs-lookup"><span data-stu-id="ec3e3-133">The eigenstate it ultimately converges to is the eigenstate that is most likely to produce the observed `Result`.</span></span>

<span data-ttu-id="ec3e3-134">A PE egyetlen lépése a következő, nem egységes átalakítást hajtja végre az állapot \begin{align} \ sum_j \sqrt{\Pr (\phi \_ j)} \ket{\phi \_ j} \mapsto \sum \_ j\frac {\ SQRT {\ PR (\phi \_ j)} \sqrt{\Pr (\text{result} | \phi \_ j)} \Ket{\phi \_ j}} {\sqrt{\Pr (\phi j \_ ) \sum \_ j \Pr (\text{result} | \phi \_ j)}}.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-134">Specifically, a single step of PE performs the following non-unitary transformation on a state \begin{align} \sum_j \sqrt{\Pr(\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}.</span></span>
<span data-ttu-id="ec3e3-135">\end{align}, mivel ezt a folyamatot több értékre is megismétlik `Result` , a $ \ prod_k \pr (\text{result} \_ k | \phi j) $ maximális értékkel nem rendelkező eigenstates \_ exponenciálisan lesznek letiltva.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-135">\end{align} As this process is iterated over multiple `Result` values, eigenstates that do not have maximal values of $\prod_k\Pr(\text{Result}\_k|\phi\_j)$ will be exponentially suppressed.</span></span>
<span data-ttu-id="ec3e3-136">Ennek eredményeképpen a következtetési folyamat általában egyetlen sajátérték rendelkező állapotokra lesz átszervezve, ha a kísérletek megfelelően vannak kiválasztva.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-136">As a result, the inference process will tend to converge to states with a single eigenvalue if the experiments are chosen properly.</span></span>

<span data-ttu-id="ec3e3-137">A Bayes "tétel továbbra is azt sugallja, hogy a fázis becslésének eredményét a \begin{align} \frac{\sqrt{\Pr (\phi \_ j)} \sqrt{\Pr (\text{result} | \phi \_ j)} \ket{\phi \_ j}} {\sqrt{\Pr (\phi \_ j) \Sum \_ j \Pr (\text{result} | \phi \_ j)}} = \ sum_j \sqrt{\Pr (\phi \_ j | \text{result})} \ket{\phi \_ j}.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-137">Bayes' theorem further suggests that the state that results from phase estimation be written in the form \begin{align} \frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}=\sum_j \sqrt{\Pr(\phi\_j|\text{Result})} \ket{\phi\_j}.</span></span>
<span data-ttu-id="ec3e3-138">\end{align} itt $ \Pr (\phi \_ j | \text{result}) $ lehet értelmezendő, mert a valószínűsége annak, hogy az egyes hipotézisek az adott eigenstates kapcsolatban szerepelnek:</span><span class="sxs-lookup"><span data-stu-id="ec3e3-138">\end{align} Here $\Pr(\phi\_j|\text{Result})$ can be interpretted as the probability that one would ascribe to each hypothesis about the eigenstates given:</span></span>

1. <span data-ttu-id="ec3e3-139">a kvantum állapot ismerete a mérés előtt</span><span class="sxs-lookup"><span data-stu-id="ec3e3-139">knowledge of the quantum state prior to measurement,</span></span>
2. <span data-ttu-id="ec3e3-140">$U $ és eigenstates ismerete</span><span class="sxs-lookup"><span data-stu-id="ec3e3-140">knowledge of the eigenstates of $U$ and,</span></span>
3. <span data-ttu-id="ec3e3-141">$U $ eigenvalues ismerete.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-141">knowledge of the eigenvalues of $U$.</span></span>

<span data-ttu-id="ec3e3-142">A három dolog megismerése gyakran exponenciálisan megnehezíti a klasszikus számítógépeket.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-142">Learning these three things is often exponentially hard on a classical computer.</span></span>
<span data-ttu-id="ec3e3-143">A fázisok becslésének segédprogramja nem csupán kis mértékben áll fenn, mert az ilyen típusú kvantum-tanulási feladatot anélkül is elvégezhet, hogy azok ismerete lenne.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-143">The utility of phase estimation arises, to no small extent, from the fact that it can perform such a quantum learning task without knowing any of them.</span></span>
<span data-ttu-id="ec3e3-144">Ennek az okának a becslése számos olyan kvantum-algoritmuson belül jelenik meg, amelyek exponenciális sebességeket biztosítanak.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-144">Phase estimation for this reason appears within a number of quantum algorithms that provide exponential speedups.</span></span>

### <a name="bayesian-phase-estimation"></a><span data-ttu-id="ec3e3-145">A Bayes fázis becslése</span><span class="sxs-lookup"><span data-stu-id="ec3e3-145">Bayesian Phase Estimation</span></span> ###

> [!TIP]
> <span data-ttu-id="ec3e3-146">A következő témakörben talál további információt a Bayes fázis becsléséről a gyakorlatban: [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation) minta.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-146">For more details on Bayesian phase estimation in practice, please see the [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation) sample.</span></span>

<span data-ttu-id="ec3e3-147">A Bayes-fázis becslésének ötlete egyszerű.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-147">The idea of Bayesian phase estimation is simple.</span></span>
<span data-ttu-id="ec3e3-148">A fázis-becslési protokollból gyűjti a mérési statisztikát, majd az eredményeket a Bayes-következtetéssel dolgozza fel, és megbecsüli a paramétert.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-148">You collect measurement statistics from the phase estimation protocol and then you process the results using Bayesian inference and provide an estimate of the parameter.</span></span>
<span data-ttu-id="ec3e3-149">Ez a feldolgozás a sajátérték, valamint a becsült bizonytalanságot is megadja.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-149">This processing gives you an estimate of the eigenvalue as well as the uncertainty in that estimate.</span></span>
<span data-ttu-id="ec3e3-150">Lehetővé teszi az adaptív kísérletek elvégzését és az előzetes információk felhasználását is.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-150">It also allows you to perform adaptive experiments and utilize prior information.</span></span>
<span data-ttu-id="ec3e3-151">A metódusok elvi hátránya, hogy számítási feltételként kell megkövetelni.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-151">The methods' principle drawback is that it is computationally demanding.</span></span>

<span data-ttu-id="ec3e3-152">Ha meg szeretné tudni, hogyan működik ez a Bayes-féle következtetési folyamat, vegye figyelembe az egyetlen eredmény feldolgozásának esetét `Zero` .</span><span class="sxs-lookup"><span data-stu-id="ec3e3-152">To understand how this Bayesian inference process works, consider the case of processing a single `Zero` result.</span></span>
<span data-ttu-id="ec3e3-153">Vegye figyelembe, hogy $X = \ket{+} \bra{+}-\ket {-} \bra {-} $, például a $ \ket{+} $ érték az egyetlen pozitív eigenstate, amely a $X $-nek felel meg `Zero` .</span><span class="sxs-lookup"><span data-stu-id="ec3e3-153">Note that $X = \ket{+}\bra{+} - \ket{-}\bra{-}$, such that $\ket{+}$ is the only positive eigenstate of $X$ corresponding to `Zero`.</span></span>
<span data-ttu-id="ec3e3-154">Az `Zero` első qubit [ `PauliX` mérésének](xref:microsoft.quantum.concepts.pauli) valószínűsége, ha a bemeneti állapot $ \ket{\psi}\ket{\phi} $, így \begin{Equation} \Pr (\texttt{Zero} | \psi) = \left | \braket{+ | \psi} \right | ^ 2.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-154">The probability of observing `Zero` for a [`PauliX` measurement](xref:microsoft.quantum.concepts.pauli) on the first qubit given an input state $\ket{\psi}\ket{\phi}$ is thus \begin{equation} \Pr(\texttt{Zero} | \psi) = \left| \braket{+ | \psi} \right|^2.</span></span>
<span data-ttu-id="ec3e3-155">\end{Equation} az ismétlődő fázisok becslése esetén a $ \ket{\psi} = R_1 (m [\phi-\theta]) \ket{+} $, például \begin{align} \Pr (\texttt{Zero} | \phi; m, \theta) & = \left | \braket{+ | R_1 (m [\phi-\theta]) | +} \right | ^ 2 \\ \\ & = \left | \frac12 \left (\bra {0} + \bra {1} \right) \left (\ket {0} + e ^ {i m [\phi-\theta]} \ket {1} \right) \right | ^ 2 \\ \\ & = \left | \frac{1 + e ^ {i m [\phi-\theta]}} {2} \right | ^ 2 \\ \\ & = \cos ^ 2 (m [\phi-\theta]/2) \tag{★} \label{EQ: fázis-est-valószínűség}.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-155">\end{equation} In the case of iterative phase estimation, we have that $\ket{\psi} = R_1(m [\phi-\theta]) \ket{+}$, such that \begin{align} \Pr(\texttt{Zero} | \phi; m,\theta) & = \left| \braket{+ | R_1(m [\phi-\theta]) | +} \right|^2 \\\\ & = \left| \frac12 \left( \bra{0} + \bra{1} \right) \left( \ket{0} + e^{i m [\phi-\theta]} \ket{1} \right) \right|^2 \\\\ & = \left| \frac{1 + e^{i m [\phi-\theta]}}{2} \right|^2 \\\\ & = \cos^2(m [\phi-\theta] / 2) \tag{★} \label{eq:phase-est-likelihood}.</span></span>
<span data-ttu-id="ec3e3-156">a \end{align} az iterációs fázis becslése egy szinuszos függvény rezgő gyakoriságának megismerését jelenti, amely lehetővé teszi, hogy egy érmet a sinusoid által adott torzítással lehessen átadni.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-156">\end{align} That is, iterative phase estimation consists of learning the oscillation frequency of a sinusoidal function, given the ability to flip a coin with a bias given by that sinusoid.</span></span>
<span data-ttu-id="ec3e3-157">A hagyományos klasszikus terminológiát követve a $ \eqref{EQ: Phase-est-valószínűség} $ értéket hívjuk az iterációs fázis becslésének *valószínűségi függvényében* .</span><span class="sxs-lookup"><span data-stu-id="ec3e3-157">Following traditional classical terminology, we call $\eqref{eq:phase-est-likelihood}$ the *likelihood function* for iterative phase estimation.</span></span>

<span data-ttu-id="ec3e3-158">Miután megfigyelte `Result` , hogy az iterációs fázis kiértékelésének valószínűsége függvényt használja, a Bayes szabály használatával írhatja be, hogy mit higgyünk a megfigyelés követésének fázisában.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-158">Having observed a `Result` from the iterative phase estimation likelihood function, we can then use Bayes' rule to prescribe what we should believe the phase to be following that observation.</span></span>
<span data-ttu-id="ec3e3-159">Konkrétan, \begin{Equation} \Pr (\phi | d) = \frac{\Pr (d | \phi) \Pr (\phi)} {\int \Pr (d | \phi) \Pr (\phi) {\mathrm d} \phi} \Pr (\phi), \end{Equation}, ahol $d \in \\ {\texttt{Zero}, \texttt{One} \\ } $ a `Result` , és ahol $ \Pr (\phi) $ leírja a $ \phi $-vel kapcsolatos korábbi hiedelmeket.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-159">Concretely, \begin{equation} \Pr(\phi | d) = \frac{\Pr(d | \phi) \Pr(\phi)}{\int \Pr(d | \phi) \Pr(\phi){\mathrm d}\phi} \Pr(\phi), \end{equation} where $d \in \\{\texttt{Zero}, \texttt{One}\\}$ is a `Result`, and where $\Pr(\phi)$ describes our prior beliefs about $\phi$.</span></span>
<span data-ttu-id="ec3e3-160">Ezután az iterációs fázis becslésének iterációs jellegét adja meg explicit módon, mivel a posterior Distribution $ \Pr (\phi | d) $ a következő bevezetését közvetlenül megelőzően ismerteti `Result` .</span><span class="sxs-lookup"><span data-stu-id="ec3e3-160">This then makes the iterative nature of iterative phase estimation explicit, as the posterior distribution $\Pr(\phi | d)$ describes our beliefs immediately preceding our observation of the next `Result`.</span></span>

<span data-ttu-id="ec3e3-161">Ebben az eljárásban a klasszikus vezérlő által a \begin{Equation} \hat{\phi} \mathrel{: =} \expect [\phi | \text{Data}] = \int \phi \Pr (\phi | \text{Data}) {\mathrm d} \phi, \end{Equation}, ahol a $ \text{Data} $ a beszerzett értékek teljes rekordját jelenti, \hat{\phi} `Result` .</span><span class="sxs-lookup"><span data-stu-id="ec3e3-161">At any point during this procedure, we can report the phase $\hat{\phi}$ inferred by the classical controller as \begin{equation} \hat{\phi} \mathrel{:=} \expect[\phi | \text{data}] = \int \phi \Pr(\phi | \text{data}) {\mathrm d}\phi, \end{equation} where $\text{data}$ stands for the entire record of all `Result` values obtained.</span></span>

<span data-ttu-id="ec3e3-162">A Bayes-következtetések pontos megállapítása a gyakorlatban megoldhatatlan.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-162">Exact Bayesian inference is in practice intractable.</span></span>
<span data-ttu-id="ec3e3-163">Ehhez Képzelje el, hogy $n $-bit változót szeretne megtanulni $x $-ra.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-163">To see this imagine we wish to learn an $n$-bit variable $x$.</span></span>
<span data-ttu-id="ec3e3-164">A korábbi Distribution $ \Pr (x) $ támogatás több mint $2 ^ n $ feltételezett értéket támogat a $x $ értéknél.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-164">The prior distribution $\Pr(x)$ has support over $2^n$ hypothetical values of $x$.</span></span>
<span data-ttu-id="ec3e3-165">Ez azt jelenti, hogy ha nagyon pontos becslésre van szükségünk, $x $, akkor a Bayes-fázis becslése tiltó memóriát és feldolgozási időt igényel.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-165">This means that if we need a highly accurate estimate of $x$ then Bayesian phase estimation may need prohibitive memory and processing time.</span></span>
<span data-ttu-id="ec3e3-166">Egyes alkalmazások, például a kvantum-szimulációk esetében a limitted pontossága nem zárja ki az ilyen metódusokat, például a rövid algoritmust, a szakasz becslésének lépésein belül nem használhatók a pontos Bayes-következtetések.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-166">While for some applications, such as quantum simulation, the limitted accuracy required does not preclude such methods other applications, such as Shor's algorithm, cannot use exact Bayesian inference within its phase estimation step.</span></span>  <span data-ttu-id="ec3e3-167">Ezért megvalósításokat is biztosítunk a Bayes-as módszerekhez, például a [véletlenszerű RWPE-becslésekhez](xref:Microsoft.Quantum.Research.Characterization.RandomWalkPhaseEstimation) , valamint a nem bayesos megközelítésekhez, például a [robusztus fázisok becsléséhez](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation).</span><span class="sxs-lookup"><span data-stu-id="ec3e3-167">For this reason, we also provide implementations for approximate Bayesian methods such as [random walk phase estimation (RWPE)](xref:Microsoft.Quantum.Research.Characterization.RandomWalkPhaseEstimation) and also non-Bayesian approaches such as [robust phase estimation](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation).</span></span>

### <a name="robust-phase-estimation"></a><span data-ttu-id="ec3e3-168">Robusztus fázis becslése</span><span class="sxs-lookup"><span data-stu-id="ec3e3-168">Robust Phase Estimation</span></span> ###

<span data-ttu-id="ec3e3-169">A mérési eredményekből származó fázisok becsült *utólagos* újraépítése exponenciálisan megnehezíti a legrosszabb esetben.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-169">A maximum *a posteriori* Bayesian reconstruction of a phase estimate from measurement results is exponentially hard in the worst-case.</span></span> <span data-ttu-id="ec3e3-170">Így a gyakorlatban a gyakorlati fázis becslése algoritmusok bizonyos minőségeket feláldoznak a rekonstrukcióban, a klasszikus feldolgozások mennyiségét pedig az elvégzett mérések számával együtt.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-170">Thus most practical phase estimation algorithms sacrifice some quality in the reconstruction, in exchange for an amount of classical post-processing that instead scales polynomially with the number of measurements made.</span></span>

<span data-ttu-id="ec3e3-171">Egy ilyen példa egy hatékony klasszikus utólagos feldolgozási lépés a [robusztus fázis-becslési algoritmus](https://arxiv.org/abs/1502.02677), amely a fent említett aláírást és bemeneteket is megjeleníti.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-171">One such example with an efficient classical post-processing step is the [robust phase estimation algorithm](https://arxiv.org/abs/1502.02677), with its signature and inputs mentioned above.</span></span> <span data-ttu-id="ec3e3-172">Ez azt feltételezi, hogy a bemeneti, $U $ értékű fekete dobozok típusaként vannak becsomagolva `DiscreteOracle` , így csak a vezérelt $U $ egész számú jogosultságot kérdezi le.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-172">It assumes that input unitary black-boxes $U$ are packaged as `DiscreteOracle` type, and therefore only queries integer powers of controlled-$U$.</span></span> <span data-ttu-id="ec3e3-173">Ha a regisztráció bemeneti állapota `Qubit[]` eigenstate $U \ket{\psi} = e ^ {i\phi} \ ket {\ psi} $, a robusztus fázis-becslési algoritmus a becslés $ \hat{\phi}\in [-\pi, \pi) $ $ \phi $ értéket adja vissza `Double` .</span><span class="sxs-lookup"><span data-stu-id="ec3e3-173">If the input state in the `Qubit[]` register is an eigenstate $U\ket{\psi}=e^{i\phi}\ket{\psi}$, the robust phase estimation algorithm returns an estimate $\hat{\phi}\in[-\pi,\pi)$ of $\phi$ as a `Double`.</span></span>

<span data-ttu-id="ec3e3-174">A robusztus fázisok becslésének legfontosabb funkciója, amelyet a legtöbb más hasznos változatban megosztanak, az, hogy a $ \hat{\phi} $ újraépítési minőség bizonyos értelemben Heisenberg korlátozott.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-174">The most important feature of robust phase estimation, which is shared with most other useful variants, is that the reconstruction quality of $\hat{\phi}$ is in some sense Heisenberg-limited.</span></span> <span data-ttu-id="ec3e3-175">Ez azt jelenti, hogy ha a valódi érték $ \hat{\phi} $ értéke a $ \sigma $, akkor a $ \sigma $ függvény fordítottan arányos – az ellenőrzött $U $-ra, azaz a $ \sigma = \mathcal{O} (1/Q) $ értékű $Q lekérdezések teljes számával arányosan.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-175">This means that if the deviation of $\hat{\phi}$ from the true value is $\sigma$, then $\sigma$ scales inversely-proportional to the total number of queries $Q$ made to controlled-$U$, i.e. $\sigma=\mathcal{O}(1/Q)$.</span></span> <span data-ttu-id="ec3e3-176">Az eltérés definíciója most a különböző becslési algoritmusok között változik.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-176">Now, the definition of deviation varies between different estimation algorithms.</span></span> <span data-ttu-id="ec3e3-177">Bizonyos esetekben előfordulhat, hogy legalább $ \mathcal{O} (1) $ valószínűséggel, a becslési hiba $ | \hat{\phi}-\phi | \_ \circ\le \sigma $ egy bizonyos körkörös mértéknél $ \circ $.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-177">In some cases, it may mean that with at least $\mathcal{O}(1)$ probability, the estimation error $|\hat{\phi}-\phi|\_\circ\le \sigma$ on some circular measure $\circ$.</span></span> <span data-ttu-id="ec3e3-178">A robusztus fázisok becslése esetében az eltérés pontosan a következő variancia: $ \sigma ^ 2 = \mathbb{E} \_ \hat{\phi} [(\mod \_ {2 \ PI} (\hat{\phi}-\phi + \pi)-\pi) ^ 2] $, ha az időszakos fázisokat egyetlen véges intervallumra (-\pi, \pi] $-ra csomagoljuk.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-178">For robust phase estimation, deviation is precisely the variance $\sigma^2 = \mathbb{E}\_\hat{\phi}[(\mod\_{2\pi}(\hat{\phi}-\phi +\pi)-\pi)^2]$ if we unwrap periodic phases onto a single finite interval $(-\pi,\pi]$.</span></span> <span data-ttu-id="ec3e3-179">Pontosabban, a robusztus fázisok becslésének szórása megfelel a $ $ \begin{align} 2,0 \pi/Q \Le \sigma \Le 2 \ pi/2 ^ {n} \Le 10.7 \ PI/Q, \end{align} $ $, ahol az alsó határ elérte a nagy $Q $ izomorf korlátot, és a felső határ garantált a kis méretű minták esetében is.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-179">More precisely, the standard deviation in robust phase estimation satisfies the inequalities $$ \begin{align} 2.0 \pi / Q \le \sigma \le 2\pi / 2^{n} \le 10.7\pi / Q, \end{align} $$ where the lower bound is reached in the limit of asymptotically large $Q$, and the upper bound is guaranteed even for small sample sizes.</span></span>  <span data-ttu-id="ec3e3-180">Vegye figyelembe, hogy a bemenet által kiválasztott $n $ `bitsPrecision` , amely implicit módon meghatározza a $Q $ értéket.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-180">Note that $n$ selected by the `bitsPrecision` input, which implicitly defines $Q$.</span></span>

<span data-ttu-id="ec3e3-181">A további releváns részletek közé tartozik például a $1 $ Ancilla qubit, illetve az eljárás nem adaptív, azaz a kvantum-kísérletek szükséges sorozata független a köztes mérési eredményektől.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-181">Other relevant details include, say, the small space overhead of just $1$ ancilla qubit, or that the procedure is non-adaptive, meaning the required sequence of quantum experiments is independent of the intermediate measurement outcomes.</span></span> <span data-ttu-id="ec3e3-182">Ebben a és a közelgő példákban a fázis-becslési algoritmus kiválasztása fontos, az egyiknek a dokumentációra, például @"microsoft.quantum.characterization.robustphaseestimation" a hivatkozott kiadványokra, valamint a megvalósítására kell hivatkoznia.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-182">In this and forthcoming examples where the choice of phase estimation algorithm is important, one should one should refer to the documentation such as @"microsoft.quantum.characterization.robustphaseestimation" and the referenced publications therein for more information and for their the implementation.</span></span>

> [!TIP]
> <span data-ttu-id="ec3e3-183">Számos minta van, ahol robusztus fázis-becslést használunk.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-183">There are many samples where robust phase estimation is used.</span></span> <span data-ttu-id="ec3e3-184">A különböző fizikai rendszerek alapvető állapotának kinyeréséhez szükséges fázis-becsléshez tekintse meg a [ **H2-szimulációs** mintát](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line), a [ **SimpleIsing** mintát](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/simple)és a [ **Hubbard Model** mintát](https://github.com/microsoft/Quantum/tree/main/samples/simulation/hubbard).</span><span class="sxs-lookup"><span data-stu-id="ec3e3-184">For phase estimation in extracting the ground state energy of various physical system, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line), the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/simple), and the [**Hubbard model** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/hubbard).</span></span>


### <a name="continuous-oracles"></a><span data-ttu-id="ec3e3-185">Folyamatos Oracle-</span><span class="sxs-lookup"><span data-stu-id="ec3e3-185">Continuous Oracles</span></span> ###

<span data-ttu-id="ec3e3-186">A fentiekben ismertetett Oracle-modell általánosítható is, hogy a folyamatos Oracle-típusok a Canon típus szerint legyenek modellezve <xref:Microsoft.Quantum.Oracles.ContinuousOracle> .</span><span class="sxs-lookup"><span data-stu-id="ec3e3-186">We can also generalize from the oracle model used above to allow for continuous-time oracles, modeled by the canon type <xref:Microsoft.Quantum.Oracles.ContinuousOracle>.</span></span>
<span data-ttu-id="ec3e3-187">Vegye figyelembe, hogy ahelyett, hogy egyetlen, egységes operátort $U $-t használunk, az egységes operátorok családja $U (t) $, $t \in \mathbb{R} $, hogy $U (t) U (s) $ = $U (t + s) $.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-187">Consider that instead of a single unitary operator $U$, we have a family of unitary operators $U(t)$ for $t \in \mathbb{R}$ such that $U(t) U(s)$ = $U(t + s)$.</span></span>
<span data-ttu-id="ec3e3-188">Ez egy gyengébb utasítás, mint a diszkrét esetekben, mivel a kialakítható a <xref:Microsoft.Quantum.Oracles.DiscreteOracle> $t = m \, \delta t $ korlátozásával néhány Fixed $ \delta t $ értékkel.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-188">This is a weaker statement than in the discrete case, since we can construct a <xref:Microsoft.Quantum.Oracles.DiscreteOracle> by restricting $t = m\,\delta t$ for some fixed $\delta t$.</span></span>
<span data-ttu-id="ec3e3-189">A [Stone-tétel](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U (t) = \exp (i H t) $ egyes operátorok esetében $H $, ahol a $ \exp $ a mátrix exponenciális értéke a [speciális mátrixok](xref:microsoft.quantum.concepts.matrix-advanced)részben leírtak szerint.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-189">By [Stone's theorem](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U(t) = \exp(i H t)$ for some operator $H$, where $\exp$ is the matrix exponential as described in [advanced matrices](xref:microsoft.quantum.concepts.matrix-advanced).</span></span>
<span data-ttu-id="ec3e3-190">Egy eigenstate $ \ket{\phi} $ $H $-ból, amely $H \ket{\phi} = \phi \ket{\phi} $-t is eigenstate $U (t) $ az összes $t $, \begin{Equation} U (t) \ket{\phi} = e ^ {i \phi t} \ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-190">An eigenstate $\ket{\phi}$ of $H$ such that $H \ket{\phi} = \phi \ket{\phi}$ is then also an eigenstate of $U(t)$ for all $t$, \begin{equation} U(t) \ket{\phi} = e^{i \phi t} \ket{\phi}.</span></span>
<span data-ttu-id="ec3e3-191">\end{equation}</span><span class="sxs-lookup"><span data-stu-id="ec3e3-191">\end{equation}</span></span>

<span data-ttu-id="ec3e3-192">A [Bayes fázis becslésének](#bayesian-phase-estimation) pontos elemzése is alkalmazható, és a valószínűségi függvény pontosan ugyanaz ennél az általános Oracle-modellnél: $ $ \Pr (\texttt{Zero} | \phi; t, \theta) = \cos ^ 2 \ Left (\frac{t [\phi-\theta]} {2} \right).</span><span class="sxs-lookup"><span data-stu-id="ec3e3-192">The exact same analysis discussed for [Bayesian phase estimation](#bayesian-phase-estimation) can be applied, and the likelihood function is the precisely the same for this more general oracle model: $$ \Pr(\texttt{Zero} | \phi; t,\theta)=\cos^2\left(\frac{t[\phi -\theta]}{2}\right).</span></span>
<span data-ttu-id="ec3e3-193">$ $ Továbbá, ha $U $ egy dinamikus generátor szimulációja, mint a [Hamilton-szimuláció](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation)esetében, akkor a $ \phi $ értéket használjuk energiaként.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-193">$$ Moreover, if $U$ is a simulation of a dynamical generator, as is the case for [Hamiltonian simulation](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), we interpret $\phi$ as an energy.</span></span>
<span data-ttu-id="ec3e3-194">Így a folyamatos lekérdezésekkel a fázisok becslése lehetővé teszi, hogy megismerjük a molekulák, [anyagok](https://arxiv.org/abs/1510.03859) vagy [mezők elméletének](https://arxiv.org/abs/1111.3633v2) szimulált [energia-spektrumát](https://arxiv.org/abs/quant-ph/0604193)anélkül, hogy az $t</span><span class="sxs-lookup"><span data-stu-id="ec3e3-194">Thus, using phase estimation with continuous queries allows us to learn the simulated [energy spectrum of molecules](https://arxiv.org/abs/quant-ph/0604193), [materials](https://arxiv.org/abs/1510.03859) or [field theories](https://arxiv.org/abs/1111.3633v2) without having to compromise our choice of experiments by requiring $t$ to be an integer.</span></span>

### <a name="random-walk-phase-estimation"></a><span data-ttu-id="ec3e3-195">Véletlenszerű séta fázisának becslése</span><span class="sxs-lookup"><span data-stu-id="ec3e3-195">Random Walk Phase Estimation</span></span> ###

<span data-ttu-id="ec3e3-196">:::no-loc(Q#)::: hasznos közelítést nyújt a Bayes-fázis becsléséhez, amelyet úgy terveztek, hogy az olyan kvantum-eszközökhöz közelítse a használatot, amelyek az iterációs fázis becslése alapján kapott adatrekordon véletlenszerű sétával működnek.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-196">:::no-loc(Q#)::: provides a useful approximation of Bayesian phase estimation designed for use close to quantum devices that operates by conditioning a random walk on the data record obtained from iterative phase estimation.</span></span>
<span data-ttu-id="ec3e3-197">Ez a módszer egyaránt adaptív és teljes mértékben determinisztikus, ami lehetővé teszi a hibák közel optimális méretezését a becsült "\hat{\phi} $" fázisban, nagyon alacsony memóriával.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-197">This method is both adaptive and entirely deterministic, allowing for near-optimal scaling of errors in the estimated phase $\hat{\phi}$ with very low memory overheads.</span></span>

<span data-ttu-id="ec3e3-198">A protokoll egy hozzávetőleges Bayes-következtetési módszert használ, amely feltételezi, hogy az előző eloszlás a Gauss.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-198">The protocol uses an approximate Bayesian inference method that assumes the prior distribution is Gaussian.</span></span>
<span data-ttu-id="ec3e3-199">Ez a Gauss-feltevés lehetővé teszi, hogy a kísérlethez olyan analitikai képletet használjon, amely a hátsó variancia minimalizálását végzi.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-199">This Gaussian assumption allows us to use an analytical formula for the experiment that minimizes the posterior variance.</span></span>
<span data-ttu-id="ec3e3-200">Az algoritmus ezután a kísérlet eredménye alapján áthelyezi a $ \phi $ értéket egy előre meghatározott összeggel balra vagy jobbra, és egy előre meghatározott összeggel csökkenti a variancia értékét.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-200">The algorithm then, based on the outcome of that experiment, shifts the estimate of $\phi$ left or right by a pre-determined amount and shrinks the variance by a pre-determined amount.</span></span>
<span data-ttu-id="ec3e3-201">Ez a középérték és a variancia adja meg az összes olyan információt, amely szükséges a Gauss megadásához a $ \phi $ értéknél a következő kísérletnél.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-201">This mean and variance give all the information that is needed to specify a Gaussian prior on $\phi$ for the next experiment.</span></span>
<span data-ttu-id="ec3e3-202">A nem várt mérési hibák, vagy a kezdeti előtt az igaz eredmény az, hogy ez a metódus sikertelen lesz.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-202">Unexpected measurement failures, or the true result being on the tails of the initial prior, can cause this method to fail.</span></span>
<span data-ttu-id="ec3e3-203">A művelet sikertelenül helyreállítja a kísérleteket, hogy tesztelje, hogy a jelenlegi középérték és szórás megfelelő-e a rendszer számára.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-203">It recovers from failure by performing experiments to test whether the current mean and standard deviation are appropriate for the system.</span></span>
<span data-ttu-id="ec3e3-204">Ha nem, akkor az algoritmus a séta inverz lépését és a folyamat folytatását is folytatja.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-204">If they are not, then the algorithm does an inverse step of the walk and the process continues.</span></span>
<span data-ttu-id="ec3e3-205">A visszafelé lépés lehetővé teszi, hogy az algoritmus még akkor is tudjon tanulni, ha a kezdeti korábbi szórás inapropriately kicsi.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-205">The ability to step backwards also allows the algorithm to learn even if the initial prior standard deviation is inapropriately small.</span></span>

## <a name="calling-phase-estimation-algorithms"></a><span data-ttu-id="ec3e3-206">Hívási fázisok becslési algoritmusai</span><span class="sxs-lookup"><span data-stu-id="ec3e3-206">Calling Phase Estimation Algorithms</span></span> ##

<span data-ttu-id="ec3e3-207">A Canon által biztosított minden fázis-becslési művelet :::no-loc(Q#)::: különböző bemeneteket használ a parameterizing, amelyet a végleges becslés $ \hat{\phi} $ értékkel együtt igényel.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-207">Each phase estimation operation provided with the :::no-loc(Q#)::: canon takes a different set of inputs parameterizing the quality that we demand out of the final estimate $\hat{\phi}$.</span></span>
<span data-ttu-id="ec3e3-208">Ezek a különböző bemenetek azonban a közösen több bemenetet is megosztanak, például a minőségi paraméterekben lévő részleges alkalmazások közös aláírást eredményeznek.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-208">These various inputs, however, all share several inputs in common, such that partial application over the quality parameters results in a common signature.</span></span>
<span data-ttu-id="ec3e3-209">A <xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation> következő szakaszban tárgyalt művelet például a következő aláírással rendelkezik:</span><span class="sxs-lookup"><span data-stu-id="ec3e3-209">For example, the <xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation> operation discussed in the next section has the following signature:</span></span>

```qsharp
operation RobustPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
```

<span data-ttu-id="ec3e3-210">A `bitsPrecision` bemenet egyedi `RobustPhaseEstimation` , míg a `oracle` és a `eigenstate` közös.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-210">The `bitsPrecision` input is unique to `RobustPhaseEstimation`, while `oracle` and `eigenstate` are in common.</span></span>
<span data-ttu-id="ec3e3-211">Így ahogy a **H2Sample** is látható, egy művelet elfogadhat egy iterációs fázis-értékelési algoritmust, amely az űrlap bemenetével `(DiscreteOracle, Qubit[]) => Unit` lehetővé teszi, hogy a felhasználó tetszőleges fázisú becslési algoritmusokat adjon meg:</span><span class="sxs-lookup"><span data-stu-id="ec3e3-211">Thus, as seen in **H2Sample** , an operation can accept an iterative phase estimation algorithm with an input of the form `(DiscreteOracle, Qubit[]) => Unit` to allow a user to specify arbitrary phase estimation algorithms:</span></span>

```qsharp
operation H2EstimateEnergy(
    idxBondLength : Int,
    trotterStepSize : Double,
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double
```

<span data-ttu-id="ec3e3-212">Ezek a számtalan fázis-becslési algoritmusok különböző tulajdonságokra és bemeneti paraméterekre vannak optimalizálva, amelyeket érdemes értelmezni a célalkalmazás legmegfelelőbb választásához.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-212">These myriad phase estimation algorithms are optimized for different properties and input parameters, which must be understood to make the best choice for the target application.</span></span> <span data-ttu-id="ec3e3-213">Például egyes fázis-becslési algoritmusok adaptívak, ami azt jelenti, hogy a jövőbeli lépéseket a korábbi lépések mérési eredményei klasszikusan szabályozzák.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-213">For instance, some phase estimation algorithms are adaptive, meaning that future steps are classically controlled by the measurement results of previous steps.</span></span> <span data-ttu-id="ec3e3-214">Egyesek számára lehetővé kell tenni, hogy a fekete dobozos egységes Oracle-t tetszőleges valós hatáskörökkel exponentiate, mások pedig csak egész hatásköröket igényelnek, de csak a 2. számú, 2 \ PI $ adatmennyiséget tudják feloldani.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-214">Some require the ability to exponentiate its black-box unitary oracle by arbitrary real powers, and others only require integer powers but are only able to resolve a phase estimate modulo $2\pi$.</span></span> <span data-ttu-id="ec3e3-215">Némelyikhez számos kiegészítő qubits szükséges, mások pedig csak egyet igényelnek.</span><span class="sxs-lookup"><span data-stu-id="ec3e3-215">Some require many auxiliary qubits, and others require only one.</span></span>

<span data-ttu-id="ec3e3-216">Hasonlóképpen, ha a véletlenszerű séta fázisának becslését használja, ugyanúgy, mint a canonhoz tartozó más algoritmusokkal:</span><span class="sxs-lookup"><span data-stu-id="ec3e3-216">Similarly, using random walk phase estimation proceeds in much the same way as for other algorithms provided with the canon:</span></span>

```qsharp
operation ApplyExampleOracle(
    eigenphase : Double,
    time : Double,
    register : Qubit[])
: Unit is Adj + Ctl {
    Rz(2.0 * eigenphase * time, register[0]);
}

operation EstimateBayesianPhase(eigenphase : Double) : Double {
    let oracle = ContinuousOracle(ApplyExampleOracle(eigenphase, _, _));
    using (eigenstate = Qubit()) {
        X(eigenstate);
        // The additional inputs here specify the mean and variance of the prior, the number of
        // iterations to perform, how many iterations to perform as a maximum, and how many
        // steps to roll back on an approximation failure.
        let est = RandomWalkPhaseEstimation(0.0, 1.0, 61, 100000, 1, oracle, [eigenstate]);
        Reset(eigenstate);
        return est;
    }
}
```
