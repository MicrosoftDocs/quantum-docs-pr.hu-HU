---
title: 'Hibajavítás a Q # standard kódtárakban'
description: 'Megtudhatja, hogyan használhatja a Q # programokban a hiba javítására szolgáló kódokat a qubits állapotának védelme mellett.'
author: QuantumWriter
uid: microsoft.quantum.libraries.error-correction
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 514fe68f603b9a3a0b4607390719b08a43fe4967
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907766"
---
# <a name="error-correction"></a><span data-ttu-id="6a5f4-103">Hibajavítás</span><span class="sxs-lookup"><span data-stu-id="6a5f4-103">Error Correction</span></span> #

## <a name="introduction"></a><span data-ttu-id="6a5f4-104">Introduction (Bevezetés)</span><span class="sxs-lookup"><span data-stu-id="6a5f4-104">Introduction</span></span> ##

<span data-ttu-id="6a5f4-105">A klasszikus számítástechnika esetében, ha egy kicsit a hibák ellen szeretne védeni, az adatbitek megismétlésével általában elég, ha az adott bitet egy *logikai bit* jelzi.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-105">In classical computing, if one wants to protect a bit against errors, it can often suffice to represent that bit by a *logical bit* by repeating the data bit.</span></span>
<span data-ttu-id="6a5f4-106">Például hagyja, hogy a $ \overline{0} = $0 legyen az adatmennyiség 0 kódolása, ahol a 0. címkénél nagyobb sort használunk, amely azt jelzi, hogy egy kicsit a 0 állapotú kódolású.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-106">For instance, let $\overline{0} = 000$ be the encoding of the data bit 0, where we use the a line above the label 0 to indicate that it is an encoding of a bit in the 0 state.</span></span>
<span data-ttu-id="6a5f4-107">Ha hasonlóan hagyjuk a $ \overline{1} = $111-et, akkor egy egyszerű ismétlődési kód áll rendelkezésére, amely egy kicsit megfricskázó hiba ellen nyújt védelmet.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-107">If we similarly let $\overline{1} = 111$, then we have a simple repetition code that protects against any one bit flip error.</span></span>
<span data-ttu-id="6a5f4-108">Azaz ha a három bit bármelyike tükrözött, akkor a logikai bitek állapotát többségi szavazással helyreállítjuk.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-108">That is, if any of the three bits are flipped, then we can recover the state of the logical bit by taking a majority vote.</span></span>
<span data-ttu-id="6a5f4-109">Bár a klasszikus hibajavítás sokkal gazdagabb téma, hogy ez az adott példa (azt javasoljuk, hogy tegyük a [kódolási elmélet bevezetését](https://www.springer.com/us/book/9783540641339)), a fenti ismétlődési kód már a kvantum-információk védelmének lehetséges problémájára mutat.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-109">Though classical error correction is a much richer subject that this particular example (we recommend [Lint's introduction to coding theory](https://www.springer.com/us/book/9783540641339)), the repetition code above already points to a possible problem in protecting quantum information.</span></span>
<span data-ttu-id="6a5f4-110">A [nem klónozási tétel](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) azt jelenti, hogy ha az egyes qubit mértékét méri, és a fentiekben a klasszikus kódokhoz hasonló többségi szavazást végez, akkor elveszítettük a védelemmel ellátott pontos információkat.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-110">Namely, the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) implies that if we measure each individual qubit and take a majority vote by analogy to classical code above, then we have lost the precise information that we are trying to protect.</span></span>

<span data-ttu-id="6a5f4-111">A kvantum beállításban láthatjuk, hogy a mérték problémás.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-111">In the quantum setting, we will see that the measurement is problematic.</span></span> <span data-ttu-id="6a5f4-112">A fenti kódolás továbbra is megvalósítható.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-112">We can still implement the encoding above.</span></span>
<span data-ttu-id="6a5f4-113">Hasznos, ha szeretné megtudni, hogyan általánosíthatja a hibajavítást a kvantum-esetre.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-113">It is helpful to do so to see how we can generalize error correction to the quantum case.</span></span>
<span data-ttu-id="6a5f4-114">Így tehát a $ \ket{\overline{0}} = \ket{000} = \ket{0} \otimes \ket{0} \otimes \ket{0}$, és hagyja $ \ket{\overline{1}} = \ket{111}$.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-114">Thus, let $\ket{\overline{0}} = \ket{000} = \ket{0} \otimes \ket{0} \otimes \ket{0}$, and let $\ket{\overline{1}} = \ket{111}$.</span></span>
<span data-ttu-id="6a5f4-115">Ezt követően a linearitás alapján meghatározjuk az összes bemenet ismétlődési kódját; például: $ \ket{\overline{+}} = (\ket{\overline{0}} + \ket{\overline{1}})/\sqrt{2} = (\ket{000} + \ket{111})/\sqrt{2}$.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-115">Then, by linearity, we have defined our repetition code for all inputs; for instance, $\ket{\overline{+}} = (\ket{\overline{0}} + \ket{\overline{1}}) / \sqrt{2} = (\ket{000} + \ket{111}) / \sqrt{2}$.</span></span>
<span data-ttu-id="6a5f4-116">Különösen a egy kicsit flip hiba $X _1 $ művelet a középső qubit, láthatjuk, hogy mindkét ág esetében pontosan $X _1 $: $ $ \begin{align} X_1 \ket{\overline{+}} & = \frac{1}{\sqrt{2}} \left (X_1 \ket{000} + X_1 \ket{111} \right) \\\\ & = \frac{1}{\sqrt{2}} \left (\ket{010} + \ket{101} \right).</span><span class="sxs-lookup"><span data-stu-id="6a5f4-116">In particular, letting a bit-flip error $X_1$ act on the middle qubit, we see that the correction needed in both branches is precisely $X_1$: $$ \begin{align} X_1 \ket{\overline{+}} & = \frac{1}{\sqrt{2}} \left( X_1 \ket{000} + X_1 \ket{111} \right) \\\\ & = \frac{1}{\sqrt{2}} \left( \ket{010} + \ket{101} \right).</span></span>
<span data-ttu-id="6a5f4-117">\end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="6a5f4-117">\end{align} $$</span></span>

<span data-ttu-id="6a5f4-118">Ha szeretné megtudni, hogy miként azonosítható, hogy ez a helyzet a védelemre kerülő állapot mérése nélkül, hasznos, ha leírjuk, hogy milyen módon történik a különböző áttekintő hibák használata a logikai állapotokban:</span><span class="sxs-lookup"><span data-stu-id="6a5f4-118">To see how we can identify that this is the case without measuring the very state we are trying to protect, it is helpful to write down what each different bit flip error does to our logical states:</span></span>

| <span data-ttu-id="6a5f4-119">Hiba $E $</span><span class="sxs-lookup"><span data-stu-id="6a5f4-119">Error $E$</span></span> | <span data-ttu-id="6a5f4-120">$E \ket{\overline{0}} $</span><span class="sxs-lookup"><span data-stu-id="6a5f4-120">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="6a5f4-121">$E \ket{\overline{1}} $</span><span class="sxs-lookup"><span data-stu-id="6a5f4-121">$E\ket{\overline{1}}$</span></span> |
| --- | --- | --- |
| <span data-ttu-id="6a5f4-122">$ \boldone $</span><span class="sxs-lookup"><span data-stu-id="6a5f4-122">$\boldone$</span></span> | <span data-ttu-id="6a5f4-123">$ \ket{000}$</span><span class="sxs-lookup"><span data-stu-id="6a5f4-123">$\ket{000}$</span></span> | <span data-ttu-id="6a5f4-124">$ \ket{111}$</span><span class="sxs-lookup"><span data-stu-id="6a5f4-124">$\ket{111}$</span></span> |
| <span data-ttu-id="6a5f4-125">$X _0 $</span><span class="sxs-lookup"><span data-stu-id="6a5f4-125">$X_0$</span></span> | <span data-ttu-id="6a5f4-126">$ \ket{100}$</span><span class="sxs-lookup"><span data-stu-id="6a5f4-126">$\ket{100}$</span></span> | <span data-ttu-id="6a5f4-127">$ \ket{011}$</span><span class="sxs-lookup"><span data-stu-id="6a5f4-127">$\ket{011}$</span></span> |
| <span data-ttu-id="6a5f4-128">$X _1 $</span><span class="sxs-lookup"><span data-stu-id="6a5f4-128">$X_1$</span></span> | <span data-ttu-id="6a5f4-129">$ \ket{010}$</span><span class="sxs-lookup"><span data-stu-id="6a5f4-129">$\ket{010}$</span></span> | <span data-ttu-id="6a5f4-130">$ \ket{101}$</span><span class="sxs-lookup"><span data-stu-id="6a5f4-130">$\ket{101}$</span></span> |
| <span data-ttu-id="6a5f4-131">$X _2 $</span><span class="sxs-lookup"><span data-stu-id="6a5f4-131">$X_2$</span></span> | <span data-ttu-id="6a5f4-132">$ \ket{001}$</span><span class="sxs-lookup"><span data-stu-id="6a5f4-132">$\ket{001}$</span></span> | <span data-ttu-id="6a5f4-133">$ \ket{110}$</span><span class="sxs-lookup"><span data-stu-id="6a5f4-133">$\ket{110}$</span></span> |

<span data-ttu-id="6a5f4-134">Ahhoz, hogy megvédje a kódoláshoz szükséges állapotot, meg kell tudni különböztetni a három hibát egymástól és a $ \boldone $ identitástól a $ \ket{\overline{0}} $ és a $ \ket{\overline{1}} $ érték megkülönböztetése nélkül.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-134">In order to protect the state that we're encoding, we need to be able to distinguish the three errors from each other and from the identity $\boldone$ without distinguishing between $\ket{\overline{0}}$ and $\ket{\overline{1}}$.</span></span>
<span data-ttu-id="6a5f4-135">Ha például a $Z _0 $ értéket mérjük, akkor a No-Error esetben a $ \ket{\overline{0}} $ és a $ \ket{\overline{1}} $ értékhez egy másik eredményt kapunk, amely Összecsukja a kódolt állapotot.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-135">For example, if we measure $Z_0$, we get a different result for $\ket{\overline{0}}$ and $\ket{\overline{1}}$ in the no-error case, so that collapses the encoded state.</span></span>
<span data-ttu-id="6a5f4-136">Másfelől érdemes megfontolni $Z _0 Z_1 $ mérését, amely az első két bit paritását adja meg minden számítási alapon.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-136">On the other hand, consider measuring $Z_0 Z_1$, the parity of the first two bits in each computational basis state.</span></span>
<span data-ttu-id="6a5f4-137">Ne felejtse el, hogy a Pauli-operátorok minden mérése ellenőrzi, hogy a sajátérték a mért állapot megfelel-e, így a fenti táblázatban szereplő összes \ket{\psi} $ értéknél kiszámítjuk $Z _0 Z_1 \ket{\psi} $ értéket, hogy a $ \pm\ket{\psi} $ beszerzése megtörténjen-e.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-137">Recall that each measurement of a Pauli operator checks which eigenvalue  the state being measured corresponds to, so for each state $\ket{\psi}$ in the table above, we can compute $Z_0 Z_1 \ket{\psi}$ to see if we get $\pm\ket{\psi}$.</span></span>
<span data-ttu-id="6a5f4-138">Vegye figyelembe, hogy $Z _0 Z_1 \ket{000} = \ket{000}$, és hogy $Z _0 Z_1 \ket{111} = \ket{111}$, így azt a következtetést tartjuk, hogy ez a mérték ugyanaz, mint a kódolt állapotok esetében is.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-138">Note that $Z_0 Z_1 \ket{000} = \ket{000}$ and that $Z_0 Z_1 \ket{111} = \ket{111}$, so that we conclude that this measurement does the same thing to both encoded states.</span></span>
<span data-ttu-id="6a5f4-139">Másfelől $Z _0 Z_1 \ket{100} =-\ket{100}$ és $Z _0 Z_1 \ket{011} =-\ket{011}$, így a $Z _0 Z_1 $ mérési eredménye azt mutatja be, hogy milyen hiba történt.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-139">On the other hand, $Z_0 Z_1 \ket{100} = - \ket{100}$ and $Z_0 Z_1 \ket{011} = -\ket{011}$, so the result of measuring $Z_0 Z_1$ reveals useful information about which error occurred.</span></span>

<span data-ttu-id="6a5f4-140">Ennek kihangsúlyozása érdekében ismételje meg a fenti táblázatot, de adja hozzá a $Z _0 Z_1 $ és $Z _1 Z_2 $ mérésének eredményét minden egyes sorban.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-140">To emphasize this, we repeat the table above, but add the results of measuring $Z_0 Z_1$ and $Z_1 Z_2$ on each row.</span></span>
<span data-ttu-id="6a5f4-141">Az egyes mérések eredményeit a megfigyelt sajátérték ($ + $ vagy $-$) jelöléssel jelöljük, amely megfelel a Q # `Result` `Zero` és `One`értékének.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-141">We denote the results of each measurement by the sign of the eigenvalue that is observed, either $+$ or $-$, corresponding to the Q# `Result` values of `Zero` and `One`, respectively.</span></span>

| <span data-ttu-id="6a5f4-142">Hiba $E $</span><span class="sxs-lookup"><span data-stu-id="6a5f4-142">Error $E$</span></span> | <span data-ttu-id="6a5f4-143">$E \ket{\overline{0}} $</span><span class="sxs-lookup"><span data-stu-id="6a5f4-143">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="6a5f4-144">$E \ket{\overline{1}} $</span><span class="sxs-lookup"><span data-stu-id="6a5f4-144">$E\ket{\overline{1}}$</span></span> | <span data-ttu-id="6a5f4-145">$Z _0 eredménye Z_1 $</span><span class="sxs-lookup"><span data-stu-id="6a5f4-145">Result of $Z_0 Z_1$</span></span> | <span data-ttu-id="6a5f4-146">$Z _1 eredménye Z_2 $</span><span class="sxs-lookup"><span data-stu-id="6a5f4-146">Result of $Z_1 Z_2$</span></span> |
| --- | --- | --- | --- | --- |
| <span data-ttu-id="6a5f4-147">$ \boldone $</span><span class="sxs-lookup"><span data-stu-id="6a5f4-147">$\boldone$</span></span> | <span data-ttu-id="6a5f4-148">$ \ket{000}$</span><span class="sxs-lookup"><span data-stu-id="6a5f4-148">$\ket{000}$</span></span> | <span data-ttu-id="6a5f4-149">$ \ket{111}$</span><span class="sxs-lookup"><span data-stu-id="6a5f4-149">$\ket{111}$</span></span> | $+$ | $+$ |
| <span data-ttu-id="6a5f4-150">$X _0 $</span><span class="sxs-lookup"><span data-stu-id="6a5f4-150">$X_0$</span></span> | <span data-ttu-id="6a5f4-151">$ \ket{100}$</span><span class="sxs-lookup"><span data-stu-id="6a5f4-151">$\ket{100}$</span></span> | <span data-ttu-id="6a5f4-152">$ \ket{011}$</span><span class="sxs-lookup"><span data-stu-id="6a5f4-152">$\ket{011}$</span></span> | $-$ | $+$ |
| <span data-ttu-id="6a5f4-153">$X _1 $</span><span class="sxs-lookup"><span data-stu-id="6a5f4-153">$X_1$</span></span> | <span data-ttu-id="6a5f4-154">$ \ket{010}$</span><span class="sxs-lookup"><span data-stu-id="6a5f4-154">$\ket{010}$</span></span> | <span data-ttu-id="6a5f4-155">$ \ket{101}$</span><span class="sxs-lookup"><span data-stu-id="6a5f4-155">$\ket{101}$</span></span> | $-$ | $-$ |
| <span data-ttu-id="6a5f4-156">$X _2 $</span><span class="sxs-lookup"><span data-stu-id="6a5f4-156">$X_2$</span></span> | <span data-ttu-id="6a5f4-157">$ \ket{001}$</span><span class="sxs-lookup"><span data-stu-id="6a5f4-157">$\ket{001}$</span></span> | <span data-ttu-id="6a5f4-158">$ \ket{110}$</span><span class="sxs-lookup"><span data-stu-id="6a5f4-158">$\ket{110}$</span></span> | $+$ | $-$ |

<span data-ttu-id="6a5f4-159">Így a két mérés eredménye egyedi módon meghatározza, hogy melyik bit-flip hiba történt, de nem tárt fel semmilyen információt arról, hogy melyik állapotot kódoljuk.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-159">Thus, the results of the two measurements uniquely determines which bit-flip error occurred, but without revealing any information about which state we encoded.</span></span>
<span data-ttu-id="6a5f4-160">Ezeket az eredményeket egy *szindrómát*hívjuk, és a szindrómát visszaképező hibára utalunk, amely a *helyreállítást*okozta.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-160">We call these results a *syndrome*, and refer to the process of mapping a syndrome back to the error that caused it as *recovery*.</span></span>
<span data-ttu-id="6a5f4-161">Különösen hangsúlyozjuk, hogy a helyreállítás egy *klasszikus* következtetési eljárás, amely a bekövetkezett szindrómát veszi át, és az esetlegesen előforduló hibák kijavításának módját adja vissza.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-161">In particular, we emphasize that recovery is a *classical* inference procedure which takes as its input the syndrome which occurred, and returns a prescription for how to fix any errors that may have occurred.</span></span>

> [!NOTE]
> <span data-ttu-id="6a5f4-162">A fenti bit-flip kód csak egybites tükrözési hibákra képes. Ez egy `X` művelet, amely egyetlen qubit működik.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-162">The bit-flip code above can only correct against single bit-flip errors; that is, an `X` operation acting on a single qubit.</span></span>
> <span data-ttu-id="6a5f4-163">A `X` alkalmazása több qubit esetén az $ \ket{\overline{0}} $ és $ \ket{\overline{1}} $ leképezhető a helyreállítás után.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-163">Applying `X` to more than one qubit will map $\ket{\overline{0}}$ to $\ket{\overline{1}}$ following recovery.</span></span>
> <span data-ttu-id="6a5f4-164">Hasonlóképpen, egy fázis-tükrözési művelet alkalmazása `Z` leképezi a $ \ket{\overline{1}} $ értéket a $-\ket{\overline{1}} $ értékre, és így a $ \ket{\overline{+}} $ \ket{\overline{-}} $-t fogja leképezni.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-164">Similarly, applying a phase flip operation `Z` will map $\ket{\overline{1}}$ to $-\ket{\overline{1}}$, and hence will map $\ket{\overline{+}}$ to $\ket{\overline{-}}$.</span></span>
> <span data-ttu-id="6a5f4-165">Általánosabban a kódok nagyobb számú hiba kezelésére és $Z $ hibák, valamint $X $ hibák kezelésére használhatók.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-165">More generally, codes can be created to handle larger number of errors, and to handle $Z$ errors as well as $X$ errors.</span></span>

<span data-ttu-id="6a5f4-166">A *stabilizátorok formalitásának*lényege, hogy betekintést nyerhetünk a kvantum-hibák kijavításának olyan mértékére, amely az összes kód állapotával azonos módon működik.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-166">The insight that we can describe measurements in quantum error correction that act the same way on all code states, is the essence of the *stabilizer formalism*.</span></span>
<span data-ttu-id="6a5f4-167">A Q # Canon olyan keretrendszert biztosít, amely leírja a stabilizátor-kódok kódolását és dekódolását, valamint leírja, hogyan történik az egyik helyreállítás a hibákból.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-167">The Q# canon provides a framework for describing encoding into and decoding from stabilizer codes, and for describing how one recovers from errors.</span></span>
<span data-ttu-id="6a5f4-168">Ebben a szakaszban ezt a keretrendszert és annak alkalmazását néhány egyszerű kvantum-hiba – a kódok kijavítani.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-168">In this section, we describe this framework and its application to a few simple quantum error-correcting codes.</span></span>

> [!TIP]
> <span data-ttu-id="6a5f4-169">A stabilizátorok formális bevezetésének teljes bemutatása meghaladja a jelen szakasz hatókörét.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-169">A full introduction to the stabilizer formalism is beyond the scope of this section.</span></span>
> <span data-ttu-id="6a5f4-170">A [Gottesman 2009](https://arxiv.org/abs/0904.2557)-re vonatkozó további információkért tekintse meg az olvasók érdeklődését.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-170">We refer readers interested in learning more to [Gottesman 2009](https://arxiv.org/abs/0904.2557).</span></span>

## <a name="representing-error-correcting-codes-in-q"></a><span data-ttu-id="6a5f4-171">Hibakódot jelölő kód kijavítani a Q-ban #</span><span class="sxs-lookup"><span data-stu-id="6a5f4-171">Representing Error Correcting Codes in Q#</span></span> ##

<span data-ttu-id="6a5f4-172">A Q # Canon számos különböző, felhasználó által definiált típust biztosít a hibák kijavított kódjának megadásához:</span><span class="sxs-lookup"><span data-stu-id="6a5f4-172">To help specify error correcting codes, the Q# canon provides several distinct user-defined types:</span></span>

- <span data-ttu-id="6a5f4-173"><xref:microsoft.quantum.errorcorrection.logicalregister> `= Qubit[]`: azt jelzi, hogy a qubits-regisztrációt egy hibajavítási kód kódjának blokkjának kell értelmezni.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-173"><xref:microsoft.quantum.errorcorrection.logicalregister> `= Qubit[]`: Denotes that a register of qubits should be interpreted as the code block of an error-correcting code.</span></span>
- <span data-ttu-id="6a5f4-174"><xref:microsoft.quantum.errorcorrection.syndrome> `= Result[]`: azt jelzi, hogy a mérési eredmények tömbjét úgy kell értelmezni, mint a kód blokkban mért szindrómát.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-174"><xref:microsoft.quantum.errorcorrection.syndrome> `= Result[]`: Denotes that an array of measurement results should be interpreted as the syndrome measured on a code block.</span></span>
- <span data-ttu-id="6a5f4-175"><xref:microsoft.quantum.errorcorrection.recoveryfn> `= (Syndrome -> Pauli[])`: azt jelzi, hogy egy *klasszikus* függvényt kell használni a szindrómák értelmezéséhez, és az alkalmazandó korrekciót kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-175"><xref:microsoft.quantum.errorcorrection.recoveryfn> `= (Syndrome -> Pauli[])`: Denotes that a *classical* function should be used to interpret a syndrome and return a correction that should be applied.</span></span>
- <span data-ttu-id="6a5f4-176"><xref:microsoft.quantum.errorcorrection.encodeop> `= ((Qubit[], Qubit[]) => LogicalRegister)`: azt jelzi, hogy egy művelet qubits az adatok ábrázolásával, valamint a friss Ancilla-qubits, hogy egy hibakódot hozzon létre egy hibajavítási kód alapján.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-176"><xref:microsoft.quantum.errorcorrection.encodeop> `= ((Qubit[], Qubit[]) => LogicalRegister)`: Denotes that an operation takes qubits representing data along with fresh ancilla qubits in order to produce a code block of an error-correcting code.</span></span>
- <span data-ttu-id="6a5f4-177"><xref:microsoft.quantum.errorcorrection.decodeop> `= (LogicalRegister => (Qubit[], Qubit[]))`: azt jelzi, hogy egy művelet lebontja a hibakódot az adatok qubits és a Ancilla használt qubits.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-177"><xref:microsoft.quantum.errorcorrection.decodeop> `= (LogicalRegister => (Qubit[], Qubit[]))`: Denotes than an operation decomposes a code block of an error correcting code into the data qubits and the ancilla qubits used to represent syndrome information.</span></span>
- <span data-ttu-id="6a5f4-178"><xref:microsoft.quantum.errorcorrection.syndromemeasop> `= (LogicalRegister => Syndrome)`: egy olyan műveletet jelöl, amelynek használatával a rendszer egy kód blokkból Kinyeri a szindrómával kapcsolatos információkat anélkül, hogy zavarja a kód által védett állapotot.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-178"><xref:microsoft.quantum.errorcorrection.syndromemeasop> `= (LogicalRegister => Syndrome)`: Denotes an operation that should be used to extract syndrome information from a code block, without disturbing the state protected by the code.</span></span>

<span data-ttu-id="6a5f4-179">Végül a Canon biztosítja a <xref:microsoft.quantum.errorcorrection.qecc> típust a kvantum-hibák meghatározásához szükséges egyéb típusok összegyűjtéséhez.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-179">Finally, the canon provides the <xref:microsoft.quantum.errorcorrection.qecc> type to collect the other types required to define a quantum error-correcting code.</span></span> <span data-ttu-id="6a5f4-180">Az egyes stabilizátorok kvantum-kódjához társítva a kód hossza $n $, a logikai qubits száma $k $, valamint a minimális távolság $d $, amely gyakran kényelmesen csoportosítható a ⟦ $n $, $k $, $d $ ⟧.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-180">Associated with each stabilizer quantum code is the code length $n$, the number $k$ of logical qubits, and the minimum distance $d$, often conveniently grouped together in the notation ⟦$n$, $k$, $d$⟧.</span></span> <span data-ttu-id="6a5f4-181">A <xref:microsoft.quantum.errorcorrection.bitflipcode> függvény például a ⟦ 3, 1, 1 ⟧ bitet definiálja:</span><span class="sxs-lookup"><span data-stu-id="6a5f4-181">For example, the <xref:microsoft.quantum.errorcorrection.bitflipcode> function defines the ⟦3, 1, 1⟧ bit flip code:</span></span>

```qsharp
let encodeOp = EncodeOp(BitFlipEncoder);
let decodeOp = DecodeOp(BitFlipDecoder);
let syndMeasOp = SyndromeMeasOp(MeasureStabilizerGenerators([
    [PauliZ, PauliZ, PauliI],
    [PauliI, PauliZ, PauliZ]
], _, MeasureWithScratch));
let code = QECC(encodeOp, decodeOp, syndMeasOp);
```

<span data-ttu-id="6a5f4-182">Figyelje meg, hogy a `QECC` típus *nem* tartalmaz helyreállítási funkciót.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-182">Notice that the `QECC` type does *not* include a recovery function.</span></span>
<span data-ttu-id="6a5f4-183">Ez lehetővé teszi, hogy megváltoztassuk a hibák kijavításához használt helyreállítási funkciót, a kód definíciójának módosítása nélkül. Ez a képesség különösen hasznos, ha a jellemzési mérések származó visszajelzéseket a helyreállítás által feltételezett modellbe foglalja.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-183">This allows us to change the recovery function that is used in correcting errors without changing the definition of the code itself; this ability is in particular useful when incorporating feedback from characterization measurements into the model assumed by recovery.</span></span>

<span data-ttu-id="6a5f4-184">Ha a kód ily módon van definiálva, a hibákból való helyreállításhoz a <xref:microsoft.quantum.errorcorrection.recover> műveletet is használhatja:</span><span class="sxs-lookup"><span data-stu-id="6a5f4-184">Once a code is defined in this way, we can use the <xref:microsoft.quantum.errorcorrection.recover> operation to recover from errors:</span></span>

```qsharp
let code = BitFlipCode();
let fn = BitFlipRecoveryFn();
let X0 = ApplyPauli([PauliX, PauliI, PauliI], _);
using (scratch = Qubit[nScratch]) {
    let logicalRegister = encode(data, scratch);
    // Cause an error.
    X0(logicalRegister);
    Recover(code, fn, logicalRegister);
    let (decodedData, decodedScratch) = decode(logicalRegister);
    ApplyToEach(Reset, decodedScratch);
}
```

<span data-ttu-id="6a5f4-185">Ezt részletesebben is megvizsgáljuk a [bit flip Code-mintában](https://github.com/microsoft/Quantum/tree/master/samples/error-correction/bit-flip-code).</span><span class="sxs-lookup"><span data-stu-id="6a5f4-185">We explore this in more detail in the [bit flip code sample](https://github.com/microsoft/Quantum/tree/master/samples/error-correction/bit-flip-code).</span></span>

<span data-ttu-id="6a5f4-186">A bit-flip code-on kívül a Q # Canon az [öt qubit tökéletes kód](https://arxiv.org/abs/quant-ph/9602019)megvalósításával és a [Seven-qubit kóddal](https://arxiv.org/abs/quant-ph/9705052)van ellátva, amelyek közül mindkettő kiválaszthat egy tetszőleges, egyetlen qubit hibát.</span><span class="sxs-lookup"><span data-stu-id="6a5f4-186">Aside from the bit-flip code, the Q# canon is provided with implementations of the [five-qubit perfect code](https://arxiv.org/abs/quant-ph/9602019), and the [seven-qubit code](https://arxiv.org/abs/quant-ph/9705052), both of which can correct an arbitrary single-qubit error.</span></span>
