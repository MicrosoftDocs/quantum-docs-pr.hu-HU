---
title: 'Quantum-algoritmusok a Q-ban #'
description: Ismerje meg az alapvető kvantum-számítási algoritmusokat, beleértve az amplitúdó-erősítést, a Fourier-transzformációt, a drapériát és a Beauregard-kiegészítéseket, valamint a fázisok
author: QuantumWriter
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.algorithms
ms.openlocfilehash: 8b8a9019e8bc419f42b0c6f7558354d19a157917
ms.sourcegitcommit: d61b388651351e5abd4bfe7a672e88b84a6697f8
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 03/15/2020
ms.locfileid: "79402850"
---
# <a name="quantum-algorithms"></a><span data-ttu-id="528ea-103">Quantum algoritmusok</span><span class="sxs-lookup"><span data-stu-id="528ea-103">Quantum Algorithms</span></span> #

## <a name="amplitude-amplification"></a><span data-ttu-id="528ea-104">Amplitúdó-erősítés</span><span class="sxs-lookup"><span data-stu-id="528ea-104">Amplitude Amplification</span></span> ##

<span data-ttu-id="528ea-105">Az *amplitúdó-erősítés* a kvantum-számítástechnika alapvető eszközeinek egyike.</span><span class="sxs-lookup"><span data-stu-id="528ea-105">*Amplitude Amplification* is one of the fundamental tools of Quantum Computing.</span></span> <span data-ttu-id="528ea-106">Ez az alapvető elképzelés, hogy a megalapozott kutatás, az amplitúdó-becslés és számos Quantum Machine learning algoritmus.</span><span class="sxs-lookup"><span data-stu-id="528ea-106">It is the fundamental idea that underlies Grover's search, amplitude estimation and many quantum machine learning algorithms.</span></span>  <span data-ttu-id="528ea-107">Számos változat létezik, és a Q #-ban egy általános verziót biztosítunk, amely a részleges reflexiókkal ellátott, részben az alkalmazás legszélesebb területét lehetővé tevő, részleges reflexiókkal rendelkező, általánosan elérhető verzión alapul.</span><span class="sxs-lookup"><span data-stu-id="528ea-107">There are many variants, and in Q# we provide a general version based on Oblivious Amplitude Amplification with Partial Reflections to allow for the widest area of application.</span></span>

<span data-ttu-id="528ea-108">Az amplitúdó-erősítés mögötti központi elképzelés az, hogy kiterjesztheti a kívánt eredmény valószínűségét a reflexiók sorrendjének végrehajtásával.</span><span class="sxs-lookup"><span data-stu-id="528ea-108">The central idea behind amplitude amplification is to amplify the probability of a desired outcome occurring by performing a sequence of reflections.</span></span>  <span data-ttu-id="528ea-109">Ezek a reflexiók a kezdeti állapotot közelebb viszik a kívánt cél állapothoz, amelyet gyakran jelölt állapotnak nevezünk.</span><span class="sxs-lookup"><span data-stu-id="528ea-109">These reflections rotate the initial state closer towards a desired target state, often called a marked state.</span></span>  <span data-ttu-id="528ea-110">Pontosabban, ha a kiindulási állapot jelölésének valószínűsége jelölt állapotban van, a $ \sin ^ 2 (\theta) $, majd az amplitúdó-$m erősítés alkalmazása után a siker valószínűsége $ \sin ^ 2 ((2m + 1) \theta) $ lesz.</span><span class="sxs-lookup"><span data-stu-id="528ea-110">Specifically, if the probability of measuring the initial state to be in a marked state is $\sin^2(\theta)$ then after applying amplitude amplification $m$ times the probability of success becomes $\sin^2((2m+1)\theta)$.</span></span>  <span data-ttu-id="528ea-111">Ez azt jelenti, hogy ha a $ \theta = \ Pi/[2 (2n + 1)] $ értéket adja meg a $ $n $ értéknél, akkor az amplitúdó-erősítés képes növelni a siker valószínűségét $100\\% $ után $n $ iterációs amplitúdó-erősítéssel.</span><span class="sxs-lookup"><span data-stu-id="528ea-111">This means that if $\theta = \pi/[2(2n+1)]$ for some value of $n$ then amplitude amplification is capable of boosting the probability of success to $100\\%$ after $n$ iterations of amplitude amplification.</span></span>  <span data-ttu-id="528ea-112">Mivel a $ \theta = \sin ^{-1}(\sqrt{\Pr (Success)}) $ Ez azt jelenti, hogy a sikeres determinisztikus módon beszerzéséhez szükséges Ismétlések száma a következő, véletlenszerű mintavételezéssel nem determinisztikus módon megkereséséhez szükséges számú, a vártnál nagyobb számú.</span><span class="sxs-lookup"><span data-stu-id="528ea-112">Since $\theta = \sin^{-1}(\sqrt{\Pr(success)})$ this means that the number of iterations needed to obtain a success deterministically is quadratically lower than the expected number needed to find a marked state non-deterministically using random sampling.</span></span>

<span data-ttu-id="528ea-113">Az amplitúdó-erősítés minden iterációja megköveteli, hogy két reflexiós operátor legyen megadva.</span><span class="sxs-lookup"><span data-stu-id="528ea-113">Each iteration of Amplitude amplification requires that two reflection operators be specified.</span></span> <span data-ttu-id="528ea-114">Pontosabban, ha a $Q $ érték az amplitúdó erősítésének iterációja, és $P _0 $ egy kivetítő operátor a kezdeti alterületre, és $P _1 $ a kivetítő a megjelölt alterületre, majd $Q =-(\boldone-2P_0) (\boldone-2P_1) $.</span><span class="sxs-lookup"><span data-stu-id="528ea-114">Specifically, if $Q$ is the amplitude amplification iterate and $P_0$ is a projector operator onto the initial subspace and $P_1$ is the projector onto the marked subspace then $Q=-(\boldone-2P_0)(\boldone -2P_1)$.</span></span>  <span data-ttu-id="528ea-115">Ne felejtse el, hogy a kivetítő olyan Hermitian operátor, amely eigenvalues $ + $1 és $0 $ értékű, és ennek eredményeképpen a $ (\boldone-2P_0) $ érték egységes, mert olyan eigenvalues rendelkezik, amely az egység gyökere (ebben az esetben a $ \pm $1).</span><span class="sxs-lookup"><span data-stu-id="528ea-115">Recall that a projector is a Hermitian operator that has eigenvalues $+1$ and $0$ and as a result $(\boldone -2P_0)$ is unitary because it has eigenvalues that are roots of unity (in this case $\pm 1$).</span></span> <span data-ttu-id="528ea-116">Tegyük fel például, hogy a kiindulási állapotú $H ^ {\otimes n} \ket{0}$ és a megjelölt állapot $ \ket{m} $, $P _0 = H ^ {\otimes n} \ket{0}\bra{0}H ^ {\otimes n} $ és $P _1 = \ket{m}\bra{m} $.</span><span class="sxs-lookup"><span data-stu-id="528ea-116">As an example, consider the case of Grover's search with initial state $H^{\otimes n} \ket{0}$ and marked state $\ket{m}$, $P_0 = H^{\otimes n}\ket{0}\bra{0}H^{\otimes n}$ and $P_1= \ket{m}\bra{m}$.</span></span>  <span data-ttu-id="528ea-117">Az amplitúdó-erősítés legtöbb alkalmazásában a $P _0 $ egy kezdeti állapotba kerül, amely azt jelenti, hogy $P _0 = \boldone-2 \ ket {\ PSI} \ melltartó {\ PSI} $ egyes Vector $ \ket{\psi} $; a feledékenység amplitúdó-amplication $P _0 $ esetében azonban jellemzően sok kvantum-állapotot fog kiszolgálni (azaz a $P _0 $ $ + $1 sajátérték többszöröse meghaladja a $1 $-ot).</span><span class="sxs-lookup"><span data-stu-id="528ea-117">In most applications of amplitude amplification $P_0$ will be a projector onto an initial state meaning that $P_0 = \boldone -2\ket{\psi}\bra{\psi}$ for some vector $\ket{\psi}$; however, for oblivious amplitude amplication $P_0$ will typically project onto many quantum states (i.e. the multiplicity of the $+1$ eigenvalue of $P_0$ is greater than $1$).</span></span>

<span data-ttu-id="528ea-118">Az amplitúdó-erősítés mögötti logika közvetlenül a $Q $ Eigen-felbomlásával következik.</span><span class="sxs-lookup"><span data-stu-id="528ea-118">The logic behind amplitude amplification follows directly from the eigen-decomposition of $Q$.</span></span>  <span data-ttu-id="528ea-119">Pontosabban, a kezdeti állapotú, nem nulla szintű támogatással rendelkező $Q $ eigenvectors az $P _0 $ és $P _1 $ eigenvectors $ + $1-as lineáris kombinációját jeleníti meg.</span><span class="sxs-lookup"><span data-stu-id="528ea-119">Specifically, the eigenvectors of $Q$ that the initial state has non-zero support over can be shown to be linear combinations of the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="528ea-120">Pontosabban, az amplitúdó-erősítés kezdeti állapota (feltételezve, hogy a $ + $1 eigenvector $P _0 $) írható $ $ \ket{\psi} = \frac{-i}{\sqrt{2}} \left (e ^ {i\theta} \ ket {\ psi_ +} + e ^ {-i\theta} \ ket {\ psi_-} \right), $ $, ahol a $ \ket{\ psi_ \pm} $ eigenvectors $Q $ eigenvalues $e ^ {\pm 2i \ Théta} $, és csak a $ + $1 eigenvectors támogatja a $P _0 $ és $P _1 $.</span><span class="sxs-lookup"><span data-stu-id="528ea-120">Specifically, the initial state for amplitude amplification (assuming it is a $+1$ eigenvector of $P_0$) can be written as $$ \ket{\psi}=\frac{-i}{\sqrt{2}}\left(e^{i\theta}\ket{\psi_+} + e^{-i\theta}\ket{\psi_-}\right), $$ where $\ket{\psi_\pm}$ are eigenvectors of $Q$ with eigenvalues $e^{\pm  2i\theta}$ and only have support on the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="528ea-121">Az a tény, hogy a eigenvalues $e ^ {\pm i \theta} $, azt feltételezi, hogy a kezelő $Q $ elforgatást hajt végre a két kivetítő által meghatározott kétdimenziós alterületen, valamint a kezdeti állapotot, ahol a forgási szög $2 \ THÉTA $.</span><span class="sxs-lookup"><span data-stu-id="528ea-121">The fact that the eigenvalues are $e^{\pm i \theta}$ implies that the operator $Q$ performs a rotation in a two-dimensional subspace specified by the two projectors and the initial state where the rotation angle is $2\theta$.</span></span>  <span data-ttu-id="528ea-122">Ezért a siker valószínűsége $m $ iterációk után $Q $ a sikerességi valószínűség: $ \sin ^ 2 ([2m + 1] \theta) $.</span><span class="sxs-lookup"><span data-stu-id="528ea-122">This is why after $m$ iterations of $Q$ the success probability is $\sin^2([2m+1]\theta)$.</span></span>

<span data-ttu-id="528ea-123">Egy másik hasznos tulajdonság, amely abból ered, hogy a sajátérték $ \theta $ közvetlenül kapcsolódik annak valószínűségéhez, hogy a kezdeti állapot meg lesz jelölve (abban az esetben, ha $P _0 $ egy kivetítő csak a kezdeti állapotra).</span><span class="sxs-lookup"><span data-stu-id="528ea-123">Another useful property that comes out of this is that the eigenvalue $\theta$ is directly related to probability that the initial state would be marked (in the case where $P_0$ is a projector onto only the initial state).</span></span>  <span data-ttu-id="528ea-124">Mivel a eigenphases $Q $ a $2 \ THÉTA = 2 \ Sin ^{-1}(\sqrt{\Pr (Success)}) $, akkor a következő lépés az, hogy ha a fázis-becslést a $Q $ értékre alkalmazzuk, akkor megtudhatjuk, hogy sikeres volt-e egy egységes kvantum-eljárás.</span><span class="sxs-lookup"><span data-stu-id="528ea-124">Since the eigenphases of $Q$ are $2\theta = 2\sin^{-1}(\sqrt{\Pr(success)})$ it then follows that if we apply phase estimation to $Q$ then we can learn the probability of success for a unitary quantum procedure.</span></span>  <span data-ttu-id="528ea-125">Ez azért hasznos, mert a kvantum-eljáráshoz tartozó, másodfokú módon kevesebb alkalmazásra van szükség, hogy megismerje a siker valószínűségét, mint egyébként.</span><span class="sxs-lookup"><span data-stu-id="528ea-125">This is useful because it requires quadratically fewer applications of the quantum procedure to learn the success probability than would otherwise be needed.</span></span>

<span data-ttu-id="528ea-126">A Q # amplitúdó-erősítést mutat be a feledékenység amplitúdó-erősítésének specializációja.</span><span class="sxs-lookup"><span data-stu-id="528ea-126">Q# introduces amplitude amplification as a specialization of oblivious amplitude amplification.</span></span>  <span data-ttu-id="528ea-127">A feledékenység amplitúdó-erősítése ezt a monikert keresi, mert a kezdeti eigenspace kivetítőnek nem kell kivetítőnek lennie a kezdeti állapothoz.</span><span class="sxs-lookup"><span data-stu-id="528ea-127">Oblivious amplitude amplification earns this moniker because the projector onto the initial eigenspace need not be a projector onto the initial state.</span></span>  <span data-ttu-id="528ea-128">Ebben az értelemben a protokoll a kezdeti állapotba kerül.</span><span class="sxs-lookup"><span data-stu-id="528ea-128">In this sense, the protocol is oblivious to the initial state.</span></span>  <span data-ttu-id="528ea-129">A feledékenység amplitúdó-erősítésének legfontosabb alkalmazása az egységes Hamilton-szimulációs módszerek bizonyos *lineáris kombinációjában* van, amelyben a kezdeti állapot ismeretlen, de a szimulált Ancilla-regiszterrel együtt válik elérhetővé a szimulációs protokollban.</span><span class="sxs-lookup"><span data-stu-id="528ea-129">The key application of oblivious amplitude amplification is in certain *linear combinations of unitary* Hamiltonian simulation methods, wherein the initial state is unknown but becomes entangled with an ancilla register in the simulation protocol.</span></span>  <span data-ttu-id="528ea-130">Ha a Ancilla-regisztrációt rögzített értékre kell mérni, tegyük fel, hogy az $0 $, majd az ilyen szimulációs módszerek alkalmazza a kívánt egységes átalakítást a fennmaradó qubits (ezt a rendszerregisztrációnak nevezik).</span><span class="sxs-lookup"><span data-stu-id="528ea-130">If this ancilla register were to be measured to be a fixed value, say $0$, then such simulation methods apply the desired unitary transformation to the remaining qubits (called the system register).</span></span>  <span data-ttu-id="528ea-131">Az összes többi mérési eredmény azonban sikertelen.</span><span class="sxs-lookup"><span data-stu-id="528ea-131">All other measurement outcomes lead to failure however.</span></span>  <span data-ttu-id="528ea-132">A feledékenység amplitúdó-erősítése lehetővé teszi a mérés sikerességének valószínűségét a $100\\% $ értékre a fenti indokok használatával.</span><span class="sxs-lookup"><span data-stu-id="528ea-132">Oblivious amplitude amplification allows the probability of success of this measurement to be boosted to $100\\%$ using the above reasoning.</span></span>  <span data-ttu-id="528ea-133">Emellett a hagyományos amplitúdó-erősítés abban az esetben is megfelel, ha a rendszer regisztrálása üres.</span><span class="sxs-lookup"><span data-stu-id="528ea-133">Further, ordinary amplitude amplification corresponds to the case where the system register is empty.</span></span>  <span data-ttu-id="528ea-134">Ezért a Q # a megfeledkezett az amplitúdó erősítését használja az alapvető amplitúdó-erősítési alrutinként.</span><span class="sxs-lookup"><span data-stu-id="528ea-134">This is why Q# uses oblivious amplitude amplification as its fundamental amplitude amplification subroutine.</span></span>

<span data-ttu-id="528ea-135">Az általános rutin (`AmpAmpObliviousByReflectionPhases`) két regisztert tartalmaz, amelyeket `ancillaRegister` és `systemRegister`hívunk.</span><span class="sxs-lookup"><span data-stu-id="528ea-135">The general routine (`AmpAmpObliviousByReflectionPhases`) has two registers that we call `ancillaRegister` and `systemRegister`.</span></span> <span data-ttu-id="528ea-136">Emellett két Oracle-t is elfogad a szükséges tükrözésekhez.</span><span class="sxs-lookup"><span data-stu-id="528ea-136">It also accepts two oracles for the necessary reflections.</span></span> <span data-ttu-id="528ea-137">A `ReflectionOracle` csak a `ancillaRegister` működik, míg a `ObliviousOracle` mindkét regiszteren közösen működik.</span><span class="sxs-lookup"><span data-stu-id="528ea-137">The `ReflectionOracle` acts only on the `ancillaRegister` while the `ObliviousOracle` acts jointly on both registers.</span></span> <span data-ttu-id="528ea-138">A `ancillaRegister`ba való bevitelt inicializálni kell az első reflexiós operátor ($ \boldone-2P_1 $) 1 eigenstate.</span><span class="sxs-lookup"><span data-stu-id="528ea-138">The input to `ancillaRegister` must be initialized to a -1 eigenstate of the first reflection operator $\boldone -2P_1$.</span></span>

<span data-ttu-id="528ea-139">Az Oracle általában a $ \ket{0...0} $ számítási alapon készíti el az állapotot.</span><span class="sxs-lookup"><span data-stu-id="528ea-139">Typically, the oracle prepares the state in the computational basis $\ket{0...0}$.</span></span> <span data-ttu-id="528ea-140">A megvalósítás során a `ancillaRegister` egy qubit (`flagQubit`) áll, amely a `stateOracle` és a többi kívánt ancillas vezérli.</span><span class="sxs-lookup"><span data-stu-id="528ea-140">In our implementation, the `ancillaRegister` consistes of one qubit (`flagQubit`) that controls the `stateOracle` and the rest of the desired ancillas.</span></span> <span data-ttu-id="528ea-141">A `stateOracle` akkor lesz alkalmazva, ha a `flagQubit` $ \ket{1}$.</span><span class="sxs-lookup"><span data-stu-id="528ea-141">The `stateOracle` is applied when the `flagQubit` is $\ket{1}$.</span></span>

<span data-ttu-id="528ea-142">Az egyik lehetséges, hogy az Oracle-`StateOracle` és a `ObliviousOracle` a `AmpAmpObliviousByOraclePhases`hívása helyett a reflexiók helyett.</span><span class="sxs-lookup"><span data-stu-id="528ea-142">One may also provide oracles `StateOracle` and `ObliviousOracle` instead of reflections via a call to `AmpAmpObliviousByOraclePhases`.</span></span>

<span data-ttu-id="528ea-143">Ahogy említettük, a hagyományos amplitúdó-erősítés csak egy különleges eset a rutinok esetében, ahol `ObliviousOracle` az identitás operátora, és nincsenek rendszerszintű qubits (azaz `systemRegister` üresek).</span><span class="sxs-lookup"><span data-stu-id="528ea-143">As mentioned, traditional Amplitude Amplification is just a special case of these routines where `ObliviousOracle` is the identity operator and there are no system qubits (i.e., `systemRegister` is empty).</span></span> <span data-ttu-id="528ea-144">Ha részleges reflexiók (pl. a a (a "a", a, `AmpAmpPhasesStandard` a, a, a, a, a, a, a vagy a a, a a "</span><span class="sxs-lookup"><span data-stu-id="528ea-144">If you wish to obtain phases for partial reflections (e.g., for Grover search), the function `AmpAmpPhasesStandard` is available.</span></span> <span data-ttu-id="528ea-145">A következő témakörben talál `DatabaseSearch.qs`t a a a a a a a a a a a a a a a a</span><span class="sxs-lookup"><span data-stu-id="528ea-145">Please refer to `DatabaseSearch.qs` for a sample implementation of Grover's algorithm.</span></span>

<span data-ttu-id="528ea-146">Az qubit-elforgatási fázisokat a [G.H. Low, I. L.](https://arxiv.org/abs/1707.05391)című cikkben leírtak szerint összekapcsoljuk a reflexiós operátor fázisaival.</span><span class="sxs-lookup"><span data-stu-id="528ea-146">We relate the single-qubit rotation phases to the reflection operator phases as described in the paper by [G.H. Low, I. L. Chuang](https://arxiv.org/abs/1707.05391).</span></span> <span data-ttu-id="528ea-147">A rögzített pontokra vonatkozó fázisok részletesen szerepelnek a [Yoder, az alacsony és](https://arxiv.org/abs/1409.3305) a leveles, valamint az [alacsony, Yoder és](https://arxiv.org/abs/1603.03996)fázisokban.</span><span class="sxs-lookup"><span data-stu-id="528ea-147">The fixed point phases that are used are detailed in [Yoder, Low and Chuang](https://arxiv.org/abs/1409.3305) along with the phases in [Low, Yoder and Chuang](https://arxiv.org/abs/1603.03996).</span></span>

<span data-ttu-id="528ea-148">A háttérben elindulhat a [standard amplitúdó-erősítés](https://arxiv.org/abs/quant-ph/0005055) , majd bevezethető az ismeretlen [amplitúdó-erősítéssel](https://arxiv.org/abs/1312.1414) és az [alacsony és a](https://arxiv.org/abs/1610.06546)facsoportban ismertetett általánosításokkal.</span><span class="sxs-lookup"><span data-stu-id="528ea-148">For background, you could start from [Standard Amplitude Amplification](https://arxiv.org/abs/quant-ph/0005055) then move to an introduction to [Oblivious Amplitude Amplification](https://arxiv.org/abs/1312.1414) and finally generalizations presented in [Low and Chuang](https://arxiv.org/abs/1610.06546).</span></span> <span data-ttu-id="528ea-149">A teljes terület áttekintését (ahogy a Hamilton szimulációhoz kapcsolódik) a [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf)adta meg.</span><span class="sxs-lookup"><span data-stu-id="528ea-149">A nice overview presentation of this entire area (as it relates to Hamiltonian Simulation) was given by [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf).</span></span>

## <a name="quantum-fourier-transform"></a><span data-ttu-id="528ea-150">Quantum Fourier-transzformáció</span><span class="sxs-lookup"><span data-stu-id="528ea-150">Quantum Fourier Transform</span></span> ##

<span data-ttu-id="528ea-151">A Fourier-transzformáció a klasszikus elemzés alapvető eszköze, és ugyanolyan fontos a kvantum-számításokhoz.</span><span class="sxs-lookup"><span data-stu-id="528ea-151">The Fourier transform is a fundamental tool of classical analysis and is just as important for quantum computations.</span></span>
<span data-ttu-id="528ea-152">Emellett a *Quantum Fourier-transzformáció* (QFT) hatékonysága messze felülmúlja a klasszikus gépen elérhetővé tenni kívánt első eszközök egyikét.</span><span class="sxs-lookup"><span data-stu-id="528ea-152">In addition, the efficiency of the *quantum Fourier transform* (QFT) far surpasses what is possible on a classical machine making it one of the first tools of choice when designing a quantum algorithm.</span></span>

<span data-ttu-id="528ea-153">A QFT hozzávetőleges általánosításával biztosítjuk a <xref:microsoft.quantum.canon.approximateqft> műveletet, amely lehetővé teszi a további optimalizálást olyan metszések esetében, amelyek nem feltétlenül szükségesek a kívánt algoritmus pontosságához.</span><span class="sxs-lookup"><span data-stu-id="528ea-153">As an approximate generalization of the QFT, we provide the <xref:microsoft.quantum.canon.approximateqft> operation that allows for further optimizations by pruning rotations that aren't strictly necessary for the desired algorithmic accuracy.</span></span>
<span data-ttu-id="528ea-154">A hozzávetőleges QFT működéséhez a dyadic $Z $-forgási művelet <xref:microsoft.quantum.intrinsic.rfrac> és a <xref:microsoft.quantum.intrinsic.h> művelet szükséges.</span><span class="sxs-lookup"><span data-stu-id="528ea-154">The approximate QFT requires the dyadic $Z$-rotation operation <xref:microsoft.quantum.intrinsic.rfrac> as well as the <xref:microsoft.quantum.intrinsic.h> operation.</span></span>
<span data-ttu-id="528ea-155">A bemenet és a kimenet a big endian kódolásban---, azaz az `0` indexet tartalmazó qubit a bináris egész számok bal szélső (legmagasabb) részében kódolva.</span><span class="sxs-lookup"><span data-stu-id="528ea-155">The input and output are assumed to be encoded in big endian encoding---that is, the qubit with index `0` is encoded in the left-most (highest) bit of the binary integer representation.</span></span>
<span data-ttu-id="528ea-156">Ez a [két](xref:microsoft.quantum.concepts.dirac)pontra van igazítva, mivel a $ \ket{100}$ állapotú három qubits regisztrálása megfelel a $ \ket{1}$ állapotú $q _0 $ értéknek, míg a $q _1 $ és a $q _2 $ érték a $ \ket{0}$ állapotban van.</span><span class="sxs-lookup"><span data-stu-id="528ea-156">This aligns with [ket notation](xref:microsoft.quantum.concepts.dirac), as a register of three qubits in the state $\ket{100}$ corresponds to $q_0$ being in the state $\ket{1}$ while $q_1$ and $q_2$ are both in state $\ket{0}$.</span></span>
<span data-ttu-id="528ea-157">A (z) $a $ közelítési paraméter meghatározza a $Z $-Forgások, azaz $a \in [0.. n] $ metszési szintjét.</span><span class="sxs-lookup"><span data-stu-id="528ea-157">The approximation parameter $a$ determines the pruning level of the $Z$-rotations, i.e., $a \in [0..n]$.</span></span>
<span data-ttu-id="528ea-158">Ebben az esetben minden $Z $-Forgások $2 \ pi/2 ^ k $, ahol $k > a $ el lett távolítva a QFT áramkörből.</span><span class="sxs-lookup"><span data-stu-id="528ea-158">In this case all $Z$-rotations $2\pi/2^k$ where $k > a$ are removed from the QFT circuit.</span></span>
<span data-ttu-id="528ea-159">Ismert, hogy $k \ge \ log_2 (n) + \ log_2 (1/\epsilon) + $3.</span><span class="sxs-lookup"><span data-stu-id="528ea-159">It is known that for $k \ge \log_2(n) + \log_2(1 / \epsilon) + 3$.</span></span> <span data-ttu-id="528ea-160">egy kötve $\\| \operatorname{QFT} – \operatorname{AQFT} \\| < \epsilon $.</span><span class="sxs-lookup"><span data-stu-id="528ea-160">one can bound $\\| \operatorname{QFT} - \operatorname{AQFT} \\| < \epsilon$.</span></span>
<span data-ttu-id="528ea-161">Itt $\\| \cdot\\| $ az operátori norma, amely ebben az esetben a legnagyobb [sajátérték](xref:microsoft.quantum.concepts.matrix-advanced) ($ (\Operatorname{QFT}-\operatorname{AQFT}) (\Operatorname{QFT}-\operatorname{AQFT}) ^ \dagger $.</span><span class="sxs-lookup"><span data-stu-id="528ea-161">Here $\\|\cdot\\|$ is the operator norm which in this case is the square root of the largest [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) of $(\operatorname{QFT} - \operatorname{AQFT})(\operatorname{QFT} - \operatorname{AQFT})^\dagger$.</span></span>

## <a name="arithmetic"></a><span data-ttu-id="528ea-162">Aritmetikai</span><span class="sxs-lookup"><span data-stu-id="528ea-162">Arithmetic</span></span> ##

<span data-ttu-id="528ea-163">Csakúgy, mint a aritmetika a klasszikus számítástechnika központi szerepét játssza, a kvantum-számítástechnika is nélkülözhetetlen.</span><span class="sxs-lookup"><span data-stu-id="528ea-163">Just as arithmetic plays a central role in classical computing, it is also indispensable in quantum computing.</span></span>  <span data-ttu-id="528ea-164">Az algoritmusok, például a rövid faktoring algoritmus, a Quantum szimulációs módszerek, valamint számos oracular-algoritmus koherens aritmetikai műveletekre támaszkodnak.</span><span class="sxs-lookup"><span data-stu-id="528ea-164">Algorithms such as Shor's factoring algorithm, quantum simulation methods as well as many oracular algorithms rely upon coherent arithmetic operations.</span></span>  <span data-ttu-id="528ea-165">Az aritmetikai folyamatok többsége a Quantum vipera-áramkörökre épül.</span><span class="sxs-lookup"><span data-stu-id="528ea-165">Most approaches to arithmetic build upon quantum adder circuits.</span></span>  <span data-ttu-id="528ea-166">A legegyszerűbb kiegészítés egy klasszikus input $b $, és hozzáadja az értéket egy olyan kvantum-állapothoz, amely egy egész $ \ket{a} $ számot tárol.</span><span class="sxs-lookup"><span data-stu-id="528ea-166">The simplest adder takes a classical input $b$ and adds the value to a quantum state holding an integer $\ket{a}$.</span></span>  <span data-ttu-id="528ea-167">Matematikailag, a kiegészítőkre (amit a $ \operatorname{Add} (b) $ for klasszikus input $b $ esetében jelölünk</span><span class="sxs-lookup"><span data-stu-id="528ea-167">Mathematically, the adder (which we denote $\operatorname{Add}(b)$ for classical input $b$) has the property that</span></span>

<span data-ttu-id="528ea-168">$ $ \operatorname{Add} (b) \ket{a} = \ket{a + b}.</span><span class="sxs-lookup"><span data-stu-id="528ea-168">$$ \operatorname{Add}(b)\ket{a}=\ket{a + b}.</span></span>
<span data-ttu-id="528ea-169">$ $ Ez az alapszintű kiegészítési áramkör nagyobb a növekménynél, mint a kiegészítőkre.</span><span class="sxs-lookup"><span data-stu-id="528ea-169">$$ This basic adder circuit is more of an incrementer than an adder.</span></span>
<span data-ttu-id="528ea-170">Egy olyan kiegészítőkre konvertálható, amely két kvantum bemenettel rendelkezik a $ $ \operatorname{Add}\ket{a}\ket{b} = \ket{a}\ket{a + b} használatával. $ $ $n $ vezérelt alkalmazásokat használ a \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left (\operatorname{Add} (1) \right) \Lambda\_{a\_1} \left (\operatorname{Add} (2) \right) \Lambda\_{a\_2} \left (\operatorname{Add} (4) \right) \cdots \Lambda\_{a\_{n-1}} \left (\ operatorname {Add} ({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{align} $n $ bites egész számra $a $ és $b $, valamint a többtényezős $2 ^ n $ értéket.</span><span class="sxs-lookup"><span data-stu-id="528ea-170">It can be converted into an adder that has two quantum inputs via $$ \operatorname{Add}\ket{a}\ket{b}=\ket{a}\ket{a+b}, $$ using $n$ controlled applications of adders of the form \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left(\operatorname{Add}(1) \right) \Lambda\_{a\_1} \left(\operatorname{Add}(2) \right) \Lambda\_{a\_2} \left(\operatorname{Add}(4) \right) \cdots \Lambda\_{a\_{n-1}} \left(\operatorname{Add}({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{align} for $n$-bit integers $a$ and $b$ and addition modulo $2^n$.</span></span>  <span data-ttu-id="528ea-171">Ne felejtse el, hogy a $ \Lambda\_x (A) $ jelölés a ($A $) művelethez a művelet ellenőrzött verziójára vonatkozik a qubit $x $ as vezérlővel.</span><span class="sxs-lookup"><span data-stu-id="528ea-171">Recall that the notation $\Lambda\_x(A)$ refers, for any operation $A$, to the controlled version of that operation with the qubit $x$ as control.</span></span>

<span data-ttu-id="528ea-172">Hasonlóképpen, a klasszikusan vezérelt szorzás (amely moduláris, amely elengedhetetlen a rövid faktoring algoritmushoz) az ellenőrzött kiegészítések hasonló sorozatával végezhető el: \begin{align} \operatorname{Mult} (a) \ket{x}\ket{b} & = \Lambda\_{x\_0} \left (\operatorname{Add} (2 ^ 0 a) \right) \Lambda\_{a\_1} \left (\operatorname{Add} (2 ^ 1a) \right) \Lambda\_{a\_2} \left (\operatorname{Add} (2 ^ 2 a) \right) \cdots \Lambda\_{x\_{ n-1}} \left (\operatorname{Add} ({2 ^ {n-1}} a) \right) \ket{x}\ket{b} \\\\ & = \ket{x}\ket{b + AX}.</span><span class="sxs-lookup"><span data-stu-id="528ea-172">Similarly, classically controlled multiplication (a modular form of which is essential for Shor's factoring algorithm) can be performed by using a similar series of controlled  additions: \begin{align} \operatorname{Mult}(a)\ket{x}\ket{b} & = \Lambda\_{x\_0}\left(\operatorname{Add}(2^0 a)\right) \Lambda\_{a\_1}\left(\operatorname{Add}(2^1a)\right) \Lambda\_{a\_2}\left(\operatorname{Add}(2^2 a)\right) \cdots \Lambda\_{x\_{n-1}} \left(\operatorname{Add}({2^{n-1}}a) \right)\ket{x}\ket{b} \\\\ & = \ket{x}\ket{b+ax}.</span></span>
<span data-ttu-id="528ea-173">a \end{align} olyan finomságokkal rendelkezik, amelyek a fenti $ \operatorname{Mult} $ definíció alapján megfigyelhető kvantum-számítógépeken is előfordulhatnak.</span><span class="sxs-lookup"><span data-stu-id="528ea-173">\end{align} There is a subtlety with multiplication on quantum computers that you may notice from the definition of $\operatorname{Mult}$ above.</span></span>  <span data-ttu-id="528ea-174">A hozzáadástól eltérően az áramkör Quantum verziója a bemeneti regiszter helyett egy kiegészítő regisztrációban tárolja a bemenetek termékét.</span><span class="sxs-lookup"><span data-stu-id="528ea-174">Unlike addition, the quantum version of this circuit stores the product of the inputs in an ancillary register rather than in the input register.</span></span>  <span data-ttu-id="528ea-175">Ebben a példában a regiszter $b $ értékkel van inicializálva, de általában a nulla értéket fogja megkezdeni.</span><span class="sxs-lookup"><span data-stu-id="528ea-175">In this example, the register is initialized with the value $b$, but typically it will start holding the value zero.</span></span>  <span data-ttu-id="528ea-176">Erre azért van szükség, mert általánosságban nem létezik az általános $a $ és $x $ multiplikatív.</span><span class="sxs-lookup"><span data-stu-id="528ea-176">This is needed in because in general there is not a multiplicative inverse for general $a$ and $x$.</span></span>  <span data-ttu-id="528ea-177">Mivel az összes kvantum-művelet, a mérések mentése megfordítható, meg kell őrizni a szükséges információkat a szorzás megfordításához.</span><span class="sxs-lookup"><span data-stu-id="528ea-177">Since all quantum operations, save measurement, are reversible we need to keep enough information around to invert the multiplication.</span></span>  <span data-ttu-id="528ea-178">Emiatt az eredményt egy különálló tömb tárolja.</span><span class="sxs-lookup"><span data-stu-id="528ea-178">For this reason the result is stored in a separate array.</span></span>  <span data-ttu-id="528ea-179">Ezt a trükköt, amely egy visszafordíthatatlan művelet kimenetének, például a szorzásnak a megtakarítását, egy különálló regiszterben, a Charlie Bennett után a "Bennett Trick" néven ismert, amely a visszafordítható és a kvantum-számítástechnika egyik alapvető eszköze.</span><span class="sxs-lookup"><span data-stu-id="528ea-179">This trick of saving the output of an irreversible operation, like multiplication, in a separate register is known as the "Bennett trick" after Charlie Bennett and is a fundamental tool in both reversible and quantum computing.</span></span>

<span data-ttu-id="528ea-180">Számos kvantum-áramkör javasolt a hozzáadáshoz, és mindegyik különböző kompromisszumot vizsgál a qubits (szóköz) számának és a szükséges Gate-műveleteknek (Time) a száma alapján.</span><span class="sxs-lookup"><span data-stu-id="528ea-180">Many quantum circuits have been proposed for addition and each explores a different tradeoff in terms of the number of qubits (space) and the number of gate operations (time) required.</span></span>  <span data-ttu-id="528ea-181">Két, az alábbiakban ismertetett, a drapéria-kiegészítőkre és a Beauregard-kiegészítőkre vonatkozó további, hatékony kiegészítést tekintünk át.</span><span class="sxs-lookup"><span data-stu-id="528ea-181">We review two highly space efficient adders below known as the Draper adder and the Beauregard adder.</span></span>

### <a name="draper-adder"></a><span data-ttu-id="528ea-182">A drapéria kiegészítőkre</span><span class="sxs-lookup"><span data-stu-id="528ea-182">Draper Adder</span></span> ###

<span data-ttu-id="528ea-183">A drapéria kiegészítése vitathatatlanul az egyik legelegánsabb kvantum-kiegészítés, mivel közvetlenül a kvantum-tulajdonságokat hívja meg a Hozzáadás elvégzéséhez.</span><span class="sxs-lookup"><span data-stu-id="528ea-183">The Draper adder is arguably one of the most elegant quantum adders, as it directly invokes quantum properties to perform addition.</span></span>  <span data-ttu-id="528ea-184">A drapéria kiegészítésének betekintése, hogy a Fourier-transzformáció felhasználható a fázisok eltolásának lefordítására egy kis eltolásban.</span><span class="sxs-lookup"><span data-stu-id="528ea-184">The insight behind the Draper adder is that the Fourier transform can be used to translate phase shifts into a bit shift.</span></span>  <span data-ttu-id="528ea-185">Ezután egy Fourier-transzformáció alkalmazásával, a megfelelő fázis-eltolások alkalmazásával, majd a Fourier-transzformáció visszavonásával végezheti el a kiegészítést.</span><span class="sxs-lookup"><span data-stu-id="528ea-185">It then follows that by applying a Fourier transform, applying appropriate phase shifts, and then undoing the Fourier transform you can implement an adder.</span></span>  <span data-ttu-id="528ea-186">A javasolt számos más kiegészítéstől eltérően a drapéria-kiegészítőkre explicit módon a Quantum Fourier-transzformáción keresztül bevezetett kvantum-hatásokat használják.</span><span class="sxs-lookup"><span data-stu-id="528ea-186">Unlike many other adders that have been proposed, the Draper adder explicitly uses quantum effects introduced through the quantum Fourier transform.</span></span>  <span data-ttu-id="528ea-187">Nem rendelkezik természetes klasszikus munkatársaival.</span><span class="sxs-lookup"><span data-stu-id="528ea-187">It does not have a natural classical counterpart.</span></span>  <span data-ttu-id="528ea-188">A drapéria kiegészítésének konkrét lépéseit alább találja.</span><span class="sxs-lookup"><span data-stu-id="528ea-188">The specific steps of the Draper adder are given below.</span></span>

<span data-ttu-id="528ea-189">Tegyük fel, hogy két $n $ bites qubit regisztrál az egész számok tárolására $a $ és $b $, majd minden $a $ $ $ \operatorname{QFT}\ket{a} = \frac{1}{\sqrt{2 ^ n}} \sum\_{j = 0} ^ {2 ^ n-1} e ^ {i2\pi (AJ)/2 ^ n} \ket{j}.</span><span class="sxs-lookup"><span data-stu-id="528ea-189">Assume that you have two $n$-bit qubit registers storing the integers $a$ and $b$ then for all $a$ $$ \operatorname{QFT}\ket{a}= \frac{1}{\sqrt{2^n}}\sum\_{j=0}^{2^n-1} e^{i2\pi(aj)/2^n} \ket{j}.</span></span>
<span data-ttu-id="528ea-190">$ $ Ha definiáljuk a $ $ \ket{\phi\_k (a)} = \frac{1}{\sqrt{2}} \left (\ket{0} + e ^ {i2\pi a/2 ^ k} \ket{1} \right), $ $, majd néhány algebra után láthatja, hogy a $ $ \operatorname{QFT}\ket{a} = \ket{\phi\_1 (a)} \otimes \cdots \otimes \ket{\phi\_n (a)}.</span><span class="sxs-lookup"><span data-stu-id="528ea-190">$$ If we define $$ \ket{\phi\_k(a)} = \frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi a /2^k}\ket{1} \right), $$ then after some algebra you can see that $$ \operatorname{QFT}\ket{a}=\ket{\phi\_1(a)}\otimes \cdots \otimes \ket{\phi\_n(a)}.</span></span>
<span data-ttu-id="528ea-191">$ $ A kiegészítés végrehajtásának elérési útja akkor válik világossá, miután megfigyelte, hogy a bemenetek összege $ $ \ket{a + b} = \operatorname{QFT} ^{-1}\ket{\phi\_1 (a + b)} \otimes \cdots \otimes \ket{\phi\_n (a + b)}.</span><span class="sxs-lookup"><span data-stu-id="528ea-191">$$ The path towards performing an adder then becomes clear after observing that the sum of the inputs can be written as $$ \ket{a+b}=\operatorname{QFT}^{-1}\ket{\phi\_1(a+b)}\otimes \cdots \otimes \ket{\phi\_n(a+b)}.</span></span>
<span data-ttu-id="528ea-192">$ $ A $b $ és a $a $ közötti egész szám, amely a dekompozíció egyes qubits a $b $ as vezérlőkkel rendelkező bitek használatával felügyelt fázisú rotációs műveleteket végez.</span><span class="sxs-lookup"><span data-stu-id="528ea-192">$$ The integers $b$ and $a$ can then be added by performing controlled-phase rotation on each of the qubits in the decomposition using the bits of $b$ as controls.</span></span>

<span data-ttu-id="528ea-193">Ez a bővítés tovább egyszerűsíthető azáltal, hogy bármely Integer $j $ és valós szám $x $, $e ^ {i2\pi (x + j)} = e ^ {i2\pi x} $.</span><span class="sxs-lookup"><span data-stu-id="528ea-193">This expansion can be further simplified by noting that for any integer $j$ and real number $x$, $e^{i2\pi(x+j)}=e^{i2\pi x}$.</span></span>  <span data-ttu-id="528ea-194">Ennek az az oka, hogy ha egy körben elforgat $360 ^ {\circ} $ fok ($ 2 \ PI $ radián) értéket, akkor a végén pontosan megkezdheti a kezdeti lépéseket.</span><span class="sxs-lookup"><span data-stu-id="528ea-194">This is because if you rotate $360^{\circ}$ degrees ($2\pi$ radians) in a circle then you end up precisely where you started.</span></span>  <span data-ttu-id="528ea-195">A ($e ^ {i2\pi x} $ $x $ értékének egyetlen fontos része, ezért $x $ töredékes részét képezi.</span><span class="sxs-lookup"><span data-stu-id="528ea-195">The only important part of $x$ for $e^{i2\pi x}$ is therefore the fractional part of $x$.</span></span>  <span data-ttu-id="528ea-196">Pontosabban, ha az űrlap bináris bővítése $x = y +0. x\_0x\_2 \ ldots x\_n $, $e ^ {i2\pi x} = e ^ {i2\pi (0. x\_0x\_2 \ ldots x\_{n-1})} $ és így $ $ \ket{\phi\_k (a + b)} = \frac{1}{\sqrt{2}} \left (\ket{0} + e ^ {i2\pi [a/2 ^ k +0. b\_k\ldots b\_1]} \ket{1} \right). $ $ Ez azt jelenti, hogy ha elvégezjük a hozzáadást úgy, hogy növeli a több tízezer tényezőt a $ \ket{a} $ Fourier-átalakításának növekedésével, akkor a a Forgások száma $k $ értékkel csökken.</span><span class="sxs-lookup"><span data-stu-id="528ea-196">Specifically, if we have a binary expansion of the form $x=y+0.x\_0x\_2\ldots x\_n$ then $e^{i2\pi x}=e^{i2\pi (0.x\_0x\_2\ldots x\_{n-1})}$ and hence $$\ket{\phi\_k(a+b)}=\frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi [a/2^k+0.b\_k\ldots b\_1]}\ket{1} \right).$$ This means that if we perform addition by incrementing each of the tensor factors in the expansion of the Fourier transform of $\ket{a}$ then the number of rotations shrinks as $k$ decreases.</span></span>  <span data-ttu-id="528ea-197">Ez jelentősen csökkenti a kiegészítésben szükséges kvantum-kapuk számát.</span><span class="sxs-lookup"><span data-stu-id="528ea-197">This substantially reduces the number of quantum gates needed in the adder.</span></span>  <span data-ttu-id="528ea-198">A Fourier-transzformációt, a fázisok hozzáadását és az inverz Fourier-transzformáció lépéseit jelöljük, amelyek a \operatorname{QFT} ^{-1} \left (\phi\\\!\operatorname{ADD}\right) \operatorname{QFT} $.</span><span class="sxs-lookup"><span data-stu-id="528ea-198">We denote the Fourier transform, phase addition and the inverse Fourier transform steps that comprise the Draper adder as $\operatorname{QFT}^{-1} \left(\phi\\\!\operatorname{ADD}\right) \operatorname{QFT}$.</span></span> <span data-ttu-id="528ea-199">Alább látható egy olyan kvantum-áramkör, amely ezt az egyszerűsítést használja a teljes folyamat megvalósításához.</span><span class="sxs-lookup"><span data-stu-id="528ea-199">A quantum circuit that uses this simplification to implement the entire process can be seen below.</span></span>

![Az áramköri diagramként látható drapéria-kiegészítés](~/media/draper.svg)

<span data-ttu-id="528ea-201">Az áramkörben lévő minden ellenőrzött $e ^ {I2 \ PI/k} $ Gate a szabályozott fázisú kapura utal.</span><span class="sxs-lookup"><span data-stu-id="528ea-201">Each controlled $e^{i2\pi/k}$ gate in the circuit refers to a controlled-phase gate.</span></span>  <span data-ttu-id="528ea-202">Az ilyen kapuk rendelkeznek a tulajdonsággal, amely azon qubits, amelyeken a művelet, $ \ket{00}\mapsto \ket{00}$, de $ \ket{11}\mapsto e ^ {I2 \ PI/k} \ ket{11}$.</span><span class="sxs-lookup"><span data-stu-id="528ea-202">Such gates have the property that on the pair of qubits on which they act, $\ket{00}\mapsto \ket{00}$ but $\ket{11}\mapsto e^{i2\pi/k}\ket{11}$.</span></span>  <span data-ttu-id="528ea-203">Ez az áramkör lehetővé teszi a hozzáadást további qubits nélkül, a bemenetek és a kimenetek tárolásához szükséges beállítások mellett.</span><span class="sxs-lookup"><span data-stu-id="528ea-203">This circuit allows us to perform addition using no additional qubits apart from those needed to store the inputs and the outputs.</span></span>

### <a name="beauregard-adder"></a><span data-ttu-id="528ea-204">Beauregard-kiegészítőkre</span><span class="sxs-lookup"><span data-stu-id="528ea-204">Beauregard Adder</span></span> ###

<span data-ttu-id="528ea-205">A Beauregard vipera egy olyan kvantum-moduláris kiegészítés, amely a drapéria-kiegészítést használja, hogy egy tetszőleges értékkel rendelkező, pozitív egész számú, $N $ értékű $N</span><span class="sxs-lookup"><span data-stu-id="528ea-205">The Beauregard adder is a quantum modular adder that uses the Draper adder in order to perform addition modulo $N$ for an arbitrary value positive integer $N$.</span></span>  <span data-ttu-id="528ea-206">A Quantum Modular-kiegészítések, például a Beauregard-kiegészítőkre jelentősége nagy mértékben kihasználja az rövid algoritmusának a hatványozására-modulban való használatát.</span><span class="sxs-lookup"><span data-stu-id="528ea-206">The significance of quantum modular adders, such as the Beauregard adder, stems to a large extent from their use in the modular exponentiation step within Shor's algorithm for factoring.</span></span>  <span data-ttu-id="528ea-207">A kvantum-moduláris kiegészítés a következő művelettel rendelkezik a Quantum input $ \ket{b} $ és a klasszikus input $a $ esetén, ahol a $a $ és a $b $ értéket a rendszer megígérte, hogy egész számú mod $N $, ami azt jelenti, hogy a $ [0, \ldots, N-1] $ intervallumban szerepelnek.</span><span class="sxs-lookup"><span data-stu-id="528ea-207">A quantum modular adder has the following action for quantum input $\ket{b}$ and classical input $a$ where $a$ and $b$ are promised to be integers mod $N$, meaning that they are in the interval $[0,\ldots, N-1]$.</span></span>

<span data-ttu-id="528ea-208">$ $ \ket{b}\rightarrow \ket{b + a \text{mod} N} = \begin{Cases} \ket{b + a}, & b + a < N\\\\ \ket{b + a-N}, & (b + a) \ge N \end{Cases}.</span><span class="sxs-lookup"><span data-stu-id="528ea-208">$$ \ket{b}\rightarrow \ket{b+a \text{ mod }N}=\begin{cases} \ket{b+a},& b+a < N\\\\ \ket{b+a-N},& (b+a)\ge N \end{cases}.</span></span>
$$

<span data-ttu-id="528ea-209">A Beauregard kiegészítőkre a drapéria kiegészítőkre, vagy pontosabban $ \phi\\\!\operatorname{ADD} $-t használ, hogy $a $ és $b $ értéket vegyen fel a fázisba.</span><span class="sxs-lookup"><span data-stu-id="528ea-209">The Beauregard adder uses the Draper adder, or more specifically $\phi\\\!\operatorname{ADD}$, to add $a$ and $b$ in phase.</span></span>  <span data-ttu-id="528ea-210">Ezután ugyanazzal a művelettel azonosítja, hogy a $a + b < N $ $N $ kivonásával és tesztelésével, ha $a + b-N < 0 $.</span><span class="sxs-lookup"><span data-stu-id="528ea-210">It then uses the same operation to identify whether $a+b <N$ by subtracting $N$ and testing if $a+b-N<0$.</span></span>  <span data-ttu-id="528ea-211">Az áramkör ezt az információt egy kiegészítő qubit tárolja, majd hozzáadja $N $ vissza a regisztrációt, ha $a + b < N $.</span><span class="sxs-lookup"><span data-stu-id="528ea-211">The circuit stores this information in an ancillary qubit and then adds $N$ back the register if $a+b<N$.</span></span>  <span data-ttu-id="528ea-212">Ezt követően a kiegészítő bit kiszámításával zárul le (ez a lépés szükséges annak biztosításához, hogy a Ancilla a kiegészítés meghívása után is kiosztható legyen).</span><span class="sxs-lookup"><span data-stu-id="528ea-212">It then concludes by uncomputing this ancillary bit (this step is needed to ensure that the ancilla can be de-allocated after calling the adder).</span></span>  <span data-ttu-id="528ea-213">Az alábbi, a Beauregard-kiegészítőkre vonatkozó áramkört adja meg.</span><span class="sxs-lookup"><span data-stu-id="528ea-213">The circuit for the Beauregard adder is given below.</span></span>

![A Beauregard-kiegészítőkre áramköri diagramként jelenik meg](~/media/beau.svg)

<span data-ttu-id="528ea-215">Itt a Gate $ \Phi\\\!\operatorname{ADD} $ a $ \Phi\\\!\operatorname{ADD} $ értéket veszi át, azzal a különbséggel, hogy ebben a kontextusban a bemenet klasszikus, nem pedig a Quantum.</span><span class="sxs-lookup"><span data-stu-id="528ea-215">Here the gate $\Phi\\\!\operatorname{ADD}$ takes the same form as $\phi\\\!\operatorname{ADD}$ except that in this context the input is classical rather than quantum.</span></span>  <span data-ttu-id="528ea-216">Ez lehetővé teszi, hogy a $ \Phi\\\!\operatorname{ADD} $ által vezérelt fázisok lecserélve legyenek a fázisokra, amelyek ezután kevesebb műveletre fordíthatók le, hogy csökkentsék a qubits számát és a kiegészítéshez szükséges kapuk számát.</span><span class="sxs-lookup"><span data-stu-id="528ea-216">This allows the controlled phases in $\Phi\\\!\operatorname{ADD}$ to be replaced with phase gates that can then be compiled together into fewer operations to reduce both the number of qubits and number of gates needed for the adder.</span></span>

<span data-ttu-id="528ea-217">További részletekért tekintse meg az [M. Roetteler, a th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) és a [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span><span class="sxs-lookup"><span data-stu-id="528ea-217">For more details, please refer to [M. Roetteler, Th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) and [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span></span>

### <a name="quantum-phase-estimation"></a><span data-ttu-id="528ea-218">Kvantumfázisbecslés</span><span class="sxs-lookup"><span data-stu-id="528ea-218">Quantum Phase Estimation</span></span> ###

<span data-ttu-id="528ea-219">A Quantum Fourier-transzformáció egyik különösen fontos alkalmazása, hogy megismerje az egységes operátorok eigenvalues, amely a *fázisok becslésének*ismert problémája.</span><span class="sxs-lookup"><span data-stu-id="528ea-219">One particularly important application of the quantum Fourier transform is to learn the eigenvalues of unitary operators, a problem known as *phase estimation*.</span></span>
<span data-ttu-id="528ea-220">Vegyünk egy egységes $U $ és egy State $ \ket{\phi} $ értéket, amely szerint a $ \ket{\phi} $ eigenstate $U $, ismeretlen sajátérték $ \phi $, \begin{Equation} U\ket {\ Phi} = \phi\ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="528ea-220">Consider a unitary $U$ and a state $\ket{\phi}$ such that $\ket{\phi}$ is an eigenstate of $U$ with unknown eigenvalue $\phi$, \begin{equation} U\ket{\phi} = \phi\ket{\phi}.</span></span>
<span data-ttu-id="528ea-221">\end{Equation}, ha csak $U $ Oracle-hez fér hozzá, akkor a $ \phi $ fázisban megtudhatjuk, $Z hogy egy vezérelt művelet céljára alkalmazott $ rotációs műveletet propagálja vissza a vezérlőre.</span><span class="sxs-lookup"><span data-stu-id="528ea-221">\end{equation} If we only have access to $U$ as an oracle, then we can learn the phase $\phi$ by utilizing that $Z$ rotations applied to the target of a controlled operation propagate back onto the control.</span></span>

<span data-ttu-id="528ea-222">Tegyük fel, hogy $V $ $U $ vezérelt alkalmazás, például a \begin{align} V (\ket{0} \otimes \ket{\phi}) & = \ket{0} \otimes \ket{\phi} \\\\ \textrm{és} V (\ket{1} \otimes \ket{\phi}) & = e ^ {i \phi} \ket{1} \otimes \ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="528ea-222">Suppose that $V$ is a controlled application of $U$, such that \begin{align} V (\ket{0} \otimes \ket{\phi}) & =            \ket{0} \otimes \ket{\phi} \\\\ \textrm{ and } V (\ket{1} \otimes \ket{\phi}) & = e^{i \phi} \ket{1} \otimes \ket{\phi}.</span></span>
<span data-ttu-id="528ea-223">\end{align} ezt követően: linearitás, \begin{align} V (\ket{+} \otimes \ket{\phi}) & = \frac{(\ket{0} \otimes \ket{\phi}) + e ^ {i \phi} (\ket{1} \otimes \ket{\phi})} {\sqrt{2}}.</span><span class="sxs-lookup"><span data-stu-id="528ea-223">\end{align} Then, by linearity, \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{ (\ket{0} \otimes \ket{\phi}) + e^{i \phi} (\ket{1} \otimes \ket{\phi}) }{\sqrt{2}}.</span></span>
<span data-ttu-id="528ea-224">a \end{align} a \begin{align} V (\ket{+} \otimes \ket{\phi}) & = \frac{\ket{0} + e ^ {i \phi} \ket{1}} {\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1 (\phi) \ket{+}) \otimes \ket{\phi}, \end{align}, ahol $R _1 $ a <xref:microsoft.quantum.intrinsic.r1> művelet által használt egységes alkalmazás.</span><span class="sxs-lookup"><span data-stu-id="528ea-224">\end{align} We can collect terms to find that \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{\ket{0} + e^{i \phi} \ket{1}}{\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1(\phi) \ket{+}) \otimes \ket{\phi}, \end{align} where $R_1$ is the unitary applied by the <xref:microsoft.quantum.intrinsic.r1> operation.</span></span>
<span data-ttu-id="528ea-225">Másképpen fogalmazva, a $V $ alkalmazásának hatása pontosan ugyanaz, mint a $R _1 $ ismeretlen szögben való alkalmazása, noha csak a $V $ Oracle-hez férhet hozzá.</span><span class="sxs-lookup"><span data-stu-id="528ea-225">Put differently, the effect of applying $V$ is precisely the same as applying $R_1$ with an unknown angle, even though we only have access to $V$ as an oracle.</span></span>
<span data-ttu-id="528ea-226">Így a vita további részében a $R _1 (\phi) $ kifejezéssel megbeszéljük a fázisok becslését, amelyet az úgynevezett *fázis-visszarúgás*használatával implementálunk.</span><span class="sxs-lookup"><span data-stu-id="528ea-226">Thus, for the rest of this discussion we will discuss phase estimation in terms of $R_1(\phi)$, which we implement by using so-called *phase kickback*.</span></span>

<span data-ttu-id="528ea-227">Mivel a vezérlés és a cél regisztrálása a folyamat után nem látható, a $ \ket{\phi} $ értéket újra felhasználhatjuk a $U ^ $2 ellenőrzött alkalmazásának céljára, hogy előkészítsünk egy második vezérlőelem-qubit a _1 (2 \phi) \ket{+} $ $R állapotban.</span><span class="sxs-lookup"><span data-stu-id="528ea-227">Since the control and target register remain untangled after this process, we can reuse $\ket{\phi}$ as the target of a controlled application of $U^2$ to prepare a second control qubit in the state $R_1(2 \phi) \ket{+}$.</span></span>
<span data-ttu-id="528ea-228">Így továbbra is beszerezhetjük a \begin{align} \ket{\psi} & = \ sum_ {j = 0} ^ n R_1 (2 ^ j \phi) \ket{+} \\\\ & \propto \ bigotimes_ {j = 0} ^ {n} \left (\ket{0} + \exp (i 2 ^ {j} \phi) \ket{1}\right) \\\\ & \propto \ sum_ {k = 0} ^ {2 ^ n-1} \exp (i \phi k) \ket{k} \end{align}, ahol a $n $ a szükséges bitek száma. és hogy hol használták a ${} \propto {}$ értéket, jelezve, hogy letiltottuk a $1/\sqrt normalizálás tényezőjét {2 ^ n} $.</span><span class="sxs-lookup"><span data-stu-id="528ea-228">Continuing in this way, we can obtain a register of the form \begin{align} \ket{\psi} & = \sum_{j = 0}^n R_1(2^j \phi) \ket{+} \\\\ & \propto \bigotimes_{j=0}^{n} \left(\ket{0} + \exp(i 2^{j} \phi) \ket{1}\right) \\\\ & \propto \sum_{k = 0}^{2^n - 1} \exp(i \phi k) \ket{k} \end{align} where $n$ is the number of bits of precision that we require, and where we have used ${} \propto {}$ to indicate that we have suppressed the normalization factor of $1 / \sqrt{2^n}$.</span></span>

<span data-ttu-id="528ea-229">Ha feltételezzük, hogy a $ \phi = 2 \pi p/2 ^ k $ értéket egy egész szám $p $ értékre, akkor ezt a következőt ismerjük fel: $ \ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n} $, ahol $p _j $ a $j ^ {\textrm{th}} $ bit of $2 \pi \phi $.</span><span class="sxs-lookup"><span data-stu-id="528ea-229">If we assume that $\phi = 2 \pi p / 2^k$ for an integer $p$, then we recognize this as $\ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n}$, where $p_j$ is the $j^{\textrm{th}}$ bit of $2 \pi \phi$.</span></span>
<span data-ttu-id="528ea-230">A Quantum Fourier-transzformáció adjoint alkalmazásával ezért a rendszer kvantum-állapotként kódolja a fázis bináris ábrázolását.</span><span class="sxs-lookup"><span data-stu-id="528ea-230">Applying the adjoint of the quantum Fourier transform, we therefore obtain the binary representation of the phase encoded as a quantum state.</span></span>

<span data-ttu-id="528ea-231">A Q #-ban ez a <xref:microsoft.quantum.characterization.quantumphaseestimation> művelettel valósul meg, amely <xref:microsoft.quantum.oracles.discreteoracle> $U ^ millió $-ra alkalmazza a pozitív egész számok függvényében $m $ értéket.</span><span class="sxs-lookup"><span data-stu-id="528ea-231">In Q#, this is implemented by the <xref:microsoft.quantum.characterization.quantumphaseestimation> operation, which takes a <xref:microsoft.quantum.oracles.discreteoracle> implementing application of $U^m$ as a function of positive integers $m$.</span></span>
