---
title: QDK 0,3 nyelvi felülvizsgálati és áttelepítési útmutató
description: 'Ismerteti a Microsoft Quantum Development Kit 0,3 új szolgáltatásait, valamint a meglévő Q # programok áttelepítésének módját.'
author: beheim
uid: microsoft.quantum.relnotes.migration-0-3
ms.author: bettina.heim@microsoft.com
ms.date: 10/29/2018
ms.topic: article
ms.openlocfilehash: a715185059e37e3805caf48e7fae6f5ed3372dba
ms.sourcegitcommit: 2317473fdf2b80de58db0f43b9fcfb57f56aefff
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 05/15/2020
ms.locfileid: "83426786"
---
# <a name="qdk-03-language-release-notes-and-migration-guide"></a>QDK 0,3 nyelvi kibocsátási megjegyzések és áttelepítési útmutató

Örömmel mutatjuk be a legújabb frissítést a Quantum Development Kit-ben.  Ez az oldal áttekintést nyújt az új Q # nyelvi funkciókról, és leírja, hogyan [telepíthet át](#Migration) meglévő q # programokat az új szintaxisba.  A Q # nyelv teljes leírását a teljes dokumentációban [találja.](xref:microsoft.quantum.guide.basics)


## <a name="whats-new"></a>Újdonságok 

Az 0,3-es frissítés számos új nyelvi és szerkesztői funkciót tartalmaz.

### <a name="overview-of-features"></a>A funkciók áttekintése

- Továbbfejlesztett fejlesztői eszközök integrálása a Visual studióhoz és a Visual Studio Code-hoz, beleértve a következőket:
    - Élő fordítás és visszajelzés a beíráskor (*más néven* squiggly-aláhúzás).
    - Vigye az egérmutatót a dokumentációs összefoglalók és az aláírások típusára.
    - Támogatás: ugrás a definícióhoz.
    - Egyszerűen navigáljon a névtér, a művelet, a függvény és a típus deklarációba.
    - Továbbfejlesztett diagnosztikai üzenetek.
- Nyelvi tökéletesítések
    - Egyetlen qubit és rekordos inicializálás a használat és a hitelfelvétel között
    - Az összes hozzárendelésen lévő rekordból való kiépítés
    - Iteráció a tömbökön
    - Feltételes kifejezések
    - Alapértelmezett – a műveletekhez tartozó specializáció rövidítése
    - Automatikusan generált típusok konstruktorai
    - Kifejezés-módosítók


## <a name="editor-features"></a>Szerkesztői funkciók

A Quantum Development Kit mostantól tartalmazza a Q # nyelvi kiszolgálóját, valamint a Visual Studio és a Visual Studio Code ügyfél-integrációját.
Ezzel elérhetővé válnak az IntelliSense új funkciói, valamint a valós idejű gépelési visszajelzés a hibák és figyelmeztetések hullámvonalas aláhúzása révén.
Ebben az esetben a definíció mostantól támogatott, és az egérmutató információi megjelennek a típussal kapcsolatos információk, valamint a megjegyzések dokumentálása című témakörben. Emellett elérhetők a megadott névterekkel, műveletekkel, függvényekkel és típusokkal kapcsolatos szimbólumok is, amelyek lehetővé teszik, hogy gyorsan navigáljon a deklarációk között.    
A frissítés általánosságban véve nagy mértékben javítja a diagnosztikai üzeneteket, egyszerűen elérhetővé teszi a diagnosztikákat és pontosan meghatározza azok tartományait, valamint az egérrel való rámutatással további részletek jelenít meg. 

Ehhez a 0,3-es kiadáshoz a Quantum Development Kit részét képező nyelvi kiszolgáló nem támogatja több munkaterület használatát.
Ha a VS Code-ban szeretne dolgozni egy projekttel, nyissa meg a projektet tartalmazó legfelső szintű mappát és az összes hivatkozott projektet.
Ahhoz, hogy a Visual Studióban használhasson egy megoldást, a megoldásban foglalt összes projektnek a megoldás mappájában vagy valamelyik almappájában kell lennie.

## <a name="language-features"></a>Nyelvi funkciók

A nyelvi funkciók tekintetében ez a frissítés egységesíti számos nyelvi minta kezelését.
Az egyes felhasználók által definiált típusokhoz például a konstruktorok jönnek létre, amelyek a többi függvényhez hasonlóan részben is alkalmazhatók.
Egy másik példa a rekord Dekonstrukciója, amely mostantól teljes mértékben támogatott az összes hozzárendelésen belül. Ez nem csak a let-, a megváltoztathatatlan és a set-utasítást tartalmazza, hanem a for-Loops, a using-és a hitelfelvételi-foglalások közötti iterációs változót is. Emellett a részleges dekonstrukciók az 0,3-es frissítéssel újonnan támogatottak. a dekonstrukciókban lévő aláhúzások jelzik a figyelmen kívül hagyott érték részeit. 

A következő kód néhány új funkciót mutat be:
```qsharp
    let tuples = [(1, 0), (0, 1)];
    mutable res = (0, 0, 0);

    // For-loops can iterate over arrays, and can destructure tuples.
    for ((i1, i2) in tuples) {

        // Mutable assignments can now destructure and ignore parts of tuples,
        // using the same syntax as let-bindings.
        mutable (r1, r2, _) = res;
        set (r1, r2) = (r1 ||| i1, r2 &&& i2);

        let (_, _, s) = res;
        // The new conditional operator can be used inside expressions, avoiding
        // the need for extraneous if-statements.
        set res = (r1, r2, r1 == r2 ? s | s + 1);
    }
```
Az utolsó set utasítás egy új, a 0,3-es frissítéssel bevezetett Ternáris operátort használ a feltételes kifejezések támogatásához.
A feltételes kifejezés az űrlap kifejezése `condition ? caseTrue | caseFalse` .
Ahogy a fenti példában is látható, a tömbök iterációja mostantól támogatott.

A `using` és a szolgáltatáson belüli kiosztások `borrowing` az egyqubits, a qubit-tömbök és a beágyazott rekordok esetében új lehetőségek:
```qsharp
    using (qubit = Qubit()) {
        // qubit contains a single qubit
    }

    borrowing ((qubits, qubit) = (Qubit[3], Qubit())) {
        // qubits contains an array of three qubits, and qubit contains a single qubit
    }
```

Két új specializációs generátorra vonatkozó direktíva, `invert` valamint a `distribute` bevezetése mellett a `auto` rendszer megnövelte a működés közbeni specializációk generálásának szabályozását.
A műveletekben megadott alapértelmezett specializáció explicit deklarációja `body` már nem kötelező.
A függvényekhez hasonlóan a utasítások közvetlenül is hozzáadhatók a műveleti deklarációhoz, ha a műveletben nincs más specializáció deklarálva.
A kiadásban áttelepítési parancsfájlt is tartalmaz a meglévő kódok áttelepítéséhez és az új nyelvi funkciók kihasználásához (lásd az [áttelepítési parancsfájl szakaszát](#MigrationScript)).

A felhasználó által definiált típusok kezelésének jelentős változása a 0,3-es frissítéssel jár. Míg a korábbi kiadásokban a felhasználó által definiált típusokat a rendszer az alapul szolgáló típus altípusai szerint kezeli [section on breaking changes](#BreakingChanges)  
A módosítás részeként olyan kifejezés-módosítókat vezetünk be, amelyek bizonyos kifejezésekre alkalmazhatók. Az "Atomic" kifejezéseket, amelyeket a módosítók alkalmazhatnak az azonosítók, a tömbös elemek kifejezései és a aritása-1 rekordok.
A módosítók szigorúbbak, mint bármely más kifejezés combinator, és különösen szigorúbbak, mint a Call-Expression combinator `(` `)` . 
`Adjoint`, `Controlled` és egy új "kicsomagolás" Postfix operátort `!` kifejezés-módosítónak kell tekinteni. `Adjoint`A és a `Controlled` as kifejezés-módosítók nem igényelnek nagy számú zárójelet. Az alábbi kifejezések érvényesek például a következő kifejezésekre `Op` : egy egységes művelet, `opArr` egy egységes művelet tömbje és `arg` egy megfelelő argumentum: 
```qsharp
    Adjoint Op (arg);
    Controlled opArr[i] (arg);
```
Az áttelepítési parancsfájl a felesleges zárójelek többségét elvonja, és teljes mértékben kihasználja az új funkciókat. Azt azonban javasoljuk, hogy a parancsfájl ne értelmezze a kódot, és nem veszi figyelembe a következő `Controlled` ritka esetekben előforduló eltérő értelmezését: (csak részleges alkalmazásokkal együtt releváns).

Az új módosító a `!` felhasználó által definiált típust a mögöttes típusra konvertálja. Ez a szereposztás a korábbi kiadásokban való végrehajtásnak tekinthető, és automatikusan lett végrehajtva. A felhasználó által definiált típusok új értelmezésével ez már nem így van, és a leadott értéket explicit módon kell megtenni.    
Az alábbi példa azt szemlélteti, hogyan használható az új módosító: 
```qsharp
    newtype Unitary = (Qubit => Unit: Adjoint, Controlled);

    operation Foo (unitaries : Unitary[], qubit : Qubit) : Unit {

        for (unitary in unitaries[1 .. Length(unitaries)-1]) {
            // Each element of unitaries is an instance of the user-defined
            // type Unitary, so unitary! unwraps each element to an operation
            // type that we can call.
            unitary! (qubit);
            // The unwrap operator can also be used as a part of functor
            // expressions and when indexing into arrays.
            Adjoint unitary! (qubit);
            Adjoint unitaries[0]! (qubit);
        }
    }
```
Ahogy a példa is látható, a `!` kötések szigorúbbak, mint az előtag-módosító, például a `Controlled` és a `Adjoint` .

## <a name="breaking-changes"></a><a name="BreakingChanges"></a>Változtatások megszakítása 

Az 0,3-es frissítés egy új fordítóprogrammal rendelkezik, és néhány feltörési változást tartalmaz.
A meglévő kód frissítésének megkönnyítése érdekében a fordító olyan formázási lehetőséget is biztosít, amely érvényes vagy érvénytelen kódot fordít le, és formázott Q # kódot bocsát ki a létrehozott fordítás alapján.
A megadott eszköz automatikusan feldolgozza az összes szintaktikai módosítást. Előfordulhat azonban, hogy az érvényes kód értelmezésének változásait (szemantikai változásokat) manuálisan kell elvégezni. 

Az alább felsorolt változásokon kívül az * a minta, `__*__` ahol * a nem szóközöket nem tartalmazó karakterek egyetlen sorozata belső használatra van fenntartva, és nem használható szimbólum neveként.  

## <a name="syntax-changes"></a>Szintaxis módosításai 

- Az 0,3-es verziótól kezdődően a tömb elemei nem lesznek pontosvesszővel elválasztva, ehelyett vesszővel elválasztva.
- A specializációs nyilatkozatokra vonatkozó automatikus létrehozási irányelv után egy pontosvesszőt kell megadnia.
- Az IF-, a, az és az-ig-záradékban szereplő feltételeknek zárójelbe kell esniük. 

Az összes többi szintaxis módosítása esetén a fordító egyszerűen figyelmeztetést hoz létre, ha a régi szintaxist használják.     
Egy ilyen módosítás például a felhasználó által definiált specializációk szimbóluma. Az előző kiadásokban egy vezérelt vagy szabályozott adjoint specializációs nyilatkozat egyetlen szimbólum argumentumot adott meg, 0,3-től kezdődően azt javasoljuk, hogy adjon meg egy ilyen szimbólum-rekordot az összes specializációhoz, amely azt `...` jelzi, hogy a fordítónak szükség esetén át kell telepítenie a jeleket a meghívásos deklarációból. 

## <a name="semantic-changes"></a>Szemantikai változások 

Az 0,3-es kiadás legjelentősebb betörése az, hogy a felhasználó által definiált típusok hogyan integrálhatók a típus rendszerbe. A korábbi kiadásokban a felhasználó által definiált típusok a mögöttes típus altípusának tekintendők. Ebben a kiadásban ez már nem így lesz. A felhasználó által definiált típusok mostantól a saját eltérő típusúak, és a felhasználó által definiált típus és a mögöttes típus között nincs automatikus átvitel. Az összes castot explicit módon "kicsomagolás" operátorral kell megtenni `!` , és a szereposztásra különösen szükség van a felhasználó által definiált típusú objektumok tartalmának eléréséhez.  

A típusrendszer módosításai a tömbök variancia-viselkedését, valamint a paraméteres objektumok típusának kezelését is tartalmazzák. A 0,3-től kezdődően a változó és a megváltoztathatatlan tömbök Invariant típusúak. Emellett a meghívónak átadott argumentumok nem állíthatók be paraméterrel. Ezekben az esetekben az argumentumokat a termékazonosító együtt kell átadni.

A Q # fordítóprogram korábbi kiadásai lehetővé tették egy függvény értékének megadását, ahol a rendszer a műveleti értéket várta, feltéve, hogy a függvény értéke megfelelő a bemeneti és a kimeneti típusokkal. Ez nem kívánt viselkedés, amely nincs megadva a Q # nyelvi specifikációban.
Az 0,3-fordítóban eltávolítjuk ezt a viselkedést, így a függvények értékei már nem tekintendők műveleti értéknek.
A hibára támaszkodó meglévő kód megszakadásának minimalizálásához hozzáadta a ToOperation függvényt a Microsoft. Quantum. Canon névtérhez, amely explicit módon átalakítja a függvényt egy olyan műveletbe, amely ugyanazokat a bemeneti és kimeneti típusokat fogja tartalmazni.

Az alábbi példa azt szemlélteti, hogyan lehet a `ToOperation` függvényt egy függvényt `Square` egy műveletre módosítani `op` : 
```qsharp
namespace Microsoft.Quantum.Tests {
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;

    function Square(x : Int) : Int {
        return x * x;
    }

    operation ApplyOp<'T, 'U>(op : ('T => 'U), input : 'T) : 'U {
        return op(input);
    }

    operation ToOperationTest() : Unit {
        let op = ToOperation(Square);
        AssertIntEqual(ApplyOp(op, 3), 9, "ToOperation failed with Square.");
    }
}
```

## <a name="requirements"></a>Követelmények 

A kiadás a Windows 10 rendszerhez készült Visual Studio 2017 15,8-es vagy újabb verziójában, illetve a Visual Studio Code 1.27.2 vagy újabb verziójában támogatott a Windows 10, a macOS és a Linux rendszerekhez.

A Quantum Development Kit a .NET Core SDK (2,0 vagy újabb) protokollt használja.

## <a name="installation"></a>Telepítés  

Kövesse a telepítési utasításokat [itt](../install-guide/index.md).

Előfordulhat, hogy a (z) figyelmeztetések ("a System. Reflection. Metadata" különböző verziói között észlelt ütközések találhatók, amelyek nem oldhatók fel. "), ha a .NET Core SDK jelenlegi verziója nem naprakész.  Ha azonban .NET Core SDK (2,0 vagy újabb) verziót használ, a figyelmeztetések figyelmen kívül hagyhatók.


- A kiadás több különböző mintát is tartalmaz, amelyekből megtudhatja, hogyan használhatja a Quantum Development Kit meglévő funkcióit és az ebben a kiadásban elérhető új funkciókat. Ezek a minták a GitHubon, a [Microsoft/Quantum](https://github.com/Microsoft/Quantum) adattárban is megtalálhatók.


## <a name="migrating-existing-projects-to-q-03"></a><a name="Migration"></a>Meglévő projektek migrálása Q # 0,3-re 

Ha már létezik Q # projekt a Quantum Development Kit 0,2-es verziójával, a következő lépésekkel telepítheti át ezeket a projekteket a legújabb verzióra. Egy [áttelepítési parancsfájlt](#MigrationScript) is biztosítunk a folyamat megkönnyítésére.

> [!NOTE]
> A projekteket sorrendben kell frissíteni. Ha több projekttel rendelkező megoldással rendelkezik, a rendszer a rájuk hivatkozó sorrendben frissíti az egyes projekteket.


1. A parancssorból futtassa a `dotnet clean` parancsot az összes meglévő bináris és köztes fájl eltávolításához.
2. Egy szövegszerkesztőben szerkessze a. csproj fájlt, és módosítsa a "Microsoft. Quantum" verzióját a `PackageReference` 0.3.1811.2802 verzióra, például:
```xml
    <PackageReference Include="Microsoft.Quantum.Canon" Version="0.3.1811.2802" />
    <PackageReference Include="Microsoft.Quantum.Development.Kit" Version="0.3.1811.2802" />
```
4. A parancssorban használja a parancssori fordítóba integrált formázó eszközt, hogy az összes szintaktikai módosítást a következő parancs futtatásával foglalkozzon:`dotnet msbuild /t:qsharpformat`  
    - A fájlok helyben lesznek áttelepítve. Az összes eredeti fájl biztonsági mentése a következőre lesz másolva`obj\qsharp\.backup`
    - A formázási eszköz lefordítja a projektet, figyelmen kívül hagyva az összes fordítási hibát, és formázott Q # kódot hoz létre a fordítási fordítás alapján. 
       Minden ismeretlen szimbólumot (például nem definiált változó nevét) egy helyőrző szöveg váltja fel, amelyet manuálisan kell cserélni a formázás után. Ebben az esetben a formázás sikeres lesz az érintett fájlra vonatkozó figyelmeztetés létrehozásakor.     
    - A rendszer a fájl formázását és különösen a fájlban lévő összes szóközt megváltoztatja a kibocsátott kódban. A megjegyzéseket megőrzi a rendszer.   
5. A futtatása után továbbra is manuálisan kell megadnia a szemantikai változásokat olyan esetekben, amikor a kód szemantikai értelmezése megváltozott. Ezeket a hibákat az IntelliSense a Visual Studióban vagy a Visual Studio Code-ban fogja jelenteni.
    - Nyissa meg a projekt gyökérkönyvtárát, vagy a Visual Studio 2017 vagy a Visual Studio Code-ban található megoldást.
    - A .qs fájl megnyitása után a szerkesztőben megjelenik a Q# nyelvi bővítmény kimenete a kimeneti ablakban.
    - Miután a projekt sikeresen betöltődött (ez a kimeneti ablakban látható), nyissa meg az egyes fájlokat, és manuálisan hárítsa el az összes fennmaradó problémát.


> [!NOTE]
> * Az 0,3-es kiadás esetében a Quantum Development Kit részét képező nyelvi kiszolgáló nem támogatja több munkaterület használatát.
> * Ha a Visual Studio Code-ban szeretne használni egy projektet, nyissa meg a gyökérmappát, amely tartalmazza a magát a projektet és az összes hivatkozott projektet.   
> * Ahhoz, hogy a Visual Studióban használhasson egy megoldást, a megoldásban foglalt összes projektnek a megoldás mappájában vagy valamelyik almappájában kell lennie.  
> * A 0,3-es vagy újabb verzióra áttelepített projektek közötti hivatkozások és a régebbi verziójú csomagokat használó projektek **nem** támogatottak.




## <a name="migration-script"></a><a name="MigrationScript"></a>Áttelepítési parancsfájl 

A projektek áttelepítésének megkönnyítése érdekében egy PowerShell-parancsfájlt is elérhetővé kell tenni, amely [itt](https://raw.githubusercontent.com/Microsoft/Quantum/release/v0.3.1810/utilities/qdk-migrate.ps1)tölthető le.
Ez a szkript segítséget nyújt a projekteknek a Quantum Development Kit 0,2-es verziójáról a 0,3-es verzió használatára.

> [!NOTE]
> Az áttelepítési parancsfájl futtatásához a Windows PowerShell vagy a PowerShell Core szükséges.
> A Windows PowerShell előre telepítve van a Windows 10 rendszerrel.
> Töltse le a PowerShell Core for Windows, macOS vagy Linux rendszert a következő címen: https://github.com/PowerShell/PowerShell .

A parancsfájl a következő négy lépést hajtja végre:

- A projekt a Quantum Development Kit korábbi verziójával készült, így biztosítva, hogy a Migrálás valószínűleg sikeres legyen. Ez a lépés kihagyható a `-Force` paraméterrel a parancsfájl használatával.
- Az új projekttervek telepítve vannak.
- A projekt frissítve lett a Quantum Development Kit aktuális verziójának használatára.
- A rendszer a Quantum Development Kit 0,3-es verziójával biztosított formázó eszközt alkalmazza a fentiekben dokumentált összes feltörési módosítás automatikus kezelésére.

A négy lépés elvégzése után előfordulhat, hogy néhány további áttelepítési probléma, amelyet manuálisan kell kezelni.
A Visual Studio 2017-es és a Visual Studio Code-hoz készült Quantum Development Kit-bővítmények legújabb verziójának használatával könnyedén megtalálhatja ezeket a problémákat.

A parancsfájl dokumentációja a következő parancsok egyikének futtatásával szerezhető be abban a mappában, ahol a parancsfájl található:

```powershell
Get-Help ./qdk-migrate.ps1
Get-Help -Online ./qdk-migrate.ps1
```

> [!NOTE]
> Alapértelmezés szerint a Windows meggátolja a parancsfájlok végrehajtását biztonsági mértékként.
> Előfordulhat, hogy a parancsfájlok (például a Windows rendszeren való `qdk-migrate.ps1` Futtatás) engedélyezéséhez módosítania kell a végrehajtási házirendet.
> Ehhez futtassa a következő `Set-ExecutionPolicy` parancsot:
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope Process
> ```
> Ekkor a rendszer visszaállít egy végrehajtási házirendet, amikor kilép a PowerShellből.
> Ha menteni szeretné a végrehajtási szabályzatot, használja a következőt egy másik értékkel `-Scope` :
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
> ```

