---
title: 'Q # API tervezési alapelvek'
description: 'Q # API tervezési alapelvek'
author: cgranade
ms.author: chgranad
ms.date: 3/9/2020
ms.topic: article
uid: microsoft.quantum.contributing.api-design
ms.openlocfilehash: def6a9f12accfa399fd4db3783b9899fc743f025
ms.sourcegitcommit: 0181e7c9e98f9af30ea32d3cd8e7e5e30257a4dc
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 06/23/2020
ms.locfileid: "85274853"
---
# <a name="q-api-design-principles"></a><span data-ttu-id="97ce9-103">Q # API tervezési alapelvek</span><span class="sxs-lookup"><span data-stu-id="97ce9-103">Q# API Design Principles</span></span>

## <a name="introduction"></a><span data-ttu-id="97ce9-104">Bevezetés</span><span class="sxs-lookup"><span data-stu-id="97ce9-104">Introduction</span></span>

<span data-ttu-id="97ce9-105">Nyelvként és platformként a Q # lehetővé teszi a felhasználók számára a kvantum-alkalmazások írását, futtatását, megismerését és megismerését.</span><span class="sxs-lookup"><span data-stu-id="97ce9-105">As a language and as a platform, Q# empowers users to write, run, understand, and explore quantum applications.</span></span>
<span data-ttu-id="97ce9-106">Ahhoz, hogy a felhasználók felhatalmazzák a Q # kódtárakat, az API-tervezési alapelveket követve elvégezheti a kialakítást, és segítheti a felhasználható könyvtárak létrehozását a Quantum fejlesztői közösség számára.</span><span class="sxs-lookup"><span data-stu-id="97ce9-106">In order to empower users, when we design Q# libraries, we follow a set of API design principles to guide our designs and to help us make usable libraries for the the quantum development community.</span></span>
<span data-ttu-id="97ce9-107">Ez a cikk felsorolja ezeket az alapelveket, és példákat mutat be arra, hogyan alkalmazhatja őket a Q # API-k tervezésekor.</span><span class="sxs-lookup"><span data-stu-id="97ce9-107">This article lists these principles, and gives examples to help guide how to apply them when designing Q# APIs.</span></span>

> [!TIP]
> <span data-ttu-id="97ce9-108">Ez egy meglehetősen részletes dokumentum, amely segítséget nyújt a függvénytár-fejlesztés és a részletes függvénytár-hozzájárulások létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="97ce9-108">This is a fairly detailed document that's intended to help guide library development and in-depth library contributions.</span></span>
> <span data-ttu-id="97ce9-109">Valószínűleg hasznosnak fogja találni a saját kódtárak megírását a Q #-ban, vagy ha nagyobb funkciókkal járul hozzá a [q # librarys tárházhoz](https://github.com/microsoft/QuantumLibraries).</span><span class="sxs-lookup"><span data-stu-id="97ce9-109">You'll probably find it most useful if you're writing your own libraries in Q#, or if you're contributing larger features to the [Q# libraries repository](https://github.com/microsoft/QuantumLibraries).</span></span>
>
> <span data-ttu-id="97ce9-110">Ha szeretné megtudni, hogy miként járulhat hozzá általánosabban a Quantum Development Kit-hez, javasoljuk, hogy kezdje a [hozzájárulási útmutatóval](xref:microsoft.quantum.contributing).</span><span class="sxs-lookup"><span data-stu-id="97ce9-110">On the other hand, if you're looking to learn how to contribute to the Quantum Development Kit more generally, we suggest starting with the [contribution guide](xref:microsoft.quantum.contributing).</span></span>
> <span data-ttu-id="97ce9-111">Ha többet szeretne megtudni arról, hogy a Q #-kód formázása miért javasolt, érdemes lehet megtekinteni a [stílusra vonatkozó útmutatót](xref:microsoft.quantum.contributing.style).</span><span class="sxs-lookup"><span data-stu-id="97ce9-111">If you're looking for more general information about how we recommend formatting your Q# code, you may be interested in checking out the [style guide](xref:microsoft.quantum.contributing.style).</span></span>

## <a name="general-principles"></a><span data-ttu-id="97ce9-112">Általános alapelvek</span><span class="sxs-lookup"><span data-stu-id="97ce9-112">General Principles</span></span>

<span data-ttu-id="97ce9-113">**Kulcs elve:** Tegye elérhetővé a kvantum-alkalmazásokra koncentráló API-kat.</span><span class="sxs-lookup"><span data-stu-id="97ce9-113">**Key principle:** Expose APIs that places the focus on quantum applications.</span></span>

- <span data-ttu-id="97ce9-114">✅**Válassza ki a műveletek és** függvények nevét, amelyek az algoritmusok és alkalmazások magas szintű szerkezetét tükrözik.</span><span class="sxs-lookup"><span data-stu-id="97ce9-114">✅ **DO** choose operation and function names that reflect the   high-level structure of algorithms and applications.</span></span>
- <span data-ttu-id="97ce9-115">⛔️ **nem** tesz elérhetővé olyan API-kat, amelyek elsősorban az alacsony szintű megvalósítási részletekre összpontosítanak.</span><span class="sxs-lookup"><span data-stu-id="97ce9-115">⛔️ **DON'T** expose APIs that focus primarily on low-level   implementation details.</span></span>

<span data-ttu-id="97ce9-116">**Kulcs elve:** Az API-k tervezésének megkezdése minta-használati esetek használatával biztosíthatja, hogy az API-k könnyen használhatók legyenek.</span><span class="sxs-lookup"><span data-stu-id="97ce9-116">**Key principle:** Start each API design with sample use cases to ensure that APIs are intuitive to use.</span></span>

- <span data-ttu-id="97ce9-117">✅**Győződjön meg** arról, hogy a nyilvános API-k minden összetevőjének van megfelelő használati esete, és nem kell megterveznie az összes lehetséges felhasználást a Start menüből.</span><span class="sxs-lookup"><span data-stu-id="97ce9-117">✅ **DO** ensure that each component of a public API has a corresponding use case, rather than trying to design for all possible uses from the start.</span></span>
    <span data-ttu-id="97ce9-118">Másképpen fogalmazva, ne vezessen be nyilvános API-kat abban az esetben, ha azok hasznosak, de győződjön meg arról, hogy az API-k mindegyik része *konkrét* példát mutat be, amelyben hasznos lehet.</span><span class="sxs-lookup"><span data-stu-id="97ce9-118">Put differently, don't introduce public APIs in case they are useful, but make sure that each part of an API has a *concrete* example in which it will be useful.</span></span>

  <span data-ttu-id="97ce9-119">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-119">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-120">@"microsoft.quantum.canon.applytoeachca"felhasználható úgy, `ApplyToEachCA(H, _)` hogy a regisztereket egységes, a számos kvantum-algoritmusban közös feladatként készítse elő.</span><span class="sxs-lookup"><span data-stu-id="97ce9-120">@"microsoft.quantum.canon.applytoeachca" can be used as `ApplyToEachCA(H, _)` to prepare registers in a uniform superposition state, a common task in many quantum algorithms.</span></span> <span data-ttu-id="97ce9-121">Ugyanezt a műveletet számos más feladathoz is felhasználhatja előkészítési, numerikus és Oracle-alapú algoritmusokban.</span><span class="sxs-lookup"><span data-stu-id="97ce9-121">The same operation can also be used for many other tasks in preparation, numerics, and oracle-based algorithms.</span></span>

- <span data-ttu-id="97ce9-122">✅A **brainstorming és** a workshop új API-ját úgy tervezze meg, hogy azok intuitívek legyenek, és megfeleljenek a javasolt használati eseteknek.</span><span class="sxs-lookup"><span data-stu-id="97ce9-122">✅ **DO** brainstorm and workshop new API designs to double-check   that they are intuitive and meet proposed use cases.</span></span>

  <span data-ttu-id="97ce9-123">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-123">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-124">Vizsgálja \# meg az aktuális Q-kódot, hogy megtudja, hogyan egyszerűsíthető az új API-k és a meglévő implementációk tisztázása.</span><span class="sxs-lookup"><span data-stu-id="97ce9-124">Inspect current Q\# code to see how new API designs could   simplify and clarify existing implementations.</span></span>
  - <span data-ttu-id="97ce9-125">Tekintse át a javasolt API-terveket az elsődleges célközönségek képviselőivel.</span><span class="sxs-lookup"><span data-stu-id="97ce9-125">Review proposed API designs with representatives of primary   audiences.</span></span>

<span data-ttu-id="97ce9-126">**Kulcs elve:** Tervezzen API-kat az olvasható kódok támogatásához és ösztönzéséhez.</span><span class="sxs-lookup"><span data-stu-id="97ce9-126">**Key principle:** Design APIs to support and encourage readable code.</span></span>

- <span data-ttu-id="97ce9-127">✅**Győződjön meg** arról, hogy a kód a tartományi szakértők és a nem szakértők számára is olvasható.</span><span class="sxs-lookup"><span data-stu-id="97ce9-127">✅ **DO** ensure that code is readable by domain experts and   non-experts alike.</span></span>
- <span data-ttu-id="97ce9-128">✅**Helyezze a** fókuszt az egyes műveletek és függvények hatására a magas szintű algoritmuson belül, a dokumentáció segítségével pedig szükség szerint illessze be a megvalósítás részleteit.</span><span class="sxs-lookup"><span data-stu-id="97ce9-128">✅ **DO** place the focus on the effects of each operation and   function within the high-level algorithm, using documentation to   delve into implementation details as appropriate.</span></span>
- <span data-ttu-id="97ce9-129">✅Ha alkalmazható **, kövesse a** közös [Q- \# stílus útmutatóját](xref:microsoft.quantum.contributing.style) .</span><span class="sxs-lookup"><span data-stu-id="97ce9-129">✅ **DO** follow the common [Q\# style guide](xref:microsoft.quantum.contributing.style) whenever applicable.</span></span>

<span data-ttu-id="97ce9-130">**Kulcs elve:** Az API-k megtervezése stabil és a továbbítási kompatibilitás biztosítása érdekében.</span><span class="sxs-lookup"><span data-stu-id="97ce9-130">**Key principle:** Design APIs to be stable and to provide forward compatibility.</span></span>

- <span data-ttu-id="97ce9-131">✅A régi API- **k elavultak** legyenek, ha a változtatások megszakadnak.</span><span class="sxs-lookup"><span data-stu-id="97ce9-131">✅ **DO** deprecate old APIs gracefully when breaking changes are   required.</span></span>

- <span data-ttu-id="97ce9-132">✅**Olyan "** alátét" műveleteket és függvényeket adjon meg, amelyek lehetővé teszik, hogy a meglévő felhasználói kód megfelelően működjön az elavulás során.</span><span class="sxs-lookup"><span data-stu-id="97ce9-132">✅ **DO** provide "shim" operations and functions that allow   existing user code to operate correctly during deprecation.</span></span>

  <span data-ttu-id="97ce9-133">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-133">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-134">Egy nevű művelet átnevezése során `EstimateExpectation` `EstimateAverage` egy új műveletet kell meghívnia, `EstimateExpectation` amely új néven hívja meg az eredeti műveletet, hogy a meglévő kód továbbra is megfelelően működjön.</span><span class="sxs-lookup"><span data-stu-id="97ce9-134">When renaming an operation called `EstimateExpectation` to   `EstimateAverage`, introduce a new operation called   `EstimateExpectation` that calls the original operation at   its new name, so that existing code can continue to work   correctly.</span></span>

- <span data-ttu-id="97ce9-135">✅**Használja az** @"microsoft.quantum.core.deprecated" attribútumot az elavultak a felhasználóval való kommunikációhoz.</span><span class="sxs-lookup"><span data-stu-id="97ce9-135">✅ **DO** use the @"microsoft.quantum.core.deprecated" attribute to communicate deprecations to the user.</span></span>

- <span data-ttu-id="97ce9-136">✅Egy művelet vagy függvény átnevezése **esetén adja meg** az új nevet karakterlánc-bemenetként `@Deprecated` .</span><span class="sxs-lookup"><span data-stu-id="97ce9-136">✅ When renaming an operation or function, **DO** provide the new   name as a string input to `@Deprecated`.</span></span>

- <span data-ttu-id="97ce9-137">⛔️ **ne** távolítsa el a meglévő függvényeket vagy műveleteket, ha az előzetes verziónál legalább hat hónapig elavult időszak van, vagy legalább két év a támogatott kiadásokhoz.</span><span class="sxs-lookup"><span data-stu-id="97ce9-137">⛔️ **DON'T** remove existing functions or operations without a   deprecation period of at least six months for preview releases,   or at least two years for supported releases.</span></span>

## <a name="functions-and-operations"></a><span data-ttu-id="97ce9-138">Függvények és műveletek</span><span class="sxs-lookup"><span data-stu-id="97ce9-138">Functions and Operations</span></span>

<span data-ttu-id="97ce9-139">**Kulcs elve:** gondoskodjon arról, hogy minden függvény és művelet egyetlen jól meghatározott céllal legyen az API-n belül.</span><span class="sxs-lookup"><span data-stu-id="97ce9-139">**Key principle:** ensure that every function and operation has a single well-defined purpose within the API.</span></span>

- <span data-ttu-id="97ce9-140">⛔️ **nem** tesznek elérhetővé több nem kapcsolódó feladatot végrehajtó függvényeket és műveleteket.</span><span class="sxs-lookup"><span data-stu-id="97ce9-140">⛔️ **DON'T** expose functions and operations that perform multiple   unrelated tasks.</span></span>

<span data-ttu-id="97ce9-141">**Kulcs elve:** a lehető legtöbbször felhasználható és a jövőbeli igényeknek megfelelő tervezési funkciókat és műveleteket kell megtervezni.</span><span class="sxs-lookup"><span data-stu-id="97ce9-141">**Key principle:** design functions and operations to be as reusable as possible, and to anticipate future needs.</span></span>

- <span data-ttu-id="97ce9-142">✅A **tervezési függvények** és műveletek a más függvényekkel és műveletekkel is összehozhatók, mind UGYANABBAN az API-ban, mind a korábban meglévő könyvtárakban.</span><span class="sxs-lookup"><span data-stu-id="97ce9-142">✅ **DO** design functions and operations to compose well with other   functions and operations, both in the same API and in previously   existing libraries.</span></span>

  <span data-ttu-id="97ce9-143">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-143">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-144">A @"microsoft.quantum.canon.delay" művelet minimális feltételezéseket biztosít a bemenetével kapcsolatban, így a Q # standard Library-ben vagy a felhasználók által meghatározott műveletek bármelyike esetében késleltetheti az alkalmazások használatát.</span><span class="sxs-lookup"><span data-stu-id="97ce9-144">The @"microsoft.quantum.canon.delay" operation makes minimal assumptions about its input, and thus can be used to delay applications of either operations across the Q# standard library or as defined by users.</span></span>
    <!-- TODO: define bad example. -->

- <span data-ttu-id="97ce9-145">✅A művelet helyett kizárólag klasszikus logikai determinisztikus **teheti** elérhetővé.</span><span class="sxs-lookup"><span data-stu-id="97ce9-145">✅ **DO** expose purely deterministic classical logic as   as functions rather than operations.</span></span>

  <span data-ttu-id="97ce9-146">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-146">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-147">Egy olyan alrutin, amely a lebegőpontos bemenetének négyzetes beírását is lehetővé teszi, determinisztikus módon, így nem műveletként kell a felhasználó számára elérhetőnek lennie `Squared : Double -> Double` `Square : Double => Double` .</span><span class="sxs-lookup"><span data-stu-id="97ce9-147">A subroutine which squares its floating-point input can be written deterministically, and so should be exposed to the user as `Squared : Double -> Double` rather than as an operation `Square : Double => Double`.</span></span> <span data-ttu-id="97ce9-148">Ez lehetővé teszi, hogy a alrutin több helyen legyen meghívva (pl.: más funkciókon belül), és hasznos optimalizálási információkat biztosít a fordítónak, amely hatással lehet a teljesítményre és az optimalizálásokra.</span><span class="sxs-lookup"><span data-stu-id="97ce9-148">This allows for the subroutine to be called in more places (e.g.: inside of other functions), and provides useful optimization information to the compiler that can affect performance and optimizations.</span></span>
  - <span data-ttu-id="97ce9-149">`ForEach<'TInput, 'TOutput>('TInput => 'TOutput, 'TInput[]) => 'TOutput[]`és `Mapped<'TInput, 'TOutput>('TInput -> 'TOutput, 'TInput[]) -> 'TOutput[]` különbözik a megkötések tekintetében nyújtott garanciákkal; mindkettő különböző helyzetekben hasznos.</span><span class="sxs-lookup"><span data-stu-id="97ce9-149">`ForEach<'TInput, 'TOutput>('TInput => 'TOutput, 'TInput[]) => 'TOutput[]` and `Mapped<'TInput, 'TOutput>('TInput -> 'TOutput, 'TInput[]) -> 'TOutput[]` differ in the guarantees made with respect to   determinism; both are useful in different circumstances.</span></span>
  - <span data-ttu-id="97ce9-150">A Quantum Operations alkalmazást átalakító API-rutinok gyakran determinisztikus módon hajthatók végre, így olyan függvényként is elérhetők, mint a `CControlled<'T>(op : 'T => Unit) => ((Bool, 'T) => Unit)` .</span><span class="sxs-lookup"><span data-stu-id="97ce9-150">API routines that transform the application of quantum   operations can often be carried out in a deterministic     fashion and hence can be made available as functions such as   `CControlled<'T>(op : 'T => Unit) => ((Bool, 'T) => Unit)`.</span></span>

- <span data-ttu-id="97ce9-151">✅**DO** Az egyes függvényekhez és műveletekhez az adott típus paramétereit igény szerint adja meg, és használja a bemeneti típust.</span><span class="sxs-lookup"><span data-stu-id="97ce9-151">✅ **DO** generalize the input type as much as reasonable for each   function and operation, using type parameters as needed.</span></span>

  <span data-ttu-id="97ce9-152">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-152">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-153">`ApplyToEach`a típusa `<'T>(('T => Unit), 'T[]) => Unit` nem a leggyakrabban használt alkalmazás típusa, hanem az adott típus `((Qubit => Unit), Qubit[]) => Unit` .</span><span class="sxs-lookup"><span data-stu-id="97ce9-153">`ApplyToEach` has type `<'T>(('T => Unit), 'T[]) => Unit` rather than the specific type of its most common   application, `((Qubit => Unit), Qubit[]) => Unit`.</span></span>

> [!TIP]
> <span data-ttu-id="97ce9-154">Fontos, hogy előre jelezze a jövőbeli igényeket, de fontos, hogy konkrét problémák megoldására is szükség van a felhasználók számára.</span><span class="sxs-lookup"><span data-stu-id="97ce9-154">It is important to anticipate future needs, but it is also important to solve concrete problems for your users.</span></span>
> <span data-ttu-id="97ce9-155">Ennek a kulcsfontosságú alapelveknek az alkalmazása ezért mindig alapos megfontolást és kiegyensúlyozást igényel az API-k "csak abban az esetben" való fejlesztése érdekében.</span><span class="sxs-lookup"><span data-stu-id="97ce9-155">Acting on this key principle thus always requires careful consideration and balancing to avoid developing APIs "just in case."</span></span>

<span data-ttu-id="97ce9-156">**Legfontosabb elv:** válassza a bemeneti és kimeneti típusok lehetőséget a kiszámítható, valamint a meghívásos művelet céljával kommunikáló függvények és műveletek számára.</span><span class="sxs-lookup"><span data-stu-id="97ce9-156">**Key principle:** choose input and output types for functions and operations that are predictable, and that communicate the purpose of a callable.</span></span>

- <span data-ttu-id="97ce9-157">✅**DO** A rekord típusú típusokkal logikailag csoportosíthatja azokat a bemeneteket és kimeneteket, amelyek csak akkor jelentősek, ha azokat együtt tekintik.</span><span class="sxs-lookup"><span data-stu-id="97ce9-157">✅ **DO** use tuple types to logically group inputs and outputs that are only significant when considered together.</span></span> <span data-ttu-id="97ce9-158">Ezekben az esetekben érdemes lehet felhasználó által definiált típust használni.</span><span class="sxs-lookup"><span data-stu-id="97ce9-158">Consider using a user-defined type in these cases.</span></span>

  <span data-ttu-id="97ce9-159">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-159">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-160">Előfordulhat, hogy egy másik függvény helyi minimális értékeinek kimenetére szolgáló függvénynek egy keresési időközt kell megadnia bemenetként, ami lehet `LocalMinima(fn : (Double -> Double), (left : Double, right : Double)) : Double` megfelelő aláírás.</span><span class="sxs-lookup"><span data-stu-id="97ce9-160">A function to output the local minima of another function   may need to take bounds of a search interval as input, such   that `LocalMinima(fn : (Double -> Double), (left : Double, right : Double)) : Double` may be an appropriate signature.</span></span>
  - <span data-ttu-id="97ce9-161">A Machine learning-osztályozó a paraméter-átváltási technikával való kiszámításához szükséges műveletnek az áthelyezett és a nem áthelyezett paramétereket is fel kell vennie bemenetként.</span><span class="sxs-lookup"><span data-stu-id="97ce9-161">An operation to estimate a derivative of a machine learning classifier using the parameter shift technique may need to take both the shifted and unshifted parameter vectors as inputs.</span></span> <span data-ttu-id="97ce9-162">Ebben az esetben a `(unshifted : Double[], shifted : Double[])` megfelelőhöz hasonló bemenetnek kell lennie.</span><span class="sxs-lookup"><span data-stu-id="97ce9-162">An input similar to `(unshifted : Double[], shifted : Double[])` may be appropriate in this case.</span></span>

- <span data-ttu-id="97ce9-163">✅A bemeneti és kimeneti rekordok lévő **elemek sorrendje** konzisztens legyen a különböző függvények és műveletek között.</span><span class="sxs-lookup"><span data-stu-id="97ce9-163">✅ **DO** order items in input and output tuples consistently   across different functions and operations.</span></span>

  <span data-ttu-id="97ce9-164">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-164">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-165">Ha két vagy több olyan függvényt vagy műveletet vizsgál, amelyek mindegyike elforgatási szöget és a célként megadott qubit bemenetként veszi figyelembe, ügyeljen arra, hogy mindegyik bemeneti rekordban azonos sorrendben legyenek rendezve.</span><span class="sxs-lookup"><span data-stu-id="97ce9-165">If considering two or functions or operations that each take a rotation angle and a target qubit as inputs, ensure that they are ordered the same in each input tuple.</span></span> <span data-ttu-id="97ce9-166">Ez inkább a és `ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl` `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` a `ApplyRotation(target : Qubit, angle : Double) : Unit is Adj + Ctl` és a `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="97ce9-166">That is, prefer `ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl` and `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` to `ApplyRotation(target : Qubit, angle : Double) : Unit is Adj + Ctl` and `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)`.</span></span>

<span data-ttu-id="97ce9-167">**Legfontosabb alapelv:** a Q \# nyelvi funkciókkal, például a részleges alkalmazásokkal jól használható tervezési függvények és műveletek.</span><span class="sxs-lookup"><span data-stu-id="97ce9-167">**Key principle:** design functions and operations to work well with Q\# language features such as partial application.</span></span>

- <span data-ttu-id="97ce9-168">✅A bemeneti rekordok **megrendelje** az elemeket úgy, hogy a leggyakrabban alkalmazott bemenetek először (pl.:, hogy a részleges alkalmazás a curry-hez hasonlóan működik).</span><span class="sxs-lookup"><span data-stu-id="97ce9-168">✅ **DO** order items in input tuples such that the most commonly   applied inputs occur first (i.e.: so that partial application   acts similarly to currying).</span></span>

  <span data-ttu-id="97ce9-169">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-169">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-170">Egy `ApplyRotation` lebegőpontos számot és egy qubit tartalmazó műveletet gyakran csak részben lehet a lebegőpontos bemenettel együtt alkalmazni, hogy először a típus bemenetét elvárt műveletekkel használják `Qubit => Unit` .</span><span class="sxs-lookup"><span data-stu-id="97ce9-170">An operation `ApplyRotation` that takes a floating-point number and a qubit as inputs may often be partially applied with the floating-point input first for use with operations that expect an input of type `Qubit => Unit`.</span></span> <span data-ttu-id="97ce9-171">Így a`operation ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl`</span><span class="sxs-lookup"><span data-stu-id="97ce9-171">Thus, a signature of `operation ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl`</span></span>
      <span data-ttu-id="97ce9-172">a leghatékonyabban együttműködik a részleges alkalmazásokkal.</span><span class="sxs-lookup"><span data-stu-id="97ce9-172">would work most consistently with partial application.</span></span>
  - <span data-ttu-id="97ce9-173">Ez az útmutató általában azt jelenti, hogy az összes klasszikus adatot a bemeneti rekordok összes qubits elé helyezi, de jó ítéletet használ, és megvizsgálja, hogyan hívják meg az API-t a gyakorlatban.</span><span class="sxs-lookup"><span data-stu-id="97ce9-173">Typically, this guidance means placing all classical data   before all qubits in input tuples, but use good judgment and   examine how your API is called in practice.</span></span>

## <a name="user-defined-types"></a><span data-ttu-id="97ce9-174">Felhasználó által definiált típusok</span><span class="sxs-lookup"><span data-stu-id="97ce9-174">User-Defined Types</span></span>

<span data-ttu-id="97ce9-175">**Legfontosabb elv:** felhasználói típusok használata az API-k egyszerűbb és kényelmes használatának megkönnyítéséhez.</span><span class="sxs-lookup"><span data-stu-id="97ce9-175">**Key principle:** use user-defined types to help make APIs more expressive and convenient to use.</span></span>

- <span data-ttu-id="97ce9-176">✅Az új, felhasználó által definiált típusok **bevezetésével** hasznos rövidítéseket biztosíthat a hosszú és/vagy bonyolult típusok számára.</span><span class="sxs-lookup"><span data-stu-id="97ce9-176">✅ **DO** introduce new user-defined types to provide helpful   shorthand for long and/or complicated types.</span></span>

  <span data-ttu-id="97ce9-177">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-177">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-178">Azokban az esetekben, amikor egy három qubit tömb bemenettel rendelkező Művelettípus általában bemenetként van megadva vagy kimenetként van visszaadva, egy UDT, például`newtype TimeDependentBlockEncoding = ((Qubit[], Qubit[], Qubit[]) => Unit is Adj + Ctl)`</span><span class="sxs-lookup"><span data-stu-id="97ce9-178">In cases where an operation type with three qubit array inputs is commonly taken as an input or returned as an output, providing a UDT such as `newtype TimeDependentBlockEncoding = ((Qubit[], Qubit[], Qubit[]) => Unit is Adj + Ctl)`</span></span>
      <span data-ttu-id="97ce9-179">hasznos rövidítést tud nyújtani.</span><span class="sxs-lookup"><span data-stu-id="97ce9-179">can help provide a useful shorthand.</span></span>

- <span data-ttu-id="97ce9-180">✅Az új, felhasználó által definiált **típusok bevezetése azt** jelzi, hogy egy adott alaptípust csak nagyon konkrét értelemben kell használni.</span><span class="sxs-lookup"><span data-stu-id="97ce9-180">✅ **DO** introduce new user-defined types to indicate that a given   base type should only be used in a very particular sense.</span></span>

  <span data-ttu-id="97ce9-181">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-181">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-182">Egy olyan műveletet, amelyet kifejezetten olyan műveletként kell értelmezni, amely a klasszikus adatmennyiséget egy kvantum-regiszterbe kódolja, célszerű lehet egy felhasználó által definiált típussal megjelölni `newtype InputEncoder = (Apply : (Qubit[] => Unit))` .</span><span class="sxs-lookup"><span data-stu-id="97ce9-182">An operation that should be interpreted specifically as an   operation that encodes classical data into a quantum   register may be appropriate to label with a user-defined   type `newtype InputEncoder = (Apply : (Qubit[] => Unit))`.</span></span>

- <span data-ttu-id="97ce9-183">✅Új, felhasználó által definiált típusokat **vezessen** be olyan névvel ellátott elemekkel, amelyek lehetővé teszik a későbbi bővíthetőséget (például: egy olyan eredmény-struktúra, amely további megnevezett elemeket tartalmazhat a jövőben).</span><span class="sxs-lookup"><span data-stu-id="97ce9-183">✅ **DO** introduce new user-defined types with named items that   allow for future extensibility (e.g.: a results structure that   may contain additional named items in the future).</span></span>

  <span data-ttu-id="97ce9-184">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-184">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-185">Ha egy művelet `TrainModel` nagy számú konfigurációs beállítást tesz elérhetővé, ezeket a beállításokat új UDT teszik közzé, `TrainingOptions` és egy új függvényt biztosítanak, amely `DefaultTrainingOptions : Unit -> TrainingOptions` lehetővé teszi a felhasználók számára, hogy a TrainingOptions UDT értékeiben felülbírálják a meghatározott megnevezett elemeket, miközben továbbra is lehetővé teszik a könyvtár-fejlesztők számára, hogy szükség szerint</span><span class="sxs-lookup"><span data-stu-id="97ce9-185">When an operation `TrainModel` exposes a large number of   configuration options, exposing these options as a new   `TrainingOptions` UDT and providing a new function   `DefaultTrainingOptions : Unit -> TrainingOptions` allows   users to override specific named items in TrainingOptions   UDT values while still allowing library developers to add   new UDT items as appropriate.</span></span>

- <span data-ttu-id="97ce9-186">✅Megnevezett **elemek deklarálása** új, felhasználó által definiált típusokhoz, amelyekkel a felhasználóknak ismerniük kell a megfelelő rekord dekonstrukcióját.</span><span class="sxs-lookup"><span data-stu-id="97ce9-186">✅ **DO** declare named items for new user-defined types in   preference to requiring users to know the correct tuple   deconstruction.</span></span>

  <span data-ttu-id="97ce9-187">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-187">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-188">Ha egy összetett számot képvisel a Polar dekompozícióban, inkább a következőhöz: `newtype ComplexPolar = (Magnitude: Double, Argument: Double)` `newtype ComplexPolar = (Double, Double)` .</span><span class="sxs-lookup"><span data-stu-id="97ce9-188">When representing a complex number in its polar   decomposition, prefer   `newtype ComplexPolar = (Magnitude: Double, Argument: Double)` to   `newtype ComplexPolar = (Double, Double)`.</span></span>

<span data-ttu-id="97ce9-189">**Legfontosabb alapelv:** a felhasználó által definiált típusok használata a kognitív terhelés csökkentése és a felhasználónak nem kell további fogalmakat és nómenklatúrát megtanulnia.</span><span class="sxs-lookup"><span data-stu-id="97ce9-189">**Key principle:** use user-defined types in ways reduce  cognitive load and that don't require the user to learn additional concepts and nomenclature.</span></span>

- <span data-ttu-id="97ce9-190">⛔️ **ne** vezessen be olyan felhasználó által definiált típusokat, amelyek megkövetelik a felhasználótól, hogy a kicsomagolási operátor () gyakori használatát igényli `!` , vagy amelyekhez gyakran több szintű kicsomagolásra van szükség.</span><span class="sxs-lookup"><span data-stu-id="97ce9-190">⛔️ **DON'T** introduce user-defined types that require the user to make frequent use of the unwrap operator (`!`), or that commonly require multiple levels of unwrapping.</span></span> <span data-ttu-id="97ce9-191">A lehetséges kockázatcsökkentő stratégiák a következők:</span><span class="sxs-lookup"><span data-stu-id="97ce9-191">Possible mitigation strategies include:</span></span>

  - <span data-ttu-id="97ce9-192">Amikor egy felhasználó által definiált típust adott meg egyetlen elemmel, érdemes lehet megadnia az adott elem nevét.</span><span class="sxs-lookup"><span data-stu-id="97ce9-192">When exposing a user-defined type with a single item, consider defining a name for that item.</span></span> <span data-ttu-id="97ce9-193">Vegyük például a következőt `newtype Encoder = (Apply : (Qubit[] => Unit is Adj + Ctl))` : `newtype Encoder = (Qubit[] => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="97ce9-193">For instance, consider `newtype Encoder = (Apply : (Qubit[] => Unit is Adj + Ctl))` in preference to `newtype Encoder = (Qubit[] => Unit is Adj + Ctl)`.</span></span>

  - <span data-ttu-id="97ce9-194">Annak biztosítása, hogy más függvények és műveletek is elfogadják a "becsomagolt" UDT-példányokat közvetlenül.</span><span class="sxs-lookup"><span data-stu-id="97ce9-194">Ensuring that other functions and operations can accept   "wrapped" UDT instances directly.</span></span>

- <span data-ttu-id="97ce9-195">⛔️ **ne** vezessen be olyan új, felhasználó által definiált típusokat, amelyek a beépített típusokat nem biztosítanak további kifejező.</span><span class="sxs-lookup"><span data-stu-id="97ce9-195">⛔️ **DON'T** introduce new user-defined types that duplicate   built-in types without providing additional expressiveness.</span></span>

  <span data-ttu-id="97ce9-196">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-196">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-197">A UDT `newtype QubitRegister = Qubit[]` nem biztosít további kifejező `Qubit[]` , és így nehezebben használható, és nem vehető igénybe.</span><span class="sxs-lookup"><span data-stu-id="97ce9-197">A UDT `newtype QubitRegister = Qubit[]` provides no   additional expressiveness over `Qubit[]`, and is thus harder   to use with no discernable benefit.</span></span>
  - <span data-ttu-id="97ce9-198">A UDT `newtype LittleEndian = Qubit[]` dokumentálja, hogy az alapul szolgáló regisztert hogyan kell használni és értelmezni, így további kifejező biztosít az alaptípusa alapján.</span><span class="sxs-lookup"><span data-stu-id="97ce9-198">A UDT `newtype LittleEndian = Qubit[]` documents how the   underlying register is to be used and interpreted, and thus   provides additional expressiveness over its base type.</span></span>

- <span data-ttu-id="97ce9-199">⛔️ csak akkor vezessen be hozzáférési feladatokat, **Ha nem feltétlenül** szükséges;   Ebben az esetben az elnevezett elemek erősen előnyben részesítettek.</span><span class="sxs-lookup"><span data-stu-id="97ce9-199">⛔️ **DON'T** introduce accessor functions unless strictly required;   strongly prefer named items in this case.</span></span>

  <span data-ttu-id="97ce9-200">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-200">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-201">A UDT bevezetéséhez `newtype Complex = (Double, Double)` inkább a definíciók módosítását kell módosítania a `newtype Complex = (Real : Double, Imag : Double)` függvények és a funkciók bevezetéséhez `GetReal : Complex -> Double` `GetImag : Complex -> Double` .</span><span class="sxs-lookup"><span data-stu-id="97ce9-201">When introducing a UDT `newtype Complex = (Double, Double)`,   prefer modifying the definition to   `newtype Complex = (Real : Double, Imag : Double)` to introducing   functions `GetReal : Complex -> Double` and   `GetImag : Complex -> Double`.</span></span>

## <a name="namespaces-and-organization"></a><span data-ttu-id="97ce9-202">Névterek és szervezet</span><span class="sxs-lookup"><span data-stu-id="97ce9-202">Namespaces and Organization</span></span>

<span data-ttu-id="97ce9-203">**Kulcs elve:** válassza ki a kiszámítható és a függvények, a műveletek és a felhasználó által definiált típusok nevét a névtérben.</span><span class="sxs-lookup"><span data-stu-id="97ce9-203">**Key principle:** choose namespace names that are predictable and that clearly communicate the purpose of functions, operations, and user-defined types in each namespace.</span></span>

- <span data-ttu-id="97ce9-204">✅**Nevezze el** a névtereket `Publisher.Product.DomainArea` .</span><span class="sxs-lookup"><span data-stu-id="97ce9-204">✅ **DO** name namespaces as `Publisher.Product.DomainArea`.</span></span>

  <span data-ttu-id="97ce9-205">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-205">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-206">A Microsoft a Quantum Development Kit Quantum szimulációs funkciójának részeként közzétett functions, Operations és UDT a `Microsoft.Quantum.Simulation` névtérbe kerül.</span><span class="sxs-lookup"><span data-stu-id="97ce9-206">Functions, operations, and UDTs published by Microsoft as a   part of the quantum simulation feature of the Quantum   Development Kit are placed in the   `Microsoft.Quantum.Simulation` namespace.</span></span>
  - <span data-ttu-id="97ce9-207">`Microsoft.Quantum.Math`a Microsoft által közzétett, a matematikai tartomány területéhez tartozó Quantum Development-készlet részeként közzétett névteret jelöli.</span><span class="sxs-lookup"><span data-stu-id="97ce9-207">`Microsoft.Quantum.Math` represents a namespace   published by Microsoft as part of the Quantum Development   Kit pertaining to the mathematics domain area.</span></span>

- <span data-ttu-id="97ce9-208">✅Az adott funkciókhoz használt műveletekkel, függvényekkel és felhasználó által definiált típusokkal olyan névteret **használhat,** amely leírja ezt a funkciót, még akkor is, ha az adott funkciót a különböző problémás tartományok között használják.</span><span class="sxs-lookup"><span data-stu-id="97ce9-208">✅ **DO** place operations, functions, and user-defined types used   for specific functionality into a namespace that describes that   functionality, even when that functionality is used across   different problem domains.</span></span>

  <span data-ttu-id="97ce9-209">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-209">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-210">A Microsoft által a Quantum Development Kit részeként közzétett állapot-előkészítési API-k bekerülnek a szolgáltatásba `Microsoft.Quantum.Preparation` .</span><span class="sxs-lookup"><span data-stu-id="97ce9-210">State preparation APIs published by Microsoft as a part of   the Quantum Development Kit would be placed into   `Microsoft.Quantum.Preparation`.</span></span>
  - <span data-ttu-id="97ce9-211">A Microsoft által a Quantum Development Kit részeként közzétett Quantum szimulációs API-k bekerülnek a szolgáltatásba `Microsoft.Quantum.Simulation` .</span><span class="sxs-lookup"><span data-stu-id="97ce9-211">Quantum simulation APIs published by Microsoft as a part of the Quantum   Development Kit would be placed into   `Microsoft.Quantum.Simulation`.</span></span>

- <span data-ttu-id="97ce9-212">✅**DO** A műveleteket, a függvényeket és a felhasználó által definiált típusokat csak meghatározott tartományokon belül, a segédprogram tartományát jelző névterekben használja.</span><span class="sxs-lookup"><span data-stu-id="97ce9-212">✅ **DO** place operations, functions, and user-defined types used only within specific domains into namespaces indicating their domain of utility.</span></span> <span data-ttu-id="97ce9-213">Ha szükséges, használjon alnévtereket az egyes tartományalapú névtereken belüli célzott feladatok jelzéséhez.</span><span class="sxs-lookup"><span data-stu-id="97ce9-213">If needed, use subnamespaces to indicate focused tasks within each domain-specific namespace.</span></span>

  <span data-ttu-id="97ce9-214">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-214">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-215">A Microsoft által közzétett Quantum Machine learning-függvénytár nagyrészt a @"microsoft.quantum.machinelearning" névtérbe kerül, de a névtér a példában szereplő adatkészleteket is megadja @"microsoft.quantum.machinelearning.datasets" .</span><span class="sxs-lookup"><span data-stu-id="97ce9-215">The quantum machine learning library published by Microsoft is largely   placed into the @"microsoft.quantum.machinelearning" namespace, but example   datasets are provided by the @"microsoft.quantum.machinelearning.datasets"   namespace.</span></span>
  - <span data-ttu-id="97ce9-216">A Microsoft által a Quantum Development Kit részeként közzétett Quantum kémia API-kat be kell helyezni `Microsoft.Quantum.Chemistry` .</span><span class="sxs-lookup"><span data-stu-id="97ce9-216">Quantum chemistry APIs published by Microsoft as a part of the Quantum Development Kit should be placed into `Microsoft.Quantum.Chemistry`.</span></span> <span data-ttu-id="97ce9-217">A Jordan--Wigner-bomlás megvalósítására vonatkozó funkciók a következő helyen helyezhetők el `Microsoft.Quantum.Chemistry.JordanWigner` , így a kvantum-kémia tartomány elsődleges felülete nem vonatkozik a megvalósításokra.</span><span class="sxs-lookup"><span data-stu-id="97ce9-217">Functionality specific to implementing the Jordan--Wigner decomposition may be placed in `Microsoft.Quantum.Chemistry.JordanWigner`, so that the primary interface for the quantum chemistry domain area is not concerned with implementations.</span></span>

<span data-ttu-id="97ce9-218">**Kulcs elve:** A névterek és a hozzáférés-módosítók együttes használata szándékos lehet a felhasználók számára elérhető API-felülettel, valamint az API-k megvalósításával és tesztelésével kapcsolatos belső adatok elrejtésével.</span><span class="sxs-lookup"><span data-stu-id="97ce9-218">**Key principle:** Use namespaces and access modifiers together to be intentional about the API surface exposed to users, and to hide internal details related to implementation and testing of your APIs.</span></span>

- <span data-ttu-id="97ce9-219">✅Ha ésszerű, minden olyan funkciót és műveletet helyezzen el, amely ahhoz **szükséges, hogy** az API-t ugyanahhoz a névtérhez adja, mint a megvalósított API-t, de a "Private" vagy a "belső" kulcsszavakkal van megjelölve, hogy azok nem részei a könyvtár nyilvános API-felületének.</span><span class="sxs-lookup"><span data-stu-id="97ce9-219">✅ Whenever reasonable, **DO** place all functions and operations needed to implement an API into the same namespace as the API being implemented, but marked with the "private" or "internal" keywords to indicate that they are not part of the public API surface for a library.</span></span> <span data-ttu-id="97ce9-220">Az aláhúzás () karakterrel kezdődő nevet használva `_` vizuálisan megkülönböztetheti a privát és belső műveleteket és funkciókat a nyilvános callables.</span><span class="sxs-lookup"><span data-stu-id="97ce9-220">Use a name beginning with an underscore (`_`) to visually distinguish private and internal operations and functions from public callables.</span></span>

  <span data-ttu-id="97ce9-221">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-221">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-222">A művelet neve `_Features` olyan függvényt jelöl, amely egy adott névtérhez és szerelvényhez tartozik, és a kulcsszónak kell kísérnie `internal` .</span><span class="sxs-lookup"><span data-stu-id="97ce9-222">The operation name `_Features` indicates a function that is   private to a given namespace and assembly, and should be   accompanied by either the `internal` keyword.</span></span>

- <span data-ttu-id="97ce9-223">✅Abban a ritka esetben, ha egy adott névtérhez tartozó API-k megvalósításához szükség van egy kiterjedt privát funkcióra vagy műveletre, **akkor** azokat egy új névtérbe helyezi, amely megfelel a megvalósított névtérnek, és a-ben végződik `.Private` .</span><span class="sxs-lookup"><span data-stu-id="97ce9-223">✅ In the rare case that an extensive set of private functions or operations are needed to implement the API for a given namespace, **DO** place them in a new namespace matching the namespace being implemented and ending in `.Private`.</span></span>

- <span data-ttu-id="97ce9-224">✅Az összes egység tesztet olyan névterekben **Helyezze el** , amelyek megfelelnek a névtérnek a tesztelés és a Befejezés szakaszban `.Tests` .</span><span class="sxs-lookup"><span data-stu-id="97ce9-224">✅ **DO** place all unit tests into namespaces matching the     namespace under test and ending in `.Tests`.</span></span>

## <a name="naming-conventions-and-vocabulary"></a><span data-ttu-id="97ce9-225">Elnevezési konvenciók és szókincs</span><span class="sxs-lookup"><span data-stu-id="97ce9-225">Naming Conventions and Vocabulary</span></span>

<span data-ttu-id="97ce9-226">**Kulcs elve:** Válassza ki azokat a neveket és terminológiát, amelyek egyértelmű, hozzáférhető és olvashatók különböző célközönségek között, beleértve a kvantum-kezdőket és a szakértőket is.</span><span class="sxs-lookup"><span data-stu-id="97ce9-226">**Key principle:** Choose names and terminology that are clear, accessible, and readable across a diverse range of audiences, including both quantum novices and experts.</span></span>

- <span data-ttu-id="97ce9-227">⛔️ **ne** használja a megkülönböztető vagy kizárási azonosító nevét, és az API-dokumentációs megjegyzésekben szereplő terminológiát sem.</span><span class="sxs-lookup"><span data-stu-id="97ce9-227">⛔️ **DON'T** use discriminatory or exclusionary identifier names,   nor terminology in API documentation comments.</span></span>

- <span data-ttu-id="97ce9-228">✅**Az API** -dokumentációs megjegyzések használatával biztosíthatja a megfelelő kontextust, példákat és referenciákat, különösen a bonyolultabb fogalmakat illetően.</span><span class="sxs-lookup"><span data-stu-id="97ce9-228">✅ **DO** use API documentation comments to provide relevant   context, examples, and references, especially for more difficult   concepts.</span></span>

- <span data-ttu-id="97ce9-229">⛔️ **ne** használjon feleslegesen ezoterikus azonosítókat, vagy amelyekben jelentős mennyiségű kvantum-algoritmust kell olvasni.</span><span class="sxs-lookup"><span data-stu-id="97ce9-229">⛔️ **DON'T** use identifier names that are unnecessarily esoteric,   or that require significant quantum algorithms knowledge to   read.</span></span>

  <span data-ttu-id="97ce9-230">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-230">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-231">A "amplitúdó-erősítési iteráció" a "a" a "a" a "a".</span><span class="sxs-lookup"><span data-stu-id="97ce9-231">Prefer "amplitude amplification iteration" to "Grover   iteration."</span></span>

- <span data-ttu-id="97ce9-232">✅**Válassza ki** a műveletek és a függvények nevét, amelyek világosan közlik a meghívottak kívánt hatását, és nem annak megvalósítását.</span><span class="sxs-lookup"><span data-stu-id="97ce9-232">✅ **DO** choose operations and function names that clearly communicate the intended effect of a callable, and not its implementation.</span></span> <span data-ttu-id="97ce9-233">Vegye figyelembe, hogy a megvalósítást az API- [dokumentációs megjegyzésekben](xref:microsoft.quantum.guide.filestructure#documentation-comments)kell dokumentálni.</span><span class="sxs-lookup"><span data-stu-id="97ce9-233">Note that the implementation can and should be documented in [API documentation comments](xref:microsoft.quantum.guide.filestructure#documentation-comments).</span></span>

  <span data-ttu-id="97ce9-234">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-234">*Examples:*</span></span>
  - <span data-ttu-id="97ce9-235">Inkább az "átfedés megbecslése" kifejezést a "Hadamard teszt" értékre, ahogy az utóbbi kommunikál az előző megvalósításával.</span><span class="sxs-lookup"><span data-stu-id="97ce9-235">Prefer "estimate overlap" to "Hadamard test," as the latter   communicates how the former is implemented.</span></span>

- <span data-ttu-id="97ce9-236">✅**Az összes** Q API-val egységes módon használja a szavakat \# :</span><span class="sxs-lookup"><span data-stu-id="97ce9-236">✅ **DO** use words in a consistent fashion across all Q\# APIs:</span></span>

  - <span data-ttu-id="97ce9-237">**Igék**</span><span class="sxs-lookup"><span data-stu-id="97ce9-237">**Verbs:**</span></span>

    - <span data-ttu-id="97ce9-238">**Érvényesítés**: Győződjön meg arról, hogy a célszámítógép és a qubits állapotáról feltételezi a feltételezést, valószínűleg a nem fizikai erőforrások használatával.</span><span class="sxs-lookup"><span data-stu-id="97ce9-238">**Assert**: Check that an assumption about the state of a target machine and its qubits holds, possibly by using unphysical resources.</span></span> <span data-ttu-id="97ce9-239">Az ezt a műveletet használó műveleteknek mindig biztonságosan eltávolíthatók, anélkül, hogy ez befolyásolná a kódtárak és a végrehajtható programok működését.</span><span class="sxs-lookup"><span data-stu-id="97ce9-239">Operations using this verb should always be safely removable without affecting the functionality of libraries and executable programs.</span></span> <span data-ttu-id="97ce9-240">Vegye figyelembe, hogy a tényekkel ellentétben az állítások általában külső állapottól függenek, például egy qubit-regisztráció, a végrehajtási környezet vagy így tovább.</span><span class="sxs-lookup"><span data-stu-id="97ce9-240">Note that unlike facts, assertions may in general depend on external state, such as the state of a qubit register, the execution environment or so forth.</span></span> <span data-ttu-id="97ce9-241">Mivel a külső állapottól való függőség egyfajta mellékhatás, a kijelentéseket függvények helyett műveleteknek kell kitenni.</span><span class="sxs-lookup"><span data-stu-id="97ce9-241">As dependency on external state is a kind of side effect, assertions must be exposed as operations rather than functions.</span></span>

    - <span data-ttu-id="97ce9-242">**Becslés**: egy vagy több valószínűleg ismétlődő mérés használata a mérési eredményekből származó klasszikus mennyiség megbecslése.</span><span class="sxs-lookup"><span data-stu-id="97ce9-242">**Estimate**: Using one or more possibly repeated   measurements, estimate a classical quantity from   measurement results.</span></span>

      <span data-ttu-id="97ce9-243">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-243">*Examples:*</span></span>
      - @"microsoft.quantum.characterization.estimatefrequency"
      - @"microsoft.quantum.characterization.estimateoverlapbetweenstates"

    - <span data-ttu-id="97ce9-244">**Előkészítés**: alkalmazzon egy vagy több olyan qubits, amely egy adott kezdeti állapotban indul (általában $ \ket{00\cdots 0} $), így a qubits állapota a kívánt befejezési állapotnak megfelelően alakulhat ki.</span><span class="sxs-lookup"><span data-stu-id="97ce9-244">**Prepare**: Apply a quantum operation or sequence of operations to one or more qubits assumed to start in a particular initial state (typically $\ket{00\cdots 0}$), causing the state of those qubits to evolve to a desired end state.</span></span> <span data-ttu-id="97ce9-245">Általánosságban elmondható, hogy a megadott kiindulási állapotban **kívüli állapotok** nem definiált egységes átalakítást eredményezhetnek, de továbbra is meg kell őrizniük, hogy egy művelet és a adjoint "megszakítása", és a No-op alkalmazása **szükséges** .</span><span class="sxs-lookup"><span data-stu-id="97ce9-245">In general, acting on states other than the given starting state **MAY** result in an undefined unitary transformation, but **SHOULD** still preserve that an operation and its adjoint "cancel out" and apply a no-op.</span></span>

      <span data-ttu-id="97ce9-246">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-246">*Examples:*</span></span>
      - @"microsoft.quantum.preparation.preparearbitrarystate"
      - @"microsoft.quantum.preparation.prepareuniformsuperposition"

    - <span data-ttu-id="97ce9-247">**Mérték**: egy vagy több qubits alkalmazza a kvantum-műveletet vagy a műveletek egy szakaszát, és olvassa ki a klasszikus adatok biztonsági mentését.</span><span class="sxs-lookup"><span data-stu-id="97ce9-247">**Measure**: Apply a quantum operation or sequence of   operations to one or more qubits, reading classical data   back out.</span></span>

      <span data-ttu-id="97ce9-248">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-248">*Examples:*</span></span>
      - @"microsoft.quantum.intrinsic.measure"
      - @"microsoft.quantum.arithmetic.measurefxp"
      - @"microsoft.quantum.arithmetic.measureinteger"

    - <span data-ttu-id="97ce9-249">**Alkalmazás**: egy vagy több qubits alkalmazza a kvantum-műveletet vagy a műveletek egy szakaszát, így a qubits állapota koherens módon változhat.</span><span class="sxs-lookup"><span data-stu-id="97ce9-249">**Apply**: Apply a quantum operation or sequence of operations to one or more qubits, causing the state of those qubits to change in a coherent fashion.</span></span> <span data-ttu-id="97ce9-250">Ez az ige a legáltalánosabb művelet a Q- \# nómenklatúrában, és **nem** használható, ha egy konkrétabb művelet közvetlen jelentőséggel bír.</span><span class="sxs-lookup"><span data-stu-id="97ce9-250">This verb is the most general verb in Q\# nomenclature, and **SHOULD NOT BE** used when a more specific verb is more directly relevant.</span></span>

  - <span data-ttu-id="97ce9-251">**Főnevek**:</span><span class="sxs-lookup"><span data-stu-id="97ce9-251">**Nouns**:</span></span>

    - <span data-ttu-id="97ce9-252">**Tény**: egy olyan logikai feltétel, amely csak a bemenettől függ, és nem a célszámítógép, a környezete vagy a gép qubits állapota alapján.</span><span class="sxs-lookup"><span data-stu-id="97ce9-252">**Fact**: A Boolean condition which depends only on its inputs and not on the state of a target machine, its environment, or the state of the machine's qubits.</span></span> <span data-ttu-id="97ce9-253">Egy állítással ellentétben a tény csak az adott tényhez megadott *értékekre* érzékeny.</span><span class="sxs-lookup"><span data-stu-id="97ce9-253">By contrast with an assertion, a fact is only sensitive to the *values* provided to that fact.</span></span> <span data-ttu-id="97ce9-254">Például:</span><span class="sxs-lookup"><span data-stu-id="97ce9-254">For example:</span></span>

      <span data-ttu-id="97ce9-255">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-255">*Examples:*</span></span>
      - <span data-ttu-id="97ce9-256">@"microsoft.quantum.diagnostics.equalityfacti": egy Esélyegyenlőségi tényt képvisel két egész számból álló bemenettel kapcsolatban; vagy a bemenetként megadott egész számok egyenlőek egymással, vagy nem, függetlenül attól, hogy a többi program állapota független-e.</span><span class="sxs-lookup"><span data-stu-id="97ce9-256">@"microsoft.quantum.diagnostics.equalityfacti": represents an equality fact about two integer inputs; either the integers provided as input are equal to each other, or they are not, independent of any other program state.</span></span>

    - <span data-ttu-id="97ce9-257">**Beállítások:** Olyan UDT, amely több megnevezett elemet tartalmaz, amelyek "választható argumentumként" működhetnek egy függvényhez vagy művelethez.</span><span class="sxs-lookup"><span data-stu-id="97ce9-257">**Options:** A UDT containing several named items that can act as "optional arguments" to a function or operation.</span></span> <span data-ttu-id="97ce9-258">Például:</span><span class="sxs-lookup"><span data-stu-id="97ce9-258">For example:</span></span>

      <span data-ttu-id="97ce9-259">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-259">*Examples:*</span></span>
      - <span data-ttu-id="97ce9-260">A @"microsoft.quantum.machinelearning.trainingoptions" UDT tartalmazza a tanulási sebesség, a minibatch-méret és más, a ml-képzéshez konfigurálható paraméterek elnevezett elemeit.</span><span class="sxs-lookup"><span data-stu-id="97ce9-260">The @"microsoft.quantum.machinelearning.trainingoptions" UDT includes named items for learning rate, minibatch size, and other configurable parameters for ML training.</span></span>

  - <span data-ttu-id="97ce9-261">**Melléknevek**:</span><span class="sxs-lookup"><span data-stu-id="97ce9-261">**Adjectives**:</span></span>

    - <span data-ttu-id="97ce9-262">⛔️ **új**: ezt a jelzőt **nem** szabad használni, mert így elkerülhető, hogy a használatot számos programozási nyelvben (pl.: C++, C#, Java, írógéppel, PowerShell) használják.</span><span class="sxs-lookup"><span data-stu-id="97ce9-262">⛔️ **New**: This adjective **SHOULD NOT** be used, as to avoid confusion   with its usage as a verb in many   programming languages (e.g.: C++, C#, Java, TypeScript, PowerShell).</span></span>

  - <span data-ttu-id="97ce9-263">**Alaphelyzetek:** Bizonyos esetekben a függvények és a műveletek neveiben a nevek és a műveletek további egyértelműsítse vagy tisztázására is használhatók az előírások.</span><span class="sxs-lookup"><span data-stu-id="97ce9-263">**Prepositions:** In some cases, prepositions can be used to further disambiguate or clarify the roles of nouns and verbs in function and operation names.</span></span> <span data-ttu-id="97ce9-264">Ezt a gondos és következetesen kell figyelembe venni.</span><span class="sxs-lookup"><span data-stu-id="97ce9-264">Care should be taken to do so sparingly and consistently, however.</span></span>

    - <span data-ttu-id="97ce9-265">**A következőképpen:** Azt jelzi, hogy a függvény bemenete és kimenete ugyanazokat az adatokat képviseli, de a kimenet az eredeti ábrázolás helyett *X* - **ként** jelöli meg az adatokat.</span><span class="sxs-lookup"><span data-stu-id="97ce9-265">**As:** Represents that a function's input and output represent the same information, but that the output represents that information **as** an *X* instead of its original representation.</span></span> <span data-ttu-id="97ce9-266">Ez különösen gyakori a Type Conversion functions esetében.</span><span class="sxs-lookup"><span data-stu-id="97ce9-266">This is especially common for type conversion functions.</span></span>

      <span data-ttu-id="97ce9-267">*Példák*</span><span class="sxs-lookup"><span data-stu-id="97ce9-267">*Examples:*</span></span>
      - <span data-ttu-id="97ce9-268">`IntAsDouble(2)`azt jelzi, hogy mind a bemenet ( `2` ), mind a kimenet ( `2.0` ) ugyanazt az információt jeleníti meg, de különböző Q \# adattípusokat használ.</span><span class="sxs-lookup"><span data-stu-id="97ce9-268">`IntAsDouble(2)` indicates that both the input (`2`) and the output (`2.0`)   represent qualitatively the same information, but using   different Q\# data types to do so.</span></span>

    - <span data-ttu-id="97ce9-269">**Forrás:** A konzisztencia biztosítása érdekében ez az előírás **nem** használható a Type Conversion functions vagy bármely más, a megfelelőnek **minősülő** eset jelzésére.</span><span class="sxs-lookup"><span data-stu-id="97ce9-269">**From:** To ensure consistency, this preposition   **SHOULD NOT** be used to indicate type conversion   functions or any other case where **As** is appropriate.</span></span>

    - <span data-ttu-id="97ce9-270">⛔️ **a** következőhöz: ezt az előfeltételt **nem** szabad használni, mert így elkerülhető, hogy a használatuk ne legyen több programozási nyelvben.</span><span class="sxs-lookup"><span data-stu-id="97ce9-270">⛔️ **To:** This preposition **SHOULD NOT** be used, as to   avoid confusion with its usage as a verb in many   programming languages.</span></span>
