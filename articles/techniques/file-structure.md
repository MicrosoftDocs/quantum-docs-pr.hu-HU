---
title: Quantum Development Techniques – bevezetés | Microsoft Docs
description: Quantum Development-technikák bemutatása
author: QuantumWriter
ms.author: Christopher.Granade@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 9c266fe16b8e2a265d91a99f8574a6acfcf03160
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: HT
ms.contentlocale: hu-HU
ms.lasthandoff: 10/26/2019
ms.locfileid: "73183250"
---
# <a name="what-is-q"></a><span data-ttu-id="ace90-103">Mi az a Q#?</span><span class="sxs-lookup"><span data-stu-id="ace90-103">What is Q#?</span></span> #

<span data-ttu-id="ace90-104">A Q # egy méretezhető, több paradigma, tartományszintű programozási nyelv a kvantum-számítástechnika számára.</span><span class="sxs-lookup"><span data-stu-id="ace90-104">Q# is a scalable, multi-paradigm, domain-specific programming language for quantum computing.</span></span> <span data-ttu-id="ace90-105">A Q # egy Quantum programozási nyelv, amelynek segítségével leírható, hogy a rendszer hogyan hajtja végre az utasításokat a kvantum-gépeken.</span><span class="sxs-lookup"><span data-stu-id="ace90-105">Q# is a quantum programming language in that it can be used to describe how instructions are executed on quantum machines.</span></span> <span data-ttu-id="ace90-106">Azok a gépek, amelyek megcélozható a szimulátorok és a tényleges kvantum-hardver között.</span><span class="sxs-lookup"><span data-stu-id="ace90-106">The machines that can be targeted range from simulators to actual quantum hardware.</span></span> <span data-ttu-id="ace90-107">A Q # méretezhető: egyszerű bemutató programokat írhat, például a teleportot, amely néhány qubits fut, de támogatja a nagyméretű és kifinomult programok írását is, mint például az összetett molekulák szimulálása, amelyeknek több millió qubits kell lennie.</span><span class="sxs-lookup"><span data-stu-id="ace90-107">Q# is scalable: it can be used to write simple demonstration programs like teleport that run on a few qubits, but also supports writing large, sophisticated programs such as simulations of complex molecules that will require large machines with millions of qubits.</span></span> <span data-ttu-id="ace90-108">Annak ellenére, hogy a nagyméretű fizikai gépek továbbra is a jövőben vannak, a Q # lehetővé teszi a programozók számára, hogy az összetett kvantum-algoritmusokat.</span><span class="sxs-lookup"><span data-stu-id="ace90-108">Even though large physical machines are still in the future, Q# allows a programmer to program complex quantum algorithms now.</span></span> <span data-ttu-id="ace90-109">Mi több, a Q # támogatja a különböző feladatokat, például a hibakeresést, a profilkészítést, az erőforrás-becslést és bizonyos speciális célú szimulációkat méretezhető módon.</span><span class="sxs-lookup"><span data-stu-id="ace90-109">What is more, Q# supports various tasks such as debugging, profiling, resource estimation, and certain special-purpose simulations in a scalable way.</span></span> 

<span data-ttu-id="ace90-110">Technikai szempontból a kvantum-program a klasszikus függvények egy adott készletének tekinthető, amely a meghívottak szerint a kvantum-áramköröket eredményezi.</span><span class="sxs-lookup"><span data-stu-id="ace90-110">From a technical perspective, a quantum program can be seen as a particular set of classical functions which, when called, generate quantum circuits as their side effects.</span></span> <span data-ttu-id="ace90-111">Ennek a nézetnek a fontos következménye, hogy a Q #-ban írt program nem qubits magukat közvetlenül, hanem azt is leírja, hogyan kommunikál a klasszikus vezérlő számítógépek a qubits.</span><span class="sxs-lookup"><span data-stu-id="ace90-111">An important consequence of that view is that a program written in Q# does not directly model qubits themselves, but rather describes how a classical control computer interacts with those qubits.</span></span>
<span data-ttu-id="ace90-112">A tervezés szerint a Q # így nem határozza meg a kvantum-állapotokat vagy a kvantummechanika egyéb tulajdonságait közvetlenül, hanem a nyelvben definiált különböző alrutinok műveletén keresztül.</span><span class="sxs-lookup"><span data-stu-id="ace90-112">By design, Q# thus does not define quantum states or other properties of quantum mechanics directly, but rather does so indirectly through the action of the various subroutines defined in the language.</span></span>
<span data-ttu-id="ace90-113">Vegyük például a következőt: $ \ket{+} = \left (\ket{0} + \ket{1}\right)/\sqrt{2}$ a [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) útmutatójában.</span><span class="sxs-lookup"><span data-stu-id="ace90-113">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="ace90-114">Ha ezt az állapotot Q #-ban szeretné felkészíteni, a qubits a $ \ket{0}$ állapotban inicializálja, és hogy a $ \ket{+} = H\ket{0}$, ahol $H $ a Hadamard-átalakító:</span><span class="sxs-lookup"><span data-stu-id="ace90-114">To prepare this state in Q#, we use the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the Hadamard transform:</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0〉.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0〉 = |+〉, as we wanted.
}
```
## <a name="q-tranformations-of-quantum-states"></a><span data-ttu-id="ace90-115">Q # tranformations Quantum állapotok</span><span class="sxs-lookup"><span data-stu-id="ace90-115">Q# tranformations of quantum states</span></span>

<span data-ttu-id="ace90-116">Fontos, hogy a fenti program írásakor nem kifejezetten a Q #-on belüli állapotra hivatkozunk, hanem azt is, hogy a program hogyan *alakította át* az állapotot.</span><span class="sxs-lookup"><span data-stu-id="ace90-116">Importantly, in writing the above program, we did not explicitly refer to the state within Q#, but rather described how the state was *transformed* by our program.</span></span>
<span data-ttu-id="ace90-117">Így a Graphics shader program az egyes csúcspontokra való átalakítások leírását is hasonlítja össze, a Q #-ban lévő Quantum program pedig a kvantum-állapotokra gyűjti az átalakításokat.</span><span class="sxs-lookup"><span data-stu-id="ace90-117">Thus, similar to how a graphics shader program accumulates a description of transformations to each vertex, a quantum program in Q# accumulates transformations to quantum states.</span></span>
<span data-ttu-id="ace90-118">Ez lehetővé teszi számunkra, hogy teljesen függetlenek legyenek attól, hogy milyen kvantum-állapotot biztosítanak *az egyes* célszámítógépeken, ami különböző értelmezésekkel rendelkezhet a gépen.</span><span class="sxs-lookup"><span data-stu-id="ace90-118">This allows us to be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="ace90-119">A Q # program szemszögéből a qubit egy teljesen átlátszatlan hivatkozás a célszámítógép belső struktúrájára.</span><span class="sxs-lookup"><span data-stu-id="ace90-119">From the perspective of a Q# program, a qubit is an entirely opaque reference to the internal structure of a target machine.</span></span>
<span data-ttu-id="ace90-120">A Q # programnak nincs lehetősége arra, hogy betekintést végezzen egy qubit, annak ábrázolását a célszámítógépen, vagy akár ugyanazt a qubit, mint a program által elérhető többi qubit.</span><span class="sxs-lookup"><span data-stu-id="ace90-120">A Q# program has no ability to introspect into the state of a qubit, its representation on a target machine, or even whether it is the same qubit as any other qubit available to the program.</span></span>
<span data-ttu-id="ace90-121">Ehelyett a program olyan műveleteket hívhat meg, mint például a `Measure`, hogy qubit az információkat, és olyan műveleteket hívjon fel, mint például a `X` és a `H`, hogy egy qubit állapotára cselekedjenek.</span><span class="sxs-lookup"><span data-stu-id="ace90-121">Rather, a program can call operations such as `Measure` to learn information from a qubit, and call operations such as `X` and `H` to act on the state of a qubit.</span></span>
<span data-ttu-id="ace90-122">Ezeknek a műveleteknek nincs belső definíciója a nyelven belül, és csak az adott Q # program futtatására használt célszámítógép végzi el a konkrét műveleteket.</span><span class="sxs-lookup"><span data-stu-id="ace90-122">These operations have no intrinsic definition within the language, and are made concrete only by the target machine used to run a particular Q# program.</span></span>
<span data-ttu-id="ace90-123">A Q # program újrakombinálja ezeket a műveleteket a célszámítógép által meghatározott módon, hogy új, magasabb szintű műveleteket hozzon létre a kvantum-számításokhoz.</span><span class="sxs-lookup"><span data-stu-id="ace90-123">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="ace90-124">Így a Q # megkönnyíti a kvantum-és hibrid kvantum-klasszikus algoritmusok kiépítését, ugyanakkor általános megoldást is biztosít a célszámítógép vagy a szimulátor struktúrájára vonatkozóan.</span><span class="sxs-lookup"><span data-stu-id="ace90-124">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum-classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="ace90-125">Q # műveletek és függvények</span><span class="sxs-lookup"><span data-stu-id="ace90-125">Q# operations and functions</span></span>

<span data-ttu-id="ace90-126">Konkrétan a Q # program egy vagy több *műveletből*áll, egy vagy több *függvényből*és egy felhasználó által definiált típusból.</span><span class="sxs-lookup"><span data-stu-id="ace90-126">Concretely, a Q# program is comprised of one or more *operations*, one or more *functions*, and user defined types.</span></span> <span data-ttu-id="ace90-127">A műveletek a kvantum-gép állapotának átalakítását írják le, és a Q # programok legalapvetőbb építőelemei.</span><span class="sxs-lookup"><span data-stu-id="ace90-127">Operations are used to describe the transformations of the state of a quantum machine and are the most basic building block of Q# programs.</span></span> <span data-ttu-id="ace90-128">A Q # által meghatározott minden művelet hívhat tetszőleges számú egyéb műveletet, beleértve a célszámítógép által megvalósított beépített *belső* műveleteket is.</span><span class="sxs-lookup"><span data-stu-id="ace90-128">Each operation defined in Q# may then call any number of other operations, including the built-in *intrinsic* operations implemented by a target machine.</span></span>
<span data-ttu-id="ace90-129">A fordítás során az egyes műveletek .NET-osztályként jelennek meg, amely megadható a célszámítógép számára.</span><span class="sxs-lookup"><span data-stu-id="ace90-129">When compiled, each operation is represented as a .NET class type that can be provided to target machines.</span></span>

<span data-ttu-id="ace90-130">A műveletekkel szemben a függvények a tisztán klasszikus viselkedés leírására szolgálnak, és nem gyakorolnak semmilyen hatást a klasszikus számítástechnikai értékek mellett.</span><span class="sxs-lookup"><span data-stu-id="ace90-130">In contrast to operations, functions are used to describe purely classical behavior and do not have any effects besides computing classical output values.</span></span> <span data-ttu-id="ace90-131">A Q # egy erősen gépelt nyelv, amely beépített primitív típusokat és a felhasználó által definiált típusok támogatását is tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="ace90-131">Q# is a strongly typed language and comes with a set of built-in primitive types as well as support for user defined types.</span></span> 

<span data-ttu-id="ace90-132">Az útmutató további részében azt fogjuk látni, hogyan használhatunk különböző nyelvi fogalmakat és szerkezeteket a műveletek, függvények és típusok alapvető építőelemei segítségével.</span><span class="sxs-lookup"><span data-stu-id="ace90-132">Throughout the rest of this guide, we will see how to use different language concepts and constructs to help us define complex quantum programs through the basic building blocks of operations, functions, and types.</span></span> 

## <a name="structure-of-q-source-files"></a><span data-ttu-id="ace90-133">A Q # forrásfájlok szerkezete</span><span class="sxs-lookup"><span data-stu-id="ace90-133">Structure of Q# Source Files</span></span>

<span data-ttu-id="ace90-134">Minimálisan a Q # forrásfájl egy *névtér-deklarációból*áll, amely egy olyan .net-névteret határoz meg, amely a forrásfájl definícióit fogja tartalmazni.</span><span class="sxs-lookup"><span data-stu-id="ace90-134">Minimally, a Q# source file consists of a *namespace declaration*, which specifies a .NET namespace which will contain the definitions in the source file.</span></span>
<span data-ttu-id="ace90-135">A más Q # forrásfájlokat és könyvtárakat tartalmazó definíciók a `open` utasítás használatával is felvehetők.</span><span class="sxs-lookup"><span data-stu-id="ace90-135">Definitions from other Q# source files and libraries can be included using the `open` statement.</span></span>
<span data-ttu-id="ace90-136">Az alapvető kapukat meghatározó műveletek többsége például a <xref:microsoft.quantum.intrinsic> névtérben van meghatározva.</span><span class="sxs-lookup"><span data-stu-id="ace90-136">For instance, most of the operations defining fundamental gates are defined in the <xref:microsoft.quantum.intrinsic> namespace.</span></span>
<span data-ttu-id="ace90-137">Ahhoz, hogy ez elérhető legyen a kód számára, egyszerűen `open` a névteret az egyes fájlok tetején:</span><span class="sxs-lookup"><span data-stu-id="ace90-137">To make this available to our code, we simply `open` that namespace at the top of each file:</span></span>

```qsharp
namespace Example {
    open Microsoft.Quantum.Intrinsic;

    // ...
}
```

<span data-ttu-id="ace90-138">A névtéren belül minden Q # forrásfájl meghatározhatja a *műveletek*, a *függvények*és a *felhasználó által definiált típusok*tetszőleges kombinációját.</span><span class="sxs-lookup"><span data-stu-id="ace90-138">Within a namespace, each Q# source file can define any combination of *operations*, *functions*, and *user-defined types*.</span></span>
<span data-ttu-id="ace90-139">A szakasz további részében bemutatjuk, hogyan használhatók a gyakorlatban a hasznos kvantum-programok használatával.</span><span class="sxs-lookup"><span data-stu-id="ace90-139">In the rest of this section, we will describe each in turn and provide examples of how they can be used in practice to make useful quantum programs.</span></span>
