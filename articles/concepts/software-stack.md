---
title: Szoftveres verem | Microsoft Docs
description: Szoftveres verem
author: QuantumWriter
uid: microsoft.quantum.concepts.software-stack
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: f97dfacf6cde5fa92e1f368efaae36554a5c944d
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 10/28/2019
ms.locfileid: "73184729"
---
# <a name="software-stack-for-quantum-computing"></a><span data-ttu-id="2a84d-103">Szoftveres verem a kvantum-számítástechnika számára</span><span class="sxs-lookup"><span data-stu-id="2a84d-103">Software stack for quantum computing</span></span>
<span data-ttu-id="2a84d-104">Normál esetben, ha egy olyan számítógépet gondolunk, amely egy alkalmazást futtató egyetlen eszközt képzel el, de a modern számítástechnikai környezetek sokkal összetettebbek és fejlettebbek.</span><span class="sxs-lookup"><span data-stu-id="2a84d-104">Normally when we think of a computer we envision a single device running an application, but modern computing environments are much more complex and advanced.</span></span> <span data-ttu-id="2a84d-105">Az alkalmazás, amelyet általában a több rétegben dolgozunk fel, az alkalmazás futtatását a hardver szintjén biztosítjuk.</span><span class="sxs-lookup"><span data-stu-id="2a84d-105">The application we interact with typically rests on multiple layers of software that provide for the application's execution down to the hardware level.</span></span> <span data-ttu-id="2a84d-106">Ezek a szoftverek a teljes számítástechnikai rendszer összetettsége alapján elvonták az alkalmazási megoldások fejlesztését.</span><span class="sxs-lookup"><span data-stu-id="2a84d-106">These software layers are necessary to abstract the development of an application solution from the underlying complexity of the complete computing system.</span></span> <span data-ttu-id="2a84d-107">Ha egy fejlesztőnek a Bus, a cache-architektúrák, a kommunikációs protokollok és több más egyszerű okostelefon-alkalmazás írásakor kellene meggondolnia, a feladat sokkal összetettebb lesz.</span><span class="sxs-lookup"><span data-stu-id="2a84d-107">If a developer had to think about bus, cache architectures, communication protocols, and more while writing a simple smartphone app, the task would become much more complex.</span></span>  <span data-ttu-id="2a84d-108">A *szoftveres verem* koncepcióját a klasszikus számítástechnikai szolgáltatás fejlesztette ki a problémák megoldásához.</span><span class="sxs-lookup"><span data-stu-id="2a84d-108">The concept of a *software stack* was developed in classical computing to address these issues.</span></span>  <span data-ttu-id="2a84d-109">A klasszikus koncepció alapján a szoftveres verem a kvantum-számítástechnika mögötti elképzelés kulcsfontosságú részét képezi a Q # megoldással.</span><span class="sxs-lookup"><span data-stu-id="2a84d-109">Borrowing from the classical concept, a software stack is also a key part of the vision behind quantum computing with Q#.</span></span>

## <a name="conventional-stack"></a><span data-ttu-id="2a84d-110">Hagyományos verem</span><span class="sxs-lookup"><span data-stu-id="2a84d-110">Conventional stack</span></span>
<span data-ttu-id="2a84d-111">A szoftveres verem mögötti legfontosabb elképzelés a rekurzió.</span><span class="sxs-lookup"><span data-stu-id="2a84d-111">The key idea behind a software stack is recursion.</span></span>  <span data-ttu-id="2a84d-112">Több beágyazott rétegből áll, amelyek elvonták az eszköz alacsonyabb szintjeinek részleteit a fejlesztőtől.</span><span class="sxs-lookup"><span data-stu-id="2a84d-112">It consists of several nested layers of interfaces that abstract the details of the lower levels of the device away from the developer.</span></span>  <span data-ttu-id="2a84d-113">A gyakran használt szoftverek például a ASP.NET (programozási nyelv) futtatását foglalják magukban az SQL Serveren (a kapcsolati adatbázis-kezelő rendszeren), amely a Windows Serveren futó Internet Information Services (egy webkiszolgálón) fut (a operációs rendszer), amely a számítógép hardverét irányítja.</span><span class="sxs-lookup"><span data-stu-id="2a84d-113">For example, a commonly used software stack involves running ASP.NET (a programming language), on top of SQL server (a relational database management system), which runs on top of Internet Information Services (a web server), which runs on top of Windows server (an operating system), which drives the computer hardware.</span></span>  <span data-ttu-id="2a84d-114">Ha a szoftvereket hierarchiaként tekinti meg, az egyik a ASP.NET szoftvereket is írhat anélkül, hogy meg kellene ismernie az alatta lévő összes szoftver alacsony szintű részleteit.</span><span class="sxs-lookup"><span data-stu-id="2a84d-114">By looking at software as a hierarchy, one can write software in ASP.NET without needing to understand the low-level details of all the software below it.</span></span>

## <a name="quantum-stack"></a><span data-ttu-id="2a84d-115">Quantum stack</span><span class="sxs-lookup"><span data-stu-id="2a84d-115">Quantum stack</span></span>

<span data-ttu-id="2a84d-116">A kvantum-számítástechnikai szoftveres verem elvileg nem különbözik egymástól, és a gyakorlatban a hagyományos stacknél alacsonyabb szinten működnek.</span><span class="sxs-lookup"><span data-stu-id="2a84d-116">The software stack in quantum computing is no different in principle, and in practice operates at a lower level than traditional stacks.</span></span>  <span data-ttu-id="2a84d-117">Mire hasonlít a Quantum stack?</span><span class="sxs-lookup"><span data-stu-id="2a84d-117">What does a quantum stack look like?</span></span>  <span data-ttu-id="2a84d-118">A kvantum-számítógép nem helyettesíti a hagyományos (más néven klasszikus) számítógépeket.</span><span class="sxs-lookup"><span data-stu-id="2a84d-118">A quantum computer is not a replacement for traditional (often called classical) computers.</span></span>  <span data-ttu-id="2a84d-119">Valójában a kvantum-számítógépek szinte természetesen a klasszikus számítógépekkel párhuzamosan működnek a számítási problémák megoldásához.</span><span class="sxs-lookup"><span data-stu-id="2a84d-119">In fact, quantum computers will almost certainly work in tandem with classical computers to solve computational problems.</span></span>  <span data-ttu-id="2a84d-120">Ebben az esetben ez a kvantum-adatmennyiség bizonytalansága miatt fordul elő.</span><span class="sxs-lookup"><span data-stu-id="2a84d-120">In part, this arises because of the fragility of quantum data.</span></span>  <span data-ttu-id="2a84d-121">A kvantum-adatok annyira törékenyek, hogy ha még azt is észleli, hogy szinte biztosan megsérült a megfigyelt információ.</span><span class="sxs-lookup"><span data-stu-id="2a84d-121">Quantum data is so fragile that if you even look at it you almost certainly damage the information being observed.</span></span>  <span data-ttu-id="2a84d-122">A kvantum-számítógépeket ezért a kvantum-hibák javításával kell tervezni, hogy a fizikai környezetből érkező kóbor interakciók ne okozzák véletlenül az információt és a számítást.</span><span class="sxs-lookup"><span data-stu-id="2a84d-122">Quantum computers will thus need to be designed with quantum error correction in mind so that stray interactions from its physical environment do not inadvertently damage the information and computation.</span></span> <span data-ttu-id="2a84d-123">Emiatt a Q # egyik természetes célpontja egy hiba-korrigált kvantum-számítógép (más néven hibatűrő kvantum *-* számítógép), amely fogadja a kvantum-utasítások (Gates vagy Gate művelet) listáját, és alkalmazza ezeket az utasításokat a kvantumra. a benne tárolt adatkészletek.</span><span class="sxs-lookup"><span data-stu-id="2a84d-123">For this reason, a natural target for Q# is an error-corrected quantum computer (often called a *fault-tolerant* quantum computer) that accepts a list of quantum instructions (called gates or gate operations) and applies those instructions to the quantum data stored within it.</span></span>  <span data-ttu-id="2a84d-124">Vegye figyelembe, hogy ha egy Quantum algoritmusban vagy programban a qubits és a kapu műveleteinek száma elég kicsi, akkor előfordulhat, hogy a hibajavítás nem feltétlenül szükséges.</span><span class="sxs-lookup"><span data-stu-id="2a84d-124">Note that if the number of qubits and gate operations in a quantum algorithm or program is small enough, error correction may not be absolutely necessary.</span></span>  <span data-ttu-id="2a84d-125">A qubits és a Gate-műveletek számának növekedésével azonban minden bizonnyal követelmény lesz, így a szoftveres verem és a Q # felépítése a hibajavítások és a skálázható, hibatűrő és rugalmasan méretezhető számítási feladatok hatékony kezelésére szolgál.</span><span class="sxs-lookup"><span data-stu-id="2a84d-125">However as the number of qubits and gate operations grow, it will more certainly be a requirement, thus we architect our software stack and Q# to aptly and efficiently handle error correction and enable scalable, fault-tolerant quantum computing.</span></span>

### <a name="error-correction"></a><span data-ttu-id="2a84d-126">Hibajavítás</span><span class="sxs-lookup"><span data-stu-id="2a84d-126">Error correction</span></span>
<span data-ttu-id="2a84d-127">A hibajavításhoz egy gyors és megbízható klasszikus számítógépnek kell futnia a kvantum-számítógéppel, hogy kijavítsa a hibákat, amint azok megjelennek a kvantum-számításokban.</span><span class="sxs-lookup"><span data-stu-id="2a84d-127">Error correction requires a fast and reliable classical computer to be run in concert with the quantum computer to correct errors as they appear in the quantum computation.</span></span>  <span data-ttu-id="2a84d-128">A gyakorlatban az olyan összetevők, mint például a mező-programozható Gate-tömbök (FPGA-EK) vagy a gyors kriogén-processzorok, az olyan hibák azonosításához és kijavításához szükségesek, amelyek a kvantum-számítógépekben természetesen felhalmozódnak.</span><span class="sxs-lookup"><span data-stu-id="2a84d-128">In practice, components such as field-programmable gate arrays (FPGAs) or fast cryogenic processors may be needed to identify and correct the errors faster than they naturally accumulate in the quantum computer.</span></span>  <span data-ttu-id="2a84d-129">Ennek eredményeképpen a kvantum-számítógép olyan hibrid gép, amely számos különböző számítási eszközből áll, amelyek számos hőmérsékleten működnek.</span><span class="sxs-lookup"><span data-stu-id="2a84d-129">As a result, a quantum computer is a hybrid machine comprised of several different computational devices that operate over a wide range of temperatures.</span></span>  <span data-ttu-id="2a84d-130">Emiatt sokkal hasznosabb lehet a kvantum-számítógép programozása egy szoftveres verem segítségével, mivel a teljes mennyiségű hardveres és szoftveres (klasszikus és kvantum) réteg szükséges ahhoz, hogy végső soron a kvantum megvalósítását lehessen elérni. a kvantum-számítógép algoritmusa.</span><span class="sxs-lookup"><span data-stu-id="2a84d-130">For this reason, it is much more helpful to think about programming a quantum computer through the lens of a software stack, as there are many layers of hardware and software (classical and quantum) required to ultimately achieve the implementation of a quantum algorithm on a quantum computer.</span></span>

### <a name="quantum-conceptual-stack"></a><span data-ttu-id="2a84d-131">Quantum fogalmi verem</span><span class="sxs-lookup"><span data-stu-id="2a84d-131">Quantum conceptual stack</span></span>
<span data-ttu-id="2a84d-132">Alább látható egy fogalmi verem, amely bemutatja, hogy a 8704143553785700723 faktoring működési folyamata a kvantum-számítástechnikai környezetben a következő:</span><span class="sxs-lookup"><span data-stu-id="2a84d-132">A conceptual stack that illustrates the functional flow of factoring 8704143553785700723 in a quantum computing environment is shown below:</span></span>

![Szoftveres verem](~/media/concepts_stack.png)

### <a name="specification-and-algorithm"></a><span data-ttu-id="2a84d-134">Specifikáció és algoritmus</span><span class="sxs-lookup"><span data-stu-id="2a84d-134">Specification and algorithm</span></span>
<span data-ttu-id="2a84d-135">Az ilyen kvantum-számítások számos általános szakaszból állnak.</span><span class="sxs-lookup"><span data-stu-id="2a84d-135">There are several broad stages of programming such a quantum computation.</span></span>  <span data-ttu-id="2a84d-136">Az első, és vitathatatlanul a legnagyobb kihívást jelentő fázis a megoldás, amelyet az egyik meg kíván oldani.</span><span class="sxs-lookup"><span data-stu-id="2a84d-136">The first, and arguably most challenging phase, is specifying the problem that one wishes to solve.</span></span>  <span data-ttu-id="2a84d-137">Ebben az esetben a probléma az, hogy a 8704143553785700723-es számot egy két fő számból álló termékbe kell felvenni.</span><span class="sxs-lookup"><span data-stu-id="2a84d-137">In this case, the problem is to factor the number 8704143553785700723  into a product of two prime numbers.</span></span>  <span data-ttu-id="2a84d-138">A következő lépés egy algoritmus megtervezését foglalja magában a számítási probléma megoldásához.</span><span class="sxs-lookup"><span data-stu-id="2a84d-138">The next step involves designing an algorithm for solving this computational problem.</span></span>  <span data-ttu-id="2a84d-139">Ebben az esetben a rövid híres Quantum faktoring algoritmusa segítségével megtalálhatja a tényezőket.</span><span class="sxs-lookup"><span data-stu-id="2a84d-139">In this case, Shor's famous quantum factoring algorithm can be used to find the factors.</span></span>  <span data-ttu-id="2a84d-140">Ez az algoritmus Q # értékben van kifejezve, majd a Quantum Operations sorozata kimenete, amely egy idealizált, hibamentes kvantum-számítógépen futtatható.</span><span class="sxs-lookup"><span data-stu-id="2a84d-140">This algorithm is expressed in Q# and then a sequence of quantum operations is output that could be run on an idealized error-free quantum computer.</span></span>  

### <a name="physical-gates"></a><span data-ttu-id="2a84d-141">Fizikai kapuk</span><span class="sxs-lookup"><span data-stu-id="2a84d-141">Physical gates</span></span>
<span data-ttu-id="2a84d-142">Ebben a példában feltételezhető, hogy a természet nem olyan típusú, mint egy hibamentes kvantum-számítógép, így a következő lépés a Q # által kibocsátott műveleteket veszi át, és lefordítja őket a fizikai kapuk számára kiválasztott kvantum-hibajavítási módszer által megadott sablonok használatával. az alapszintű hardver végrehajtható.</span><span class="sxs-lookup"><span data-stu-id="2a84d-142">In this example, assume nature is not so kind as to provide an error-free quantum computer so the subsequent step takes the operations emitted by Q# and translates them using templates specified by the quantum error correction method chosen into physical gates that the basic hardware can execute.</span></span>  <span data-ttu-id="2a84d-143">Ez a folyamat magában foglalja az előző modellben leírt minden logikai qubit egy fizikai qubits való cseréjét, amely egy olyan redundáns módon tárolja és védik az adatokat, amely képes a helyi hibák elhárítására a fizikai környezeten belül az ilyen hibák észlelése és javítása qubits elég hosszú.</span><span class="sxs-lookup"><span data-stu-id="2a84d-143">This process involves replacing every logical qubit described in the previous model with a host of physical qubits that are used to store and protect the information within a single qubit in a redundant fashion that can resist local errors on the constituent physical qubits long enough for such errors to be detected and corrected.</span></span>  <span data-ttu-id="2a84d-144">Ugyanúgy, ahogy a Q # kód által leírt logikai qubits le kell cserélni számos fizikai qubits, hasonlóképpen a kimenetben ismertetett összes kvantum-kaput le kell fordítani a fizikai qubits alapuló fizikai kapuk sorába.</span><span class="sxs-lookup"><span data-stu-id="2a84d-144">Just as the logical qubits described by the Q# code need to be replaced with many physical qubits, similarly each quantum gate described in the output needs to be translated into a sequence of physical gates that act upon the physical qubits.</span></span>  <span data-ttu-id="2a84d-145">Emiatt a Q # kimenete ritkán a kvantum-számítástechnika végső célja, és további absztrakciós szintek szükségesek ahhoz, hogy a kód a hardveren egy feledékeny módon fusson.</span><span class="sxs-lookup"><span data-stu-id="2a84d-145">For this reason, the output of Q# is seldom the final target for quantum computing and further levels of abstraction are needed to execute the code on hardware in an oblivious fashion.</span></span>

### <a name="control-computer"></a><span data-ttu-id="2a84d-146">Számítógép vezérlése</span><span class="sxs-lookup"><span data-stu-id="2a84d-146">Control computer</span></span>
<span data-ttu-id="2a84d-147">A rendszer ezután betölti a fizikai Gate-sorozatot egy olyan normál számítógépre, amely elküldi ezeket az utasításokat egy olyan vezérlő számítógépnek, amely közvetlenül a kvantum-számítógéppel csatlakozik.</span><span class="sxs-lookup"><span data-stu-id="2a84d-147">The physical gate sequence is then loaded into an ordinary computer that sends these instructions down to a control computer that interfaces directly with the quantum computer.</span></span>  <span data-ttu-id="2a84d-148">A szoftveres veremben lévő réteget gyakran a kísérleti vezérlő szoftverek, például a [QCoDeS](http://qcodes.github.io/Qcodes/)kezelik.</span><span class="sxs-lookup"><span data-stu-id="2a84d-148">This layer within the software stack is often handled by experimental control software such as [QCoDeS](http://qcodes.github.io/Qcodes/).</span></span>

### <a name="interface-computer"></a><span data-ttu-id="2a84d-149">Csatoló számítógép</span><span class="sxs-lookup"><span data-stu-id="2a84d-149">Interface computer</span></span>
<span data-ttu-id="2a84d-150">A folyamat utolsó lépéseként a csatoló számítógépe először a kapukat a gyors vezérlésű számítógépnek megfelelően közvetíti.</span><span class="sxs-lookup"><span data-stu-id="2a84d-150">The final step in this process involves the interface computer first streaming the gates as needed to a fast control computer.</span></span> <span data-ttu-id="2a84d-151">Ezután a gyors vezérlésű számítógép alkalmazza a szükséges feszültségeket (általában impulzusok) a szükséges kapuk megvalósításához a qubits.</span><span class="sxs-lookup"><span data-stu-id="2a84d-151">Then the fast control computer applies the voltages needed (commonly called pulses) to implement the required gates on qubits.</span></span> <span data-ttu-id="2a84d-152">Ezt el kell végezni a kvantum-hibajavítás során észlelt hibák kijavítása során.</span><span class="sxs-lookup"><span data-stu-id="2a84d-152">This has to be done while correcting any errors that are observed through quantum error correction.</span></span>  <span data-ttu-id="2a84d-153">A kriogén FPGA vagy más egzotikus hardver szükséges lehet ezen lépések végrehajtásához a kvantum-számítógépen előforduló hibák száma alapján.</span><span class="sxs-lookup"><span data-stu-id="2a84d-153">Cryogenic FPGAs or other exotic hardware may be needed to perform these steps within the stringent time requirements imposed by the rate at which errors appear in the quantum computer.</span></span>  <span data-ttu-id="2a84d-154">Az ezen a szinten található célnyelv gyakran [VHDL](https://en.wikipedia.org/wiki/VHDL), ami azt feltételezi, hogy a verem felső végén használt módszernek a Quantum algoritmus leírását kell elemezni.</span><span class="sxs-lookup"><span data-stu-id="2a84d-154">The target language on this level is often [VHDL](https://en.wikipedia.org/wiki/VHDL), which requires a distinct way of thinking from that which is used at the top end of the stack to parse a description of a quantum algorithm.</span></span>

### <a name="the-q-quantum-programming-language"></a><span data-ttu-id="2a84d-155">A Q # Quantum programozási nyelv</span><span class="sxs-lookup"><span data-stu-id="2a84d-155">The Q# quantum programming language</span></span>
<span data-ttu-id="2a84d-156">A Q # célja, hogy egy egyszerű nyelvet adjon meg, amely lehetővé teszi a fejlesztők számára, hogy olyan kódot írjanak elő, amely a felhasználó és a kvantum-eszköz között álló, beavatkozó réteggel rendelkező, a felhasználók és a kvantum-eszközök közötti adatmennyiséget célozza meg.</span><span class="sxs-lookup"><span data-stu-id="2a84d-156">The aim of Q# is to provide a simple language that allows developers to write code that targets a wealth of quantum computing platforms and interface with the intervening layers of software that stand between the user and the quantum device.</span></span>  <span data-ttu-id="2a84d-157">A nyelv megkönnyíti ezt azáltal, hogy bevezeti egy szoftver-verem fogalmát, és az alapul szolgáló kvantum-számítógép számos részletét kiveszi, miközben a verem más szintjein keresztül C#teszi elérhetővé a szükséges a Q # kód és az alapvető műveletek közötti fordítások.</span><span class="sxs-lookup"><span data-stu-id="2a84d-157">The language facilitates this by embracing the notion of a software stack and abstracting many of the details of the underlying quantum computer while allowing other levels of the stack, exposed through a language such as C#, to perform the necessary translations from Q# code to fundamental operations.</span></span>  <span data-ttu-id="2a84d-158">Ez lehetővé teszi, hogy a fejlesztő a legjobban a legjobbra koncentráljon: algoritmusok tervezése és problémák megoldása.</span><span class="sxs-lookup"><span data-stu-id="2a84d-158">This allows the developer to focus on what they do best: designing algorithms and solving problems.</span></span>
